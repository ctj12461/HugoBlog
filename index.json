[{"categories":["笔记"],"content":"高斯消元主要用于求解线性方程组的解，同时可以解决某些有后效性的 DP 问题， 算法思想 增广矩阵 为了更方便地求解方程组，可以将系数和常数项放入矩阵，接下来就可以用一些矩阵的操作来消元了。 比如有一个方程组如下： $$ \\begin{cases} 3x+2y+3z=10\\\\ 3x+y+4z=12\\\\ x+y+z=4 \\end{cases} $$ 我们可以这么用矩阵表示: $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \\\\ 3 \u0026 1 \u0026 4 \\\\ 1 \u0026 1 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 10 \\\\ 12 \\\\ 1 \\end{bmatrix} $$ 在理论分析和实现代码时，为了方便，通常把两个矩阵拼在一起，这个矩阵就是增广矩阵： $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \u0026 10 \\\\ 3 \u0026 1 \u0026 4 \u0026 12 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \\end{bmatrix} $$ 增广矩阵的第 $i$ 行代笔第 $i$ 个方程，第 $i$ 列表示第 $i$ 个未知数的系数或常数项，接下来用 $x_i$ 表示第 $i$ 个未知数。 初等行变换 初等行变换是指行之间的加减乘等运算。消元的本质就是利用初等行变换，使未知数的系数变为 $0$。具体地，初等行变换是两个行中的元素逐一进行运算，以上面的矩阵为例，记 $row_i$ 表示第 $i$ 行，则 $row_2 \\longleftarrow row_2 - \\frac{2}{3}row_1$ 的结果就是： $$ \\begin{bmatrix} 0 \u0026 -2 \u0026 -\\frac{1}{2} \u0026 -3 \\end{bmatrix} $$ 这个操作使该行的第 $1$ 个元素变为了 $0$，从方程的意义上考虑，就是消去了一个元。 三角矩阵和对角矩阵 三角矩阵是指一个矩阵的一个三角部分全部为 $0$，对角矩阵则是对角线之外的元素均为 $0$。高斯消元中，三角矩阵一般指下三角矩阵，对角矩阵一般指除常数项部分为对角矩阵的矩阵。 假设得到了一个对角矩阵： $$ \\begin{bmatrix} k_1 \u0026 0 \u0026 0 \u0026 c_1\\\\ 0 \u0026 k_2 \u0026 0 \u0026 c_2\\\\ 0 \u0026 0 \u0026 k_3 \u0026 c_3 \\end{bmatrix} $$ 那就相当于是一个个的一元线性方程，直接解出即可。而对角矩阵可以通过三角矩阵得出： $$ \\begin{bmatrix} k_{11} \u0026 k_{12} \u0026 k_{13} \u0026 c_1\\\\ 0 \u0026 k_{22} \u0026 k_{23} \u0026 c_2\\\\ 0 \u0026 0 \u0026 k_{33} \u0026 c_3 \\end{bmatrix} $$ 首先可以解出 $x_3$，然后将 $x_3$ 带入第 $2$ 个方程，则 $k_{23}x_3$ 就成为了常数项，移项一下得到： $$ \\begin{bmatrix} k_{11} \u0026 k_{12} \u0026 k_{13} \u0026 c_1\\\\ 0 \u0026 k_{22} \u0026 0 \u0026 c_2 - k_{23}x_3\\\\ 0 \u0026 0 \u0026 k_{33} \u0026 c_3 \\end{bmatrix} $$ 同理带入 $x_2,x_3$ 到第 $1$ 个方程： $$ \\begin{bmatrix} k_{11} \u0026 0 \u0026 0 \u0026 c_1 - k_{12}x_2 - k_{13}x_3\\\\ 0 \u0026 k_{22} \u0026 0 \u0026 c_2 - k_{23}x_3\\\\ 0 \u0026 0 \u0026 k_{33} \u0026 c_3 \\end{bmatrix} $$ 具体步骤与实例 只要从上往下将每行与它下面的行进行运算，每枚举一行就消去一个元，枚举第 $i$ 行则消去 $x_i$，即通过初等行变换把第 $i + 1$ 到 $n$ 的方程的 $x_i$ 系数变为 $0$。最后从下往上带入即可。 以上面的矩阵为例，这里就模拟到得到三角矩阵： $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \u0026 10 \\\\ 3 \u0026 1 \u0026 4 \u0026 12 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \\end{bmatrix} $$ Step 1: $row_2 \\longleftarrow row_2 - \\frac{2}{3}row_1$ $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \u0026 10 \\\\ 0 \u0026 -2 \u0026 -\\frac{1}{2} \u0026 -3 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \\end{bmatrix} $$ Step 2: $row_3 \\longleftarrow row_3 - \\frac{1}{2}row_1$ $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \u0026 10 \\\\ 0 \u0026 -2 \u0026 -\\frac{1}{2} \u0026 -3 \\\\ 0 \u0026 0 \u0026 -\\frac{1}{2} \u0026 -4 \\end{bmatrix} $$ Step 3: $row_3 \\longleftarrow row_3 - 0\\cdot row_2$ 增广矩阵不变。 高斯-约旦消元 由于计算机上浮点数的精度有限，要尽可能选择绝对值较大的数作为除数，所以枚举到第 $i$ 行时，可以找到 $x_i$ 的系数最大的方程，与当前行交换，这种方法叫做高斯-约旦消元法。 解的判断 方程组有可能有无数解（含自由元）或无解。得到一个对角矩阵后，若存在对角元素 $k_{ii} = 0$，而常数项 $c_i \\ne 0$，则无解，否则若存在对角元素 $k_{ii} = 0$，而常数项 $c_i = 0$，则含自由元。 代码实现 class EquationGroup { public: enum class Result { UNIQUE, INFINITY, NO_SOLUTION }; void init(int n) { this-\u003en = n; e = vector\u003cvector\u003cdouble\u003e\u003e(n + 1, vector\u003cdouble\u003e(n + 2)); } Equation \u0026operator[](int x) { return e[x]; } pair\u003cvector\u003cdouble\u003e, Result\u003e solve() { transform(); Result res = calc(); vector\u003cdouble\u003e x(n + 1); for (int i = 1; i \u003c= n; ++i) x[i] = e[i][n + 1]; return {x, res}; } private: vector\u003cvector\u003cdouble\u003e\u003e e; int n; // 未知数个数 void transform() { for (int i = 1; i \u003c= n; ++i) { int p = i; // 选择 e[][i] 绝对值最大的一行进行交换 for (int j = i + 1; j \u003c= n; ++j) if (abs(e[p][i]) \u003c abs(e[j][i])) p = j; if (p != i) for (int j = 1; j \u003c= n + 1; ++j) swap(e[i][j], e[p][j]); // 初等行变换 for (int j = i + 1; j \u003c= n; ++j) { double rate = e[j][i] / e[i][i]; for (int k = 1; k \u003c= n + 1; ++k) e[j][k] -= e[i][k] * rate; } } } Result calc() { Result res = Result::UNIQUE; for (int i = n; i \u003e= 1; --i) { // 把解 x_i 存在 e[i][n + 1] 中 for (int j = i + 1; j \u003c= n; ++j) e[i][n + 1] -= e[i][j] * e[j][n + 1]; if (!e[i][i]) { e[i][n + 1] /= e[i][i]; } else { if (e[i][n + 1]) res = Result::NO_SOLUTION; else if (res != Result::NO_SOLUTION) res = Result::INFINITY; } } return res; } }; 例题 Luogu P4035 球形空间产生器 给出一个 $n + 1$ 个 $n$ 维空间的点，求这 $n + 1$ 个点构成的 $n$ 维球体的球心。 $1 \\le n \\le 10$。 设球心为 $(x_1,x_2,\\dots,x_n)$，半径为 $r$，对于球体的某个点 $p$，有如下关系： $$ \\sum_{i = 1}^{n} (p_i - x_i) ^ 2 = r ^ 2\\\\ $$ 展开并移项得到： $$ \\sum_{i = 1}^{n} 2p_ix_i + (r ^ 2 - \\sum_{i = 1}^{n} x_i ^ 2) = \\sum_{i = 1}^{n} p_i ^ 2 $$ 把括号看成一个整体，显然是一个 $n + 1$ 元线性方程组，直接高斯消元求解。 #include \u003ciostream\u003e#include \u003ciomanip\u003e#include \u003ccmath\u003eusing namespace std; constexpr int MAXN = 10 + 5; int n; double pos[MAXN][MAXN], mat[MAXN][MAXN]; void preprocess() { ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:0:0","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["题解"],"content":"这里给出一种无需换根的 DP 思路。 Part 1 我们从结点的添加方式入手，可以把结点分为三类： 初始的结点，这种结点只有一个 通过 Append 添加的结点，以下简称 A 类结点 通过 Insert 添加的结点，以下简称 I 类结点 不换根的思路核心就在于保证转移时的过程符合结点的添加规则。为了方便，我们可以给每条线定向。同时假设 $1$ 为根，$x$ 为当前结点，$y$ 为 $x$ 的一个儿子结点，$fa$ 为 $x$ 的父亲结点。很显然接下来可以分 $6$ 类讨论： 若 $x$ 为初始结点，则其子结点、$fa$ 都应该连向 $x$ 若 $x$ 为 A 类结点 $x$ 向 $fa$ 连一条红线，子结点连向 $x$ $x$ 向其中一个子结点 $y$ 连一条红线，其他子结点以及 $fa$ 连向 $x$ 若 $x$ 为 I 类结点 $x$ 取代一个子结点 $y$ 连向 $fa$ 的红线，然后换成蓝线 $x$ 取代两个个子结点 $y_1$ 和 $y_2$ 之间的红线，然后换成蓝线 $x$ 取代 $fa$ 连向一个子结点 $y$ 的红线，然后换成蓝线 上面的分类讨论中的“连向”可以看成 Append 或 Insert，根据题意计算就可以了。 Part 2 接下来根据分类讨论设出状态以及写出方程： long long f[MAXN][6]; /** * f[x][0]: x is initial * f[x][1]: x -\u003e fa * f[x][2]: x -\u003e y * f[x][3]: y -\u003e x -\u003e fa * f[x][4]: y1 -\u003e x -\u003e y2 * f[x][5]: fa -\u003e x -\u003e y */ 设 $cont(x)$ 表示 $x$ 向其父结点连线的贡献，则 $cont(x)=\\max\\{f[x][1],f[x][3]+len(x,fa(x))\\}$。 $$ f[x][0]=\\sum_{y\\in son(x)}cont(y)\\\\ f[x][1]=\\sum_{y\\in son(x)}cont(y)\\\\ f[x][2]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{\\max\\{f[y][0], f[y][2], f[y][4], f[y][5] + len(y,x)\\}-cont(y)\\}\\\\ f[x][3]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{f[y][1]+len(y,x)-cont(y)\\}\\\\ f[x][4]=\\sum_{y\\in son(x)}cont(y)+\\\\\\max_{y_1,y_2\\in son(x)\\wedge y_1\\ne y_2}\\{ f[y_1][1]+len(y_1,x)-cont(y_1)+\\max\\{f[y_2][0], f[y_2][2], f[y_2][4]\\}+len(y_2,x)-cont(y_2)\\}\\\\ f[x][5]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{\\max\\{f[y][0], f[y][2], f[y][4]\\}+len(y,x)-cont(y)\\} $$ 上面的转移都可以看成先从子结点按照 $cont(x)$ 转移，在钦定某个结点按照特定的方式转移，记录下最优的差值在加到 $f$ 里即可。$f[x][4]$ 有两个变量，可以考虑枚举其中一个，用 std::multiset\u003cT\u003e 维护另外一个的最值即可。 时间复杂度 $O(n \\log_2 n)$。 Part 3 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cset\u003eusing namespace std; constexpr int MAXN = 200000 + 10; constexpr int INFINITY = 0x7fffffff; int n; vector\u003cpair\u003cint, int\u003e\u003e tree[MAXN]; long long f[MAXN][6]; /** * f[x][0]: x is initial * f[x][1]: x -\u003e fa * f[x][2]: x -\u003e y * f[x][3]: y -\u003e x -\u003e fa * f[x][4]: y1 -\u003e x -\u003e y2 * f[x][5]: fa -\u003e x -\u003e y */ void link(int x, int y, int l) { tree[x].push_back({y, l}); tree[y].push_back({x, l}); } void dfs(int x, int fa) { if (tree[x].size() == 1 \u0026\u0026 fa != 0) { f[x][2] = f[x][3] = f[x][4] = f[x][5] = -INFINITY; return; } long long sum = 0, delta[4] = {-INFINITY, -INFINITY, -INFINITY, -INFINITY}; multiset\u003clong long\u003e val; val.insert(-INFINITY); for (auto [y, l] : tree[x]) { if (y == fa) continue; dfs(y, x); long long cont = max(f[y][1], f[y][3] + l); sum += cont; for (int i = 0; i \u003c 6; ++i) f[x][i] += cont; delta[0] = max(delta[0], max(max(max(f[y][0], f[y][2]), f[y][4]), f[y][5] + l) - cont); delta[1] = max(delta[1], f[y][1] + l - cont); delta[3] = max(delta[3], max(max(f[y][0], f[y][2]), f[y][4]) + l - cont); val.insert(f[y][1] + l - cont); } for (auto [y, l] : tree[x]) { if (y == fa) continue; int cont = max(f[y][1], f[y][3] + l); val.erase(val.find(f[y][1] + l - cont)); delta[2] = max(delta[2], *val.rbegin() + max(max(f[y][0], f[y][2]), f[y][4]) + l - cont); val.insert(f[y][1] + l - cont); } f[x][2] += delta[0]; f[x][3] += delta[1]; f[x][4] += delta[2]; f[x][5] += delta[3]; for (int i = 0; i \u003c 6; ++i) if (f[x][i] \u003c 0) f[x][i] = -INFINITY; } int main() { ios::sync_with_stdio(false); cin \u003e\u003e n; if (n == 1) { cout \u003c\u003c 0 \u003c\u003c endl; return 0; } for (int i = 1; i \u003c n; ++i) { int x, y, l; cin \u003e\u003e x \u003e\u003e y \u003e\u003e l; link(x, y, l); } dfs(1, 0); cout \u003c\u003c max(max(f[1][0], f[1][2]), f[1][4]) \u003c\u003c endl; return 0; } ","date":"2022-02-04","objectID":"/contents/20220204-luogu-p3647-solution/:0:0","tags":["OI","DP","树形 DP","C++"],"title":"Luogu P3647 连珠线题解","uri":"/contents/20220204-luogu-p3647-solution/"}]