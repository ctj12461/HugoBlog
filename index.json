[{"categories":["笔记"],"content":"拉格朗日插值是众多插值算法中的一种，插值是通过一些点来求出过这些点的多项式函数的过程。 ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:0:0","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"算法思想 ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:1:0","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"构造函数 给出 $n + 1$ 个点 $(x_1,y_1),(x_2,y_2),\\dots,(x_n,y_n),(x_{n+1},y_{n+1})$，要求出过这些点的 $n$ 次多项式函数，先考虑对每个点构造一个函数，第 $i$ 个点的函数为 $f_i(x)$，满足： $$ f_i(x) = \\begin{cases} y_i \u0026 x = x_i\\\\ 0 \u0026 x \\ne x_i \\end{cases} \\ (x\\in \\{x_1,x_2,\\dots,x_n,x_{n+1}\\}) $$ 最后将这些函数组合为最终的函数： $$ f(x) = \\sum_{i=1}^{n+1}f_i(x) $$ 接下来就是找到一种合适的形式来表示 $f_i(x)$ 的分段规定，可以让 $f_i(x)$ 含有一些因式，满足 $x=x_j,j\\ne i$ 时，其值为 $0$，$x=x_i$ 时，其值为 $y_i$。显然下面这种满足条件: $$ f_i(x) = y_i \\prod_{i\\ne j} \\frac{x-x_j}{x_i-x_j} $$ 所以最终的 $f(x)$ 的解析式为： $$ f(x) = \\sum_{i=1}^{n + 1} y_i \\prod_{i\\ne j} \\frac{x-x_j}{x_i-x_j} $$ ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:1:1","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"高斯消元主要用于求解线性方程组的解，同时可以解决某些有后效性的 DP 问题， ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:0:0","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"算法思想 ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:1:0","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"增广矩阵 为了更方便地求解方程组，可以将系数和常数项放入矩阵，接下来就可以用一些矩阵的操作来消元了。 比如有一个方程组如下： $$ \\begin{cases} 3x+2y+3z=10\\\\ 3x+y+4z=12\\\\ x+y+z=4 \\end{cases} $$ 我们可以这么用矩阵表示: $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \\\\ 3 \u0026 1 \u0026 4 \\\\ 1 \u0026 1 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 10 \\\\ 12 \\\\ 1 \\end{bmatrix} $$ 在理论分析和实现代码时，为了方便，通常把两个矩阵拼在一起，这个矩阵就是增广矩阵： $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \u0026 10 \\\\ 3 \u0026 1 \u0026 4 \u0026 12 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \\end{bmatrix} $$ 增广矩阵的第 $i$ 行代笔第 $i$ 个方程，第 $i$ 列表示第 $i$ 个未知数的系数或常数项，接下来用 $x_i$ 表示第 $i$ 个未知数。 ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:1:1","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"初等行变换 初等行变换是指行之间的加减乘等运算。消元的本质就是利用初等行变换，使未知数的系数变为 $0$。具体地，初等行变换是两个行中的元素逐一进行运算，以上面的矩阵为例，记 $row_i$ 表示第 $i$ 行，则 $row_2 \\longleftarrow row_2 - \\frac{2}{3}row_1$ 的结果就是： $$ \\begin{bmatrix} 0 \u0026 -2 \u0026 -\\frac{1}{2} \u0026 -3 \\end{bmatrix} $$ 这个操作使该行的第 $1$ 个元素变为了 $0$，从方程的意义上考虑，就是消去了一个元。 ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:1:2","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"三角矩阵和对角矩阵 三角矩阵是指一个矩阵的一个三角部分全部为 $0$，对角矩阵则是对角线之外的元素均为 $0$。高斯消元中，三角矩阵一般指下三角矩阵，对角矩阵一般指除常数项部分为对角矩阵的矩阵。 假设得到了一个对角矩阵： $$ \\begin{bmatrix} k_1 \u0026 0 \u0026 0 \u0026 c_1\\\\ 0 \u0026 k_2 \u0026 0 \u0026 c_2\\\\ 0 \u0026 0 \u0026 k_3 \u0026 c_3 \\end{bmatrix} $$ 那就相当于是一个个的一元线性方程，直接解出即可。而对角矩阵可以通过三角矩阵得出： $$ \\begin{bmatrix} k_{11} \u0026 k_{12} \u0026 k_{13} \u0026 c_1\\\\ 0 \u0026 k_{22} \u0026 k_{23} \u0026 c_2\\\\ 0 \u0026 0 \u0026 k_{33} \u0026 c_3 \\end{bmatrix} $$ 首先可以解出 $x_3$，然后将 $x_3$ 带入第 $2$ 个方程，则 $k_{23}x_3$ 就成为了常数项，移项一下得到： $$ \\begin{bmatrix} k_{11} \u0026 k_{12} \u0026 k_{13} \u0026 c_1\\\\ 0 \u0026 k_{22} \u0026 0 \u0026 c_2 - k_{23}x_3\\\\ 0 \u0026 0 \u0026 k_{33} \u0026 c_3 \\end{bmatrix} $$ 同理带入 $x_2,x_3$ 到第 $1$ 个方程： $$ \\begin{bmatrix} k_{11} \u0026 0 \u0026 0 \u0026 c_1 - k_{12}x_2 - k_{13}x_3\\\\ 0 \u0026 k_{22} \u0026 0 \u0026 c_2 - k_{23}x_3\\\\ 0 \u0026 0 \u0026 k_{33} \u0026 c_3 \\end{bmatrix} $$ ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:1:3","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"具体步骤与实例 只要从上往下将每行与它下面的行进行运算，每枚举一行就消去一个元，枚举第 $i$ 行则消去 $x_i$，即通过初等行变换把第 $i + 1$ 到 $n$ 的方程的 $x_i$ 系数变为 $0$。最后从下往上带入即可。 以上面的矩阵为例，这里就模拟到得到三角矩阵： $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \u0026 10 \\\\ 3 \u0026 1 \u0026 4 \u0026 12 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \\end{bmatrix} $$ Step 1: $row_2 \\longleftarrow row_2 - \\frac{2}{3}row_1$ $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \u0026 10 \\\\ 0 \u0026 -2 \u0026 -\\frac{1}{2} \u0026 -3 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \\end{bmatrix} $$ Step 2: $row_3 \\longleftarrow row_3 - \\frac{1}{2}row_1$ $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \u0026 10 \\\\ 0 \u0026 -2 \u0026 -\\frac{1}{2} \u0026 -3 \\\\ 0 \u0026 0 \u0026 -\\frac{1}{2} \u0026 -4 \\end{bmatrix} $$ Step 3: $row_3 \\longleftarrow row_3 - 0\\cdot row_2$ 增广矩阵不变。 ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:1:4","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"高斯-约旦消元 由于计算机上浮点数的精度有限，要尽可能选择绝对值较大的数作为除数，所以枚举到第 $i$ 行时，可以找到 $x_i$ 的系数最大的方程，与当前行交换，这种方法叫做高斯-约旦消元法。 ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:1:5","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"解的判断 方程组有可能有无数解（含自由元）或无解。得到一个对角矩阵后，若存在对角元素 $k_{ii} = 0$，而常数项 $c_i \\ne 0$，则无解，否则若存在对角元素 $k_{ii} = 0$，而常数项 $c_i = 0$，则含自由元。 ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:1:6","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"代码实现 class EquationGroup { public: enum class Result { UNIQUE, INFINITY, NO_SOLUTION }; void init(int n) { this-\u003en = n; e = vector\u003cvector\u003cdouble\u003e\u003e(n + 1, vector\u003cdouble\u003e(n + 2)); } vector\u003cdouble\u003e \u0026operator[](int x) { return e[x]; } pair\u003cvector\u003cdouble\u003e, Result\u003e solve() { transform(); Result res = calc(); vector\u003cdouble\u003e x(n + 1); for (int i = 1; i \u003c= n; ++i) x[i] = e[i][n + 1]; return {x, res}; } private: vector\u003cvector\u003cdouble\u003e\u003e e; int n; // 未知数个数 void transform() { for (int i = 1; i \u003c= n; ++i) { int p = i; // 选择 e[][i] 绝对值最大的一行进行交换 for (int j = i + 1; j \u003c= n; ++j) if (abs(e[p][i]) \u003c abs(e[j][i])) p = j; if (p != i) for (int j = 1; j \u003c= n + 1; ++j) swap(e[i][j], e[p][j]); // 初等行变换 for (int j = i + 1; j \u003c= n; ++j) { double rate = e[j][i] / e[i][i]; for (int k = 1; k \u003c= n + 1; ++k) e[j][k] -= e[i][k] * rate; } } } Result calc() { Result res = Result::UNIQUE; for (int i = n; i \u003e= 1; --i) { // 把解 x_i 存在 e[i][n + 1] 中 for (int j = i + 1; j \u003c= n; ++j) e[i][n + 1] -= e[i][j] * e[j][n + 1]; if (!e[i][i]) { e[i][n + 1] /= e[i][i]; } else { if (e[i][n + 1]) res = Result::NO_SOLUTION; else if (res != Result::NO_SOLUTION) res = Result::INFINITY; } } return res; } }; ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:2:0","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"例题 ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:3:0","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"Luogu P4035 球形空间产生器 给出一个 $n + 1$ 个 $n$ 维空间的点，求这 $n + 1$ 个点构成的 $n$ 维球体的球心。 $1 \\le n \\le 10$。 设球心为 $(x_1,x_2,\\dots,x_n)$，半径为 $r$，对于球体的某个点 $p$，有如下关系： $$ \\sum_{i = 1}^{n} (p_i - x_i) ^ 2 = r ^ 2\\\\ $$ 展开并移项得到： $$ \\sum_{i = 1}^{n} 2p_ix_i + (r ^ 2 - \\sum_{i = 1}^{n} x_i ^ 2) = \\sum_{i = 1}^{n} p_i ^ 2 $$ 把括号看成一个整体，显然是一个 $n + 1$ 元线性方程组，直接高斯消元求解。 #include \u003ciostream\u003e#include \u003ciomanip\u003e#include \u003ccmath\u003eusing namespace std; constexpr int MAXN = 10 + 5; int n; double pos[MAXN][MAXN], mat[MAXN][MAXN]; void preprocess() { for (int i = 1; i \u003c= n + 1; ++i) { double sum = 0; for (int j = 1; j \u003c= n; ++j) { mat[i][j] = 2 * pos[i][j]; sum += pos[i][j] * pos[i][j]; } mat[i][n + 1] = 1; mat[i][n + 2] = sum; } } void transform(int n) { for (int i = 1; i \u003c= n; ++i) { int p = i; for (int j = i + 1; j \u003c= n; ++j) if (abs(mat[p][i]) \u003c abs(mat[j][i])) p = j; if (i != p) for (int j = i; j \u003c= n + 1; ++j) swap(mat[i][j], mat[p][j]); for (int j = i + 1; j \u003c= n; ++j) { double rate = mat[j][i] / mat[i][i]; for (int k = i; k \u003c= n + 1; ++k) mat[j][k] -= rate * mat[i][k]; } } } void calc(int n) { for (int i = n; i \u003e= 1; --i) { for (int j = i + 1; j \u003c= n; ++j) mat[i][n + 1] -= mat[i][j] * mat[j][n + 1]; mat[i][n + 1] /= mat[i][i]; } } void guass(int n) { transform(n); calc(n); } int main() { ios::sync_with_stdio(false); cin \u003e\u003e n; for (int i = 1; i \u003c= n + 1; ++i) for (int j = 1; j \u003c= n; ++j) cin \u003e\u003e pos[i][j]; preprocess(); guass(n + 1); for (int i = 1; i \u003c= n; ++i) cout \u003c\u003c fixed \u003c\u003c setprecision(3) \u003c\u003c mat[i][n + 2] \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:3:1","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"Codeforces 24D Broken robot $n$ 行 $m$ 列的矩阵，$(1, 1)$ 是矩阵的左上角，$(n, m)$ 是矩阵的右下角。现在你在 $(x, y)$，每次等概率向左，右，下走或原地不动，但不能走出去，问走到最后一行期望的步数。（原地不动也算一步） $1 \\le n, m \\le 10 ^ 3$，$1 \\le x \\le n$，$1 \\le y \\le m$。 先考虑 $m = 1$ 的情况，有 $\\frac{1}{2}$ 的概率留在原地，$\\frac{1}{2}$ 的概率向下走，期望步数为 $2 (m - x)$。 若 $m \u003e 1$，设 $f[i][j]$ 为从 $(i, j)$ 走到最后一行的期望步数，则 $$ f[i][j] = \\begin{cases} \\frac{f[i][j + 1] + f[i + 1][j] + f[i][j]}{3} + 1 \u0026 j = 1\\\\ \\frac{f[i][j - 1] + f[i][j + 1] + f[i + 1][j] + f[i][j]}{4} + 1 \u0026 1 \u003c j \u003c m\\\\ \\frac{f[i][j - 1] + f[i + 1][j] + f[i][j]}{3} + 1 \u0026 j = m \\end{cases} $$ 移项可得： $$ \\begin{cases} 2f[i][j] - f[i][j + 1] - f[i + 1][j] = 3 \u0026 j = 1\\\\ 3f[i][j] - f[i][j - 1] - f[i][j + 1] - f[i + 1][j] = 4 \u0026 1 \u003c j \u003c m\\\\ 2f[i][j] - f[i][j - 1] - f[i + 1][j] = 3 \u0026 j = m \\end{cases} $$ 于是每行的转移就可以解决了。然而暴力消元的复杂度不正确，考虑到每个方程都至多只有三个系数不为 $0$，每一行只会消去下一行的一个元（可以手画一个矩阵），利用这个性质，消元可以做到 $\\Theta(m)$，总的复杂度就是 $\\Theta(m (n-x))$。 #include \u003ciostream\u003e#include \u003ciomanip\u003eusing namespace std; constexpr int MAXN = 1e3 + 5; // * * 0 0 0 0 | * // * * * 0 0 0 | * // 0 * * * 0 0 | * // 0 0 * * * 0 | * // 0 0 0 * * * | * // 0 0 0 0 * * | * int n, m, x, y; double mat[MAXN][MAXN], f[MAXN]; void fill() { mat[1][1] = 2; mat[1][2] = -1; mat[1][m + 1] = 3 + f[1]; for (int i = 2; i \u003c m; ++i) { mat[i][i] = 3; mat[i][i - 1] = -1; mat[i][i + 1] = -1; mat[i][m + 1] = 4 + f[i]; } mat[m][m] = 2; mat[m][m - 1] = -1; mat[m][m + 1] = 3 + f[m]; } void gauss() { for (int i = 1; i \u003c m; ++i) { double rate = mat[i + 1][i] / mat[i][i]; mat[i + 1][i] = 0; mat[i + 1][i + 1] -= rate * mat[i][i + 1]; mat[i + 1][m + 1] -= rate * mat[i][m + 1]; } mat[m][m + 1] /= mat[m][m]; for (int i = m - 1; i \u003e= 1; --i) mat[i][m + 1] = (mat[i][m + 1] - mat[i + 1][m + 1] * mat[i][i + 1]) / mat[i][i]; for (int i = 1; i \u003c= m; ++i) f[i] = mat[i][m + 1]; } int main() { ios::sync_with_stdio(false); cin \u003e\u003e n \u003e\u003e m \u003e\u003e x \u003e\u003e y; if (m == 1) { cout \u003c\u003c 2 * (n - x) \u003c\u003c endl; return 0; } for (int i = n - 1; i \u003e= x; --i) { fill(); gauss(); } cout \u003c\u003c setprecision(8) \u003c\u003c f[y] \u003c\u003c endl; return 0; } ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:3:2","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"Luogu P3232 游走 给定一个 $n$ 个点 $m$ 条边的无向连通图，顶点从 $1$ 编号到 $n$，边从 $1$ 编号到 $m$。 小 Z 在该图上进行随机游走，初始时小 Z 在 $1$ 号顶点，每一步小 Z 以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小 Z 到达 $n$ 号顶点时游走结束，总分为所有获得的分数之和。现在，请你对这 $m$ 条边进行编号，使得小 Z 获得的总分的期望值最小。 $2 \\le n \\le 500$，$1 \\le m \\le 125000$。 设 $f[i]$ 表示走到 $i$ 的期望次数，$deg[i]$ 为点 $x$ 的度，则对于一条边 $(x, y)$，其期望次数为： $$ \\frac{f[x]}{deg[x]} + \\frac{f[y]}{deg[y]} $$ 考虑 $f[i]$ 的转移，设 $j$ 为 $i$ 的上一个结点，则： $$ f[i] = \\sum\\frac{f[j]}{deg[j]} + [i = 1] $$ 因为初始在点 $1$，则期望次数会多 $1$。把这个方程，由于 $n$ 是终点，不参加转移，设 $f[n] = 0$。于是前 $n - 1$ 个转移方程组成一个方程组，解出它即可。 最后算出每条边的期望次数，根据排序不等式，次数越多的边应该编号越小，这样答案更优。 #include \u003ciostream\u003e#include \u003ciomanip\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; constexpr int MAXN = 500 + 10; constexpr int MAXM = 125000 + 10; struct Equation { double a[MAXN]; double \u0026operator[](int x) { return a[x]; } }; struct EquationGroup { Equation e[MAXN]; int n; void init(int n) { this-\u003en = n; } Equation \u0026operator[](int x) { return e[x]; } void transform() { for (int i = 1; i \u003c= n; ++i) { int p = i; for (int j = i + 1; j \u003c= n; ++j) if (abs(e[p][i]) \u003c abs(e[j][i])) p = j; if (p != i) for (int j = 1; j \u003c= n + 1; ++j) swap(e[i][j], e[p][j]); for (int j = i + 1; j \u003c= n; ++j) { double rate = e[j][i] / e[i][i]; for (int k = 1; k \u003c= n + 1; ++k) e[j][k] -= e[i][k] * rate; } } } void calc() { for (int i = n; i \u003e= 1; --i) { for (int j = i + 1; j \u003c= n; ++j) e[i][n + 1] -= e[i][j] * e[j][n + 1]; e[i][n + 1] /= e[i][i]; } } vector\u003cdouble\u003e solve() { transform(); calc(); vector\u003cdouble\u003e res(n + 1); for (int i = 1; i \u003c= n; ++i) res[i] = e[i][n + 1]; return res; } }; struct Edge { int x, y; double p; bool operator\u003c(const Edge \u0026rhs) const { return p \u003e rhs.p; } }; int n, m; EquationGroup e; vector\u003cint\u003e graph[MAXN]; int deg[MAXN]; Edge edges[MAXM]; double ans; void link(int x, int y) { graph[x].push_back(y); graph[y].push_back(x); ++deg[x]; ++deg[y]; } int main() { ios::sync_with_stdio(false); cout \u003c\u003c fixed \u003c\u003c setprecision(3); cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= m; ++i) { auto \u0026[x, y, p] = edges[i]; cin \u003e\u003e x \u003e\u003e y; link(x, y); } e.init(n - 1); for (int i = 1; i \u003c n; ++i) { for (int j : graph[i]) if (j != n) e[i][j] = -1.0 / deg[j]; e[i][i] = 1; } e[1][n] = 1; auto f = e.solve(); for (int i = 1; i \u003c= m; ++i) { auto \u0026[x, y, p] = edges[i]; p = (x != n ? f[x] / deg[x] : 0) + (y != n ? f[y] / deg[y] : 0); } sort(edges + 1, edges + 1 + m); for (int i = 1; i \u003c= m; ++i) ans += i * edges[i].p; cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:3:3","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"Luogu P3211 XOR 和路径 给定一个无向连通图，有 $n$ 个点和 $m$ 条边，其节点编号为 $1$ 到 $n$，其边的权值为非负整数。从 $1$ 号节点开始，以相等的概率随机选择一个有连边的点，并沿这条边走到下一个节点，重复这个过程，直到走到 $n$ 号节点为止，便得到一条从 $1$ 号节点到 $n$ 号节点的路径，请你求出该算法得到的路径的 XOR 和的期望值。 设 $(x, y, w)$ 为图中的一条边，$1 \\le x, y \\le n$，$0 \\le w \\le 10 ^ 9$，$2 \\le n \\le 100$，$1 \\le m \\le 10000$。图中可能有重边或自环。 首先可能想到设 $f[x]$ 为 $x$ 点的 XOR 期望，方程为 $$ f[x] = \\sum_y \\frac{f[y] \\oplus w(x, y)}{deg[x]} $$ 但是这种方程是无法转移的。先考虑答案是怎么得到的假设有一条路径 $P = \\{w_1, w_2, \\dots, w_k\\}$，其对答案的贡献为： $$ p(w_1 \\oplus w_2 \\oplus \\cdots \\oplus w_k) $$ 如果按位考虑，分子的结果只会是 $0$ 或 $1$，只需要求出分子的结果为 $1$ 的概率。 设 $f[x][0/1]$ 为点 $x$ 到点 $n$ 的路径异或值为 $0/1$ 的概率。于是可以写成方程： $$ f[x][0] = \\sum_y \\frac{f[y][w(x, y)]}{deg[x]}\\\\ f[x][1] = \\sum_y \\frac{f[y][w(x, y) \\oplus 1]}{deg[x]}\\\\ $$ 设当前枚举的位数为 $b$，则对答案的贡献为 $2 ^ b f[1][1]$。上述转移显然可以高斯消元解决，时间复杂度 $\\theta(n ^ 3 \\log_2 w)$。 注意连接自环不要连两遍。 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003ccmath\u003e#include \u003ciomanip\u003eusing namespace std; constexpr int MAXN = 100 + 10; class EquationGroup { public: void init(int n) { this-\u003en = n; e = vector\u003cvector\u003clong double\u003e\u003e(n + 1, vector\u003clong double\u003e(n + 2, 0)); } vector\u003clong double\u003e \u0026operator[](int x) { return e[x]; } vector\u003clong double\u003e solve() { transform(); calc(); vector\u003clong double\u003e res(n + 1); for (int i = 1; i \u003c= n; ++i) res[i] = e[i][n + 1]; return res; } private: int n; vector\u003cvector\u003clong double\u003e\u003e e; void transform() { for (int i = 1; i \u003c= n; ++i) { int p = i; for (int j = i + 1; j \u003c= n; ++j) if (abs(e[p][i]) \u003c abs(e[j][i])) p = j; if (p != i) for (int j = i; j \u003c= n + 1; ++j) swap(e[i][j], e[p][j]); for (int j = i + 1; j \u003c= n; ++j) { long double rate = e[j][i] / e[i][i]; for (int k = i; k \u003c= n + 1; ++k) e[j][k] -= rate * e[i][k]; } } } void calc() { for (int i = n; i \u003e= 1; --i) { for (int j = i + 1; j \u003c= n; ++j) e[i][n + 1] -= e[i][j] * e[j][n + 1]; e[i][n + 1] /= e[i][i]; } } }; int n, m, mx; EquationGroup e; vector\u003cpair\u003cint, int\u003e\u003e graph[MAXN]; int deg[MAXN]; long double ans; void link(int x, int y, int w) { graph[x].push_back({y, w}); ++deg[x]; if (x != y) { graph[y].push_back({x, w}); ++deg[y]; } } long double calc(int b) { e.init(2 * n); for (int x = 1; x \u003c n; ++x) { e[x][x] += deg[x]; e[x + n][x + n] += deg[x]; for (auto [y, w] : graph[x]) { int w1 = ((w \u003e\u003e b) \u0026 1); e[x][y + w1 * n] += -1; e[x + n][y + (w1 ^ 1) * n] += -1; } } e[n][n] = 1; e[n][2 * n + 1] = 1; e[n + n][2 * n] = 1; e[n + n][2 * n + 1] = 0; auto f = e.solve(); return f[1 + n] * (1 \u003c\u003c b); } int main() { ios::sync_with_stdio(false); cout \u003c\u003c fixed \u003c\u003c setprecision(3); cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= m; ++i) { int x, y, w; cin \u003e\u003e x \u003e\u003e y \u003e\u003e w; link(x, y, w); mx = max(mx, w); } mx = (int) log2(mx); for (int i = 0; i \u003c= mx; ++i) ans += calc(i); cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:3:4","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["题解"],"content":"这里给出一种无需换根的 DP 思路。 ","date":"2022-02-04","objectID":"/contents/20220204-luogu-p3647-solution/:0:0","tags":["OI","DP","树形 DP","C++"],"title":"Luogu P3647 连珠线题解","uri":"/contents/20220204-luogu-p3647-solution/"},{"categories":["题解"],"content":"Part 1 我们从结点的添加方式入手，可以把结点分为三类： 初始的结点，这种结点只有一个 通过 Append 添加的结点，以下简称 A 类结点 通过 Insert 添加的结点，以下简称 I 类结点 不换根的思路核心就在于保证转移时的过程符合结点的添加规则。为了方便，我们可以给每条线定向。同时假设 $1$ 为根，$x$ 为当前结点，$y$ 为 $x$ 的一个儿子结点，$fa$ 为 $x$ 的父亲结点。很显然接下来可以分 $6$ 类讨论： 若 $x$ 为初始结点，则其子结点、$fa$ 都应该连向 $x$ 若 $x$ 为 A 类结点 $x$ 向 $fa$ 连一条红线，子结点连向 $x$ $x$ 向其中一个子结点 $y$ 连一条红线，其他子结点以及 $fa$ 连向 $x$ 若 $x$ 为 I 类结点 $x$ 取代一个子结点 $y$ 连向 $fa$ 的红线，然后换成蓝线 $x$ 取代两个个子结点 $y_1$ 和 $y_2$ 之间的红线，然后换成蓝线 $x$ 取代 $fa$ 连向一个子结点 $y$ 的红线，然后换成蓝线 上面的分类讨论中的“连向”可以看成 Append 或 Insert，根据题意计算就可以了。 ","date":"2022-02-04","objectID":"/contents/20220204-luogu-p3647-solution/:1:0","tags":["OI","DP","树形 DP","C++"],"title":"Luogu P3647 连珠线题解","uri":"/contents/20220204-luogu-p3647-solution/"},{"categories":["题解"],"content":"Part 2 接下来根据分类讨论设出状态以及写出方程： long long f[MAXN][6]; /** * f[x][0]: x is initial * f[x][1]: x -\u003e fa * f[x][2]: x -\u003e y * f[x][3]: y -\u003e x -\u003e fa * f[x][4]: y1 -\u003e x -\u003e y2 * f[x][5]: fa -\u003e x -\u003e y */ 设 $cont(x)$ 表示 $x$ 向其父结点连线的贡献，则 $cont(x)=\\max\\{f[x][1],f[x][3]+len(x,fa(x))\\}$。 $$ f[x][0]=\\sum_{y\\in son(x)}cont(y)\\\\ f[x][1]=\\sum_{y\\in son(x)}cont(y)\\\\ f[x][2]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{\\max\\{f[y][0], f[y][2], f[y][4], f[y][5] + len(y,x)\\}-cont(y)\\}\\\\ f[x][3]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{f[y][1]+len(y,x)-cont(y)\\}\\\\ f[x][4]=\\sum_{y\\in son(x)}cont(y)+\\\\\\max_{y_1,y_2\\in son(x)\\wedge y_1\\ne y_2}\\{ f[y_1][1]+len(y_1,x)-cont(y_1)+\\max\\{f[y_2][0], f[y_2][2], f[y_2][4]\\}+len(y_2,x)-cont(y_2)\\}\\\\ f[x][5]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{\\max\\{f[y][0], f[y][2], f[y][4]\\}+len(y,x)-cont(y)\\} $$ 上面的转移都可以看成先从子结点按照 $cont(x)$ 转移，在钦定某个结点按照特定的方式转移，记录下最优的差值在加到 $f$ 里即可。$f[x][4]$ 有两个变量，可以考虑枚举其中一个，用 std::multiset\u003cT\u003e 维护另外一个的最值即可。 时间复杂度 $O(n \\log_2 n)$。 ","date":"2022-02-04","objectID":"/contents/20220204-luogu-p3647-solution/:2:0","tags":["OI","DP","树形 DP","C++"],"title":"Luogu P3647 连珠线题解","uri":"/contents/20220204-luogu-p3647-solution/"},{"categories":["题解"],"content":"Part 3 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cset\u003eusing namespace std; constexpr int MAXN = 200000 + 10; constexpr int INFINITY = 0x7fffffff; int n; vector\u003cpair\u003cint, int\u003e\u003e tree[MAXN]; long long f[MAXN][6]; /** * f[x][0]: x is initial * f[x][1]: x -\u003e fa * f[x][2]: x -\u003e y * f[x][3]: y -\u003e x -\u003e fa * f[x][4]: y1 -\u003e x -\u003e y2 * f[x][5]: fa -\u003e x -\u003e y */ void link(int x, int y, int l) { tree[x].push_back({y, l}); tree[y].push_back({x, l}); } void dfs(int x, int fa) { if (tree[x].size() == 1 \u0026\u0026 fa != 0) { f[x][2] = f[x][3] = f[x][4] = f[x][5] = -INFINITY; return; } long long sum = 0, delta[4] = {-INFINITY, -INFINITY, -INFINITY, -INFINITY}; multiset\u003clong long\u003e val; val.insert(-INFINITY); for (auto [y, l] : tree[x]) { if (y == fa) continue; dfs(y, x); long long cont = max(f[y][1], f[y][3] + l); sum += cont; for (int i = 0; i \u003c 6; ++i) f[x][i] += cont; delta[0] = max(delta[0], max(max(max(f[y][0], f[y][2]), f[y][4]), f[y][5] + l) - cont); delta[1] = max(delta[1], f[y][1] + l - cont); delta[3] = max(delta[3], max(max(f[y][0], f[y][2]), f[y][4]) + l - cont); val.insert(f[y][1] + l - cont); } for (auto [y, l] : tree[x]) { if (y == fa) continue; int cont = max(f[y][1], f[y][3] + l); val.erase(val.find(f[y][1] + l - cont)); delta[2] = max(delta[2], *val.rbegin() + max(max(f[y][0], f[y][2]), f[y][4]) + l - cont); val.insert(f[y][1] + l - cont); } f[x][2] += delta[0]; f[x][3] += delta[1]; f[x][4] += delta[2]; f[x][5] += delta[3]; for (int i = 0; i \u003c 6; ++i) if (f[x][i] \u003c 0) f[x][i] = -INFINITY; } int main() { ios::sync_with_stdio(false); cin \u003e\u003e n; if (n == 1) { cout \u003c\u003c 0 \u003c\u003c endl; return 0; } for (int i = 1; i \u003c n; ++i) { int x, y, l; cin \u003e\u003e x \u003e\u003e y \u003e\u003e l; link(x, y, l); } dfs(1, 0); cout \u003c\u003c max(max(f[1][0], f[1][2]), f[1][4]) \u003c\u003c endl; return 0; } ","date":"2022-02-04","objectID":"/contents/20220204-luogu-p3647-solution/:3:0","tags":["OI","DP","树形 DP","C++"],"title":"Luogu P3647 连珠线题解","uri":"/contents/20220204-luogu-p3647-solution/"}]