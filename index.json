[{"categories":["笔记"],"content":"欧拉函数 $\\varphi(n)$ 是一个重要的数论函数，它表示 $[1, n]$ 中与 $n$ 互质的数的个数。 ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:0:0","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"欧拉函数性质 ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:1:0","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"积性函数 积性函数的定义是：如果一个函数 $f(n)$ 满足 $\\gcd(a,b)=1$ 时 $f(ab)=f(a)f(b)$，则 $f(n)$ 为积性函数。 若无需 $\\gcd(a,b)=1$ 就有 $f(ab)=f(a)f(b)$，则它为完全积性函数。 $$ n = \\prod p_i^{c_i}\\\\ f(n) = \\prod f(p_i^{c_i}) $$ 一般来说，各种积性函数都是可以使用欧拉筛计算出来的，尽管方法各不相同。 $\\varphi(n)$ 也是积性函数，证明就省略了。 ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:1:1","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"计算公式 因为 $\\varphi(n)$ 是积性函数，所以我们可以先研究 $\\varphi(p^k)$ 怎么计算。$p^k$ 的约数有 $1, p, p^2, \\dots, p^k$，而 $p^2, \\dots, p^k$ 都含有 $p$ 这个约数，如果一个数不与 $p^k$ 互质，则一点有 $p$ 这个约数，我们只有知道小于等于 $p^k$ 的数中 $p$ 的倍数有多少即可。由此得出 $\\varphi(n) = p^k - \\frac{p^k}{p} = p^k - p^{k-1}=p^k\\frac{p-1}{p}$。 根据 $\\varphi(n)$ 的积性函数性质，得出对于任意的 $n$： $$ \\begin{aligned} \\varphi(n) \u0026 = \\prod p_i^{c_i} \\frac{p_i - 1}{p_i} \\\\ \u0026 = n \\prod \\frac{p_i-1}{p_i} \\\\ \u0026 = n \\prod (1 - \\frac{1}{p_i}) \\end{aligned} $$ ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:1:2","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"求和式 Formula 1 $$ n = \\sum_{d \\mid n} \\varphi(d) $$ 考虑设函数 $f(x, n)=\\sum_{i=1}^{n}[\\gcd(i,n)=x]$，则： $$ n=\\sum_{d \\mid n} f(d,n) $$ 又因为若 $\\gcd(i,n)=x$，则 $\\gcd(\\frac{i}{x},{\\frac{n}{x}})=1$，所以 $f(x,n)=\\varphi(\\frac{n}{x})$。带回原式： $$ n=\\sum_{d \\mid n}\\varphi(\\frac{n}{d}) $$ 因为 $d$ 与 $\\frac{n}{d}$ 是一起出现的，所以上式等价于原式。 Formula 2 $$ \\sum_{i=1}^{n} \\sum_{j=1}^{n} [\\gcd(i,j)=1]=\\sum_{i=1}^{n}2\\varphi(i)-1 $$ 若我们仅考虑 $j\\le i$，则可以固定每个 $i$ 考虑，对于每个 $i$，与其互质的 $j$ 有 $\\varphi(i)$ 个，全部的和显然为 $\\sum_{i=1}^{n} \\varphi(i)$。对于 $j \\ge i$ 的情况，可以发现 $j,i$ 相当于前一种情况的 $i,j$，变换求和顺序后其实是等价的，即： $$ \\sum_{i=1}^{n} \\sum_{j=i}^{n} [\\gcd(i,j)=1]=\\sum_{j=1}^{n} \\sum_{i=1}^{j} [\\gcd(i,j)=1] $$ 左右能够枚举到的 $(i,j)$ 是一样的，又因为只有 $1$ 与本身互质，则原式等价于两种情况相加再扣除一个 $1$ 的重复。 Formula 3 $$ \\sum_{i=1}^{n}i[\\gcd(i,n)=1]=\\frac{n\\varphi(n)}{2} $$ 根据更相减损术 $\\gcd(a,b)=\\gcd(b,a-b)$，可以知道若 $\\gcd(i,n)=1$，则 $\\gcd(n-i,n)=1$，也就是与 $n$ 互质的数是成对出现的，且每一对的和都为 $n$，考虑头尾相加，仿照等差数列的求和公式： $$ \\begin{aligned} \u0026 \\sum_{i=1}^{n}i[\\gcd(i,n)=1] + \\sum_{i=1}^{n}(n-i)[\\gcd(n-i,n)=1]\\\\ = \u0026\\sum_{i=1}^{n} n[\\gcd(i,n)=1]\\\\ = \u0026n\\varphi(n) \\end{aligned}\\\\ $$ 所以两边除以 $2$ 得出： $$ \\sum_{i=1}^{n}i[\\gcd(i,n)=1]=\\frac{n\\varphi(n)}{2} $$ ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:1:3","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"筛法 使用欧拉筛时随便求出即可。假设循环到 $i$： 若 $i$ 为质数，则 $\\varphi(i)=i-1$ 若 $p_j \\nmid i$，则 $\\gcd(p_j,i)=1$，根据积性函数性质，$\\varphi(ip_j)=\\varphi(i)\\varphi(p_j)=(p_j-1)\\varphi(i)$ 若 $p_j \\mid i$，则 $\\gcd(p_j,i)\\ne 1$，$i$ 中已有 $p_j$ 这个约数，根据计算公式，只要乘一次$\\frac{p_j-1}{p_j}$，则 $\\varphi(ip_j)=p_j\\varphi(i)$ ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:1:4","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"代码实现 ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:2:0","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"单次求解 int phi(int x) { int res = x; for (int i = 2; i * i \u003c= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u003e 1) res = res / x * (x - 1); return res; } ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:2:1","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"欧拉筛 void sieve(int n) { notPrime[1] = true; for (int i = 2; i \u003c= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; phi[i] = i - 1; } for (int j = 1; j \u003c= tot \u0026\u0026 i * prime[j] \u003c= n; ++j) { notPrime[i * prime[j]] = true; if (i % prime[j]) { phi[i * prime[j]] = phi[i] * (prime[j] - 1); } else { phi[i * prime[j]] = phi[i] * prime[j]; break; } } } } ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:2:2","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"欧拉定理 ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:3:0","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"定理内容 普通 $$ a^{\\varphi(m)} \\equiv 1 \\pmod{m}\\ (\\gcd(a,m)=1) $$ 扩展 $$ a^b \\equiv \\begin{cases} a^{b \\bmod \\varphi(m)} \u0026 \\gcd(a,m)=1\\\\ a^{b} \u0026 \\gcd(a,m)\\ne 1 \\wedge b \u003c \\varphi(m)\\\\ a^{b \\bmod \\varphi(m) + \\varphi(m)} \u0026 \\gcd(a,m)\\ne 1 \\wedge b \\ge \\varphi(m) \\end{cases} \\pmod{m} $$ ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:3:1","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"应用 逆元 $$ a^{\\varphi(m)}\\equiv a\\cdot a^{\\varphi(m)-1}\\equiv 1 \\pmod{m}\\ (\\gcd(a,m)=1) $$ 当 $\\gcd(a,m)=1$ 时，$a^{\\varphi(m)-1}$ 就是 $a$ 的逆元。费马小定理就是其特殊情况。 降幂 有时幂的指数恒大，快速幂的时间复杂度也无法接受，这时可以使用扩展欧拉定理对指数进行取模减小，优化算法。 幂次幂 有时题目要求类似 $a^{b_1^{b_2^{\\cdots}}}$ 的式子，一般直接处理指数与底数的关系是不可做的，这时就可以使用扩展欧拉定理，同时由于复合欧拉函数 $\\varphi(\\varphi(\\dots\\varphi(n)\\dots))$ 的值变为 $1$ 的次数是 $O(\\log_2 n)$ 的，所以也只需要用 $O(\\log_2 n)$ 扩展欧拉定理，某一层的指数就会变为 $0$，配合快速幂，总体的时间复杂度为 $O(\\log_2^2 n)$。 ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:3:2","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"例题 ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:4:0","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"Luogu P2158 仪仗队 给出一个 $n \\times n$ 的点阵，从左下角观察，一个点能够被观察到当且仅当其与左下角的点的连线上没有其他的点，就能够被观察到的点的个数（左下角的点不算）。 $1\\le n \\le 40000$。 容易看出左上部分和右下部分的答案相同，先考虑右下，对点阵建坐标系，左下角为 $(0,1)$，则半平面 $x-y \\ge 0$ 中的点 $(x, y)$ 若满足 $\\gcd(x,y)=1$，则可以被观察到。这部分答案为 $\\sum_{i=1}^{n-1}\\varphi(i)$，左上部分答案也是这个，图中还有一个位于 $(1,2)$ 的点未被算到，再加 $1$ 即可，总答案为： $$ \\sum_{x=1}^{n-1} 2\\varphi(x)+1 $$ 欧拉筛求出欧拉函数后直接加即可。 #include \u003ciostream\u003eusing namespace std; constexpr int MAXN = 40000 + 10; int n, ans = 1; bool notPrime[MAXN]; int tot, prime[MAXN], phi[MAXN]; void sieve(int n) { notPrime[1] = true; for (int i = 2; i \u003c= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; phi[i] = i - 1; } for (int j = 1; j \u003c= tot \u0026\u0026 i * prime[j] \u003c= n; ++j) { notPrime[i * prime[j]] = true; if (i % prime[j]) { phi[i * prime[j]] = phi[i] * (prime[j] - 1); } else { phi[i * prime[j]] = phi[i] * prime[j]; break; } } } } int main() { cin \u003e\u003e n; if (n == 1) { cout \u003c\u003c 0 \u003c\u003c endl; return 0; } sieve(n - 1); for (int i = 1; i \u003c= n - 1; ++i) ans += 2 * phi[i]; cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:4:1","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"Luogu P2303 Longge 的问题 给定一个整数 $n$，你需要求出 $\\sum_{i=1}^{n} \\gcd(i,n)$。 $1\\le n\u003c 2^{32}$ 推式子，考虑枚举 $d$ 作为 $\\gcd(i,n)$： $$ \\begin{aligned} \\sum_{i=1}^{n} \\gcd(i,n)\u0026=\\sum_{d \\mid n}d\\sum_{i=1}^{n}[\\gcd(i,n)=d]\\\\ \u0026=\\sum_{d \\mid n}d\\sum_{i=1}^{n}[\\gcd(\\frac{i}{d},\\frac{n}{d})=1]\\\\ \u0026=\\sum_{d \\mid n}d\\sum_{i=1}^{\\frac{n}{d}}[\\gcd(i,\\frac{n}{d})=1]\\\\ \u0026=\\sum_{d \\mid n}d\\varphi(\\frac{n}{d}) \\end{aligned} $$ 枚举约数 $d$，再计算 $\\varphi$ 即可，时间复杂度 $O(d(n)\\varphi(n))$，$d(n)$ 表示 $n$ 的约数个数，实际上跑得很快。 #include \u003ciostream\u003eusing namespace std; long long n, ans; long long phi(long long x) { long long res = x; for (long long i = 2; i * i \u003c= n; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u003e 1) res = res / x * (x - 1); return res; } int main() { long long i; for (i = 1; i * i \u003c n; ++i) if (n % i == 0) ans += i * phi(n / i) + (n / i) * phi(i); if (i * i == n) ans += i * phi(i); cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:4:2","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"Luogu P2350 外星人 设 $\\varphi^x(n)$ 为对 $n$ 求 $x$ 次欧拉函数，即： $$ \\varphi^x(n)= \\begin{cases} \\varphi(n) \u0026 x=1\\\\ \\varphi^{x-1}(\\varphi(n)) \u0026 x\u003e1 \\end{cases} $$ 现在给出 $n$ 的唯一分解 $\\prod_{i=1}^{m}p_i^{q_i}$，求出一个最小的 $x$ 使得 $\\varphi^x(n)=1$。 $test$ 组数据，$1\\le test\\le 50$，$1\\le p_i\\le 10^5$，$1\\le q_i\\le 10^9$，$1\\le m\\le 2000$。 首先可以找一些规律，对于 $2^k$ 这一类数，显然最小的 $x=k$，因为每套一层欧拉函数就会使 $k$ 减小 $1$。 对于其他不等于 $2$ 的质数 $p$，$\\varphi(p)=p-1=2^{k'}\\prod p_i'^{c_i'}$，$\\varphi^2(p)=2^{k'+k'-1}\\prod p_i''^{c_i''}$，$\\varphi^3(p)=2^{k'+k''+k'''-2}\\prod p_i'''^{c_i'''}$，依此类推，发现几个性质： 每个互质的 $p_i^{c_i}$ 同时减小 $c_i$，根据欧拉函数的公式可以得出 每次每个 $p_i^{c_i}\\ (p_i\\ne 2)$ 都会使前面的某些 $p_j^{c_j}$ 的 $c_j$ 增加，且 $p_j\u003cp_i$，且一定有一个 $p_j=2$。 对于 $2^k$，不考虑后面的 $p_i^{c_i}$，每次 $k$ 会被减小 $1$ 最后一个被消去的质因数一定是 $2$ 前 $3$ 个都很好理解，最后一个使用反证法，假设存在一个质因数 $p$ 大于 $2$，且经过 $t$ 次操作后，$2$ 的次数变为 $0$，而 $p$ 的次数大于 $0$，这种情况下若要满足最后一个被消去的质因数不是 $2$，则 $\\varphi^{t+1}(p)$ 不能有 $2$ 的约数，与性质 $2$ 矛盾，故假设不成立。 所以，总共的消除次数就是 $2$ 的次数，这启发我们计算每个质因数 $p_i$ 最后能够产生多少个 $2$。设 $f[i]$ 表示 $i$ 能够产生的 $2$ 的个数，则： $$ f[2]=1\\\\ f[p]=f[p-1]\\\\ f[p^k]=kf[p]\\\\ f[ap]=f[a]+f[p]\\\\ $$ 其中 $p$ 为质数，这个 DP 在欧拉筛时求出即可。最后答案为： $$ \\sum_{i=1}^{m}qf[p]+[2\\notin\\{p_1,p_2,\\dots,p_m\\}] $$ 注意特判最开始的 $n$ 没有 $2$ 的约数的情况，这个时候要先求一次欧拉函数来获得 $2$ 的约数。 #include \u003ciostream\u003eusing namespace std; constexpr int MAXP = 1e5 + 10; int t, m; int f[MAXP], prime[MAXP], tot; bool notprime[MAXP]; void preprocess(int n) { notprime[0] = notprime[1] = true; f[1] = 1; // 虽然 1 不能产生 2，但是为了方便可以这么写 for (int i = 2; i \u003c= n; ++i) { if (!notprime[i]) { prime[++tot] = i; f[i] = f[i - 1]; } for (int j = 1; j \u003c= tot; ++j) { if (i * prime[j] \u003e n) break; notprime[i * prime[j]] = true; f[i * prime[j]] = f[i] + f[prime[j]]; if (i % prime[j] == 0) break; } } } void solve() { m = read(); bool found = false; long long ans = 0; for (int i = 1; i \u003c= m; ++i) { int p, q; cin \u003e\u003e p \u003e\u003e q; found |= (p == 2); ans += 1ll * f[p] * q; } ans += !found; cout \u003c\u003c ans \u003c\u003c endl; } int main() { ios::sync_with_stdio(false); preprocess(MAXP - 10); cin \u003e\u003e t; while (t--) solve(); return 0; } ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:4:3","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"Luogu P4139 上帝与集合的正确用法 给出 $p$，求以下式子： $$ 2^{2^{2^{\\cdots}}} \\bmod p $$ 可以看作 $\\infty$ 个 $2$，尽管这种式子不是很严谨。 $T$ 组数据，$1\\le T \\le 10^3$，$1\\le p\\le 10^7$。 使用扩展欧拉定理，原式可以写成： $$ 2^{2^{2^{\\cdots}}} \\bmod p= \\begin{cases} 2^{2^{2^{\\cdots}} \\bmod \\varphi(p)} \\bmod p \u0026 \\gcd(2,p)=1\\\\ 2^{2^{2^{\\cdots}} \\bmod \\varphi(p) + \\varphi(p)} \\bmod p \u0026 \\gcd(2,p)\\ne 1 \\end{cases} $$ 这里把 $2^{2^{2^{\\cdots}}}$ 视为 $\\infty$，所以不存在 $2^{2^{2^{\\cdots}}}\u003c\\varphi(p)$ 的情况。设 $f(p) = 2^{2^{2^{\\cdots}}} \\bmod p$，就可以把上面的式子写成这样： $$ f(p)= \\begin{cases} 2^{f(\\varphi(p))} \\bmod p \u0026 \\gcd(2,p)=1\\\\ 2^{f(\\varphi(p)) + \\varphi(p)} \\bmod p \u0026 \\gcd(2,p)\\ne 1 \\end{cases} $$ 当 $p=1$ 时，$f(p)=0$。先筛出 $\\varphi(p)$，再用递归实现 $f(p)$，$f(p)$ 只会递归 $(\\log_2 p)$ 层，可以再加上记忆化搜索。时间复杂度 $O(p+T\\log_2^2 p)$。 #include \u003ciostream\u003eusing namespace std; constexpr int MAXP = 1e7 + 10; int t, p; int buc[MAXP]; int prime[MAXP], phi[MAXP], tot; bool notPrime[MAXP]; int gcd(int x, int y) { int t; while (y) { t = x; x = y; y = t % y; } return x; } int power(int x, int y, int p) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % p; x = 1ll * x * x % p; } return res; } void preprocess(int n) { notPrime[1] = true; for (int i = 2; i \u003c= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; phi[i] = i - 1; } for (int j = 1; j \u003c= tot \u0026\u0026 i * prime[j] \u003c= n; ++j) { notPrime[i * prime[j]] = true; if (i % prime[j]) { phi[i * prime[j]] = phi[i] * (prime[j] - 1); } else { phi[i * prime[j]] = phi[i] * prime[j]; break; } } } } int calc(int p) { if (buc[p] != -1) return buc[p]; int res; if (gcd(2, p) == 1) res = power(2, calc(phi[p]), p); else res = power(2, calc(phi[p]) + phi[p], p); buc[p] = res; return res; } int main() { ios::sync_with_stdio(false); preprocess(MAXP - 1); for (int i = 0; i \u003c MAXP; ++i) buc[i] = -1; buc[1] = buc[2] = 0; cin \u003e\u003e t; while (t--) { int x; cin \u003e\u003e x; cout \u003c\u003c calc(x) \u003c\u003c endl; } return 0; } ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:4:4","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"Luogu P3747 相逢是问候 维护一个长度为 $n$ 的数组，这个数组的下标为从 $1$ 到 $n$ 的正整数。 一共有 $m$ 个操作，可以分为两种： 0 l r，对区间 $[l,r]$ 中的每一个数进行赋值：$a_i\\longleftarrow c^{a_i}$，$c$ 为一常数。 1 l r，查询区间 $[l,r]$ 中的 $a_i$ 之和对 $p$ 取模的值。 $1\\le n,m\\le 5\\times 10^4$，$1\\le p\\le 10^8$，$0\u003cc\u003cp$，$0\\le a_i \u003c p$。 思路与上一题有异曲同工之处，每个数最多被赋值 $O(\\log_2 p)$ 次后就固定不变了，用线段树维护区间和以及区间的最小操作次数，每次修改只处理仍然需要计算的部分，总时间复杂度 $O(n\\log_2^3 p)$，常数小就可以过去了。 考虑去掉一个 $O(\\log_2 p)$。由于 $\\varphi(p)$ 减小得很快，仅需要 $O(\\log_2 p)$ 次，意味着快速幂的模数也很少，考虑对每个模数 $M$ 预处理出 $p_1[i]=M^i$，$p_2[i]=M^{10000i}$，然后就可以 $O(1)$ 求幂了。时间复杂度 $O(n\\log_2^2 p)$。 #include \u003ciostream\u003eusing namespace std; constexpr int MAXN = 5e4 + 10; constexpr int INFINITY = 0x3f3f3f3f; struct Node { int left, right; int cnt, sum; }; int n, m, p, c; int a[MAXN]; int seq[MAXN], g[MAXN], tot; Node tree[MAXN * 4]; int p1[10001], p2[10001], p3[32][10001], p4[32][10001]; int gcd(int x, int y) { int t; while (y) { t = x; x = y; y = t % y; } return x; } int powerImpl(int x, int y) { if (y == INFINITY) return INFINITY; int res = 1; for (; y; y /= 2) { if (y % 2) { if (x == INFINITY || 1ll * res * x \u003e= p) return INFINITY; res = res * x; } if (x == INFINITY || 1ll * x * x \u003e= p) x = INFINITY; else x = x * x; } return res; } int power(int y) { int y1 = y % 10000, y2 = y / 10000; if (p1[y1] == INFINITY || p2[y2] == INFINITY || 1ll * p1[y1] * p2[y2] \u003e= p) return INFINITY; return p1[y1] * p2[y2]; } int power(int y, int id) { int y1 = y % 10000, y2 = y / 10000; return 1ll * p3[id][y1] * p4[id][y2] % seq[id]; } int powerImpl(int x, int y, int p) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % p; x = 1ll * x * x % p; } return res; } int phi(int x) { int res = x; for (int i = 2; i * i \u003c= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u003e 1) res = res / x * (x - 1); return res; } void preprocess() { int x = p; while (seq[tot] != 1) { seq[++tot] = x; x = phi(x); } for (int i = 1; i \u003c= tot; ++i) g[i] = gcd(seq[i], c); for (int i = 0; i \u003c= 10000; ++i) { p1[i] = powerImpl(c, i); p2[i] = powerImpl(c, i * 10000); } for (int i = 1; i \u003c= tot; ++i) { for (int j = 0; j \u003c= 10000; ++j) { p3[i][j] = powerImpl(c, j, seq[i]); p4[i][j] = powerImpl(c, j * 10000, seq[i]); } } } // 核心部分，利用扩展欧拉定理求幂次幂 // 返回值一个是答案，一个是用于处理与 phi(p) 的大小关系 pair\u003cint, int\u003e calc(int dep, int lim, int a) { // phi 的值已经为 1 if (dep == tot) { int prod = a; for (int i = lim; i \u003e= dep; --i) { prod = power(prod); // 用无穷大表示超过 p 的情况 if (prod == INFINITY) return { 0, INFINITY }; } return { 0, prod }; } // 已经到 a_i，无法继续递归 if (dep == lim + 1) return { a % seq[dep], a }; auto [res, prod] = calc(dep + 1, lim, a); // seq[i] 表示对 p 求 i 次欧拉函数的结果 // g[i] 表示 c 与 seq[i] 的 gcd if (g[dep] == 1) res = power(res, dep); else if (prod \u003e= seq[dep + 1]) res = power(res + seq[dep + 1], dep); else res = power(prod, dep); prod = power(prod); return { res, prod }; } inline void pushup(int x) { tree[x].sum = (tree[x * 2].sum + tree[x * 2 + 1].sum) % p; tree[x].cnt = min(tree[x * 2].cnt, tree[x * 2 + 1].cnt); } void build(int x, int l, int r) { tree[x].left = l; tree[x].right = r; if (l == r) { tree[x].sum = a[l]; return; } int mid = (l + r) / 2; build(x * 2, l, mid); build(x * 2 + 1, mid + 1, r); pushup(x); } void modify(int x, int l, int r) { if (tree[x].cnt \u003e= tot || tree[x].right \u003c l || r \u003c tree[x].left) return; if (tree[x].left == tree[x].right) { ++tree[x].cnt; tree[x].sum = calc(1, tree[x].cnt, a[tree[x].left]).first; return; } int mid = (tree[x].left + tree[x].right) / 2; if (l \u003c= mid) modify(x * 2, l, r); if (mid \u003c r) modify(x * 2 + 1, l, r); pushup(x); } int query(int x, int l, int r) { if (l \u003c= tree[x].left \u0026\u0026 tree[x].right \u003c= r) return tree[x].sum; int mid = (tree[x].left + tree[x].right) / 2, res = 0; if (l \u003c= mid) res = (res + query(x * 2, l, r)) % p; if (mid \u003c r) res = (res + query(x * 2 + 1, l, r)) % p; return res; } int main() { ios::sync_with_stdio(false); cin \u003e\u003e n \u003e\u003e m \u003e\u003e p \u003e\u003e c; preprocess(); for (int i = 1; i \u003c= n; ++i) cin \u003e\u003e a[i]; build(1, 1, n); for (int i = 1; i \u003c= m; ++i) { int op, l, ","date":"2022-02-10","objectID":"/contents/20220210-euler-function-and-euler-theorem-note/:4:5","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"/contents/20220210-euler-function-and-euler-theorem-note/"},{"categories":["笔记"],"content":"拉格朗日插值是众多插值算法中的一种，插值是通过一些点来求出过这些点的多项式函数的过程。 ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:0:0","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"算法思想 ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:1:0","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"构造函数 给出 $n + 1$ 个点 $(x_1,y_1),(x_2,y_2),\\dots,(x_n,y_n),(x_{n+1},y_{n+1})$，要求出过这些点的 $n$ 次多项式函数（也称该函数的度为 $n$），先考虑对每个点构造一个函数，第 $i$ 个点的函数为 $f_i(x)$，满足： $$ f_i(x) = \\begin{cases} y_i \u0026 x = x_i\\\\ 0 \u0026 x \\ne x_i \\end{cases} \\ (x\\in \\{x_1,x_2,\\dots,x_n,x_{n+1}\\}) $$ 最后将这些函数组合为最终的函数： $$ f(x) = \\sum_{i=1}^{n+1}f_i(x) $$ 接下来就是找到一种合适的形式来表示 $f_i(x)$ 的分段规定，可以让 $f_i(x)$ 含有一些因式，满足 $x=x_j,j\\ne i$ 时，其值为 $0$，$x=x_i$ 时，其值为 $y_i$。显然下面这种满足条件： $$ f_i(x) = y_i \\prod_{i\\ne j} \\frac{x-x_j}{x_i-x_j} $$ 所以最终的 $f(x)$ 的解析式为： $$ f(x) = \\sum_{i=1}^{n + 1} y_i \\prod_{i\\ne j} \\frac{x-x_j}{x_i-x_j} $$ 求单个函数值的时间复杂度是 $\\Theta(n^2)$。 ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:1:1","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"前后缀积优化 在一些题目中，插值所需的 $x$ 是连续的，当 $x\\in \\mathrm{N^*}$ 时，我们可以把公式写成这样： $$ f(x) = \\sum_{i=1}^{n + 1} y_i \\prod_{i\\ne j} \\frac{x-j}{i-j} = \\sum_{i=1}^{n + 1} y_i \\frac{pre[i - 1]suf[i+1]}{(i-1)!(n-i+1)!(-1)^{n-i+1}}\\\\ pre[i]=\\prod_{j=1}^{i} (k-j) = (k-i)pre[i-1]\\\\ suf[i]=\\prod_{j=i}^{n+1} (k-j)= (k-i)suf[i+1]\\\\ $$ 特殊地，$pre[0] = 1$，$suf[n+2] = 1$。 这样单次插值的时间复杂度就是 $\\Theta(n)$。 当然，前后缀积优化还适用于 $x_i-x_{i-1}=d\\ (d\\ne 0,x\u003e1)$ 的情况，即 $x_i$ 是一个公差不为 $0$ 的等差数列。 ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:1:2","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"重心拉格朗日插值 如果题面要求动态地加入插值点升高次数，上述方法不够优秀，从公式中可以发现，我们重复计算了许多东西，考虑把它们提取出来： $$ f(x) = \\sum_{i=1}^{n + 1} y_i \\prod_{i\\ne j} \\frac{x-x_j}{x_i-x_j} = \\sum_{i=1}^{n + 1} \\frac{y_i}{x-x_i} \\prod_{j=1}^{n+1}(x-x_j) \\prod_{i\\ne j}\\frac{1}{x_i-x_j} $$ 定义以下函数： $$ w(i)=\\prod_{i\\ne j}\\frac{1}{x_i-x_j}\\\\ c(x)=\\prod_{j=1}^{n+1}(x-x_j) $$ 其中 $w(i)$ 也被称为重心权。 最终公式为： $$ f(x)=c(x) \\sum_{i=1}^{n + 1} w(i) \\frac{y_i}{x-x_i} $$ 显然只要 $\\Theta(1)$ 更新 $c(x)$，$\\Theta(nt)$ 求出 $w(n+2)$ 以及更新 $w(1\\dots n+1)$。最后 $\\Theta(nt)$ 求出新的 $f(x)$。$\\Theta(t)$ 为求逆元的复杂度，一般为 $\\Theta(\\log_2 M)$，$M$ 为模数。 具体地，对于 $\\forall i\\in [1,n+1]$，$w(i)$ 都除以 $x_i-x_{n+2}$，而 $w(n+2)$ 只需扫一遍即可。 ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:1:3","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"代码实现 ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:2:0","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"普通拉格朗日插值 int interpolation(int deg, int k, int x[], int y[]) { int res = 0; for (int i = 1; i \u003c= deg + 1; ++i) { int num = y[i], den = 1; for (int j = 1; j \u003c= deg + 1; ++j) { if (i == j) continue; num = 1ll * num * (k - x[j] + MOD) % MOD; den = 1ll * den * (x[i] - x[j] + MOD) % MOD; } res = (res + 1ll * num * power(den, MOD - 2)) % MOD; } return res; } ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:2:1","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"前后缀积优化 inline int sgnInv(int n) { static int inv[2] = {power(1, MOD - 2), power(MOD - 1, MOD - 2)}; return inv[n % 2]; } void preprocess(int deg) { fac[0] = 1; for (int i = 1; i \u003c= deg + 1; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; inv[deg + 1] = power(fac[deg + 1], MOD - 2); for (int i = deg; i \u003e= 0; --i) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD; } int interpolation(int deg, int k, int x[], int y[]) { int res = 0; pre[0] = suf[deg + 2] = 1; for (int i = 1; i \u003c= n + 1; ++i) pre[i] = 1ll * pre[i - 1] * (k - i + MOD) % MOD; for (int i = n + 1; i \u003e= 1; --i) suf[i] = 1ll * suf[i + 1] * (k - i + MOD) % MOD; for (int i = 1; i \u003c= n + 1; ++i) { int num = 1ll * y[i] * pre[i - 1] % MOD * suf[i + 1] % MOD; int den = 1ll * inv[i - 1] * inv[deg - i + 1] % MOD * sgnInv(deg - i + 1) % MOD % MOD; res = (1ll * res + 1ll * num * den % MOD) % MOD; } return res } ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:2:2","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"重心拉格朗日插值 int interpolationAdd(int nx, int ny) { ++deg; x[deg + 1] = nx; y[deg + 1] = ny; c = 1ll * c * (k - nx + MOD) % MOD; for (int i = 1; i \u003c= deg; ++i) w[i] = 1ll * w[i] * power(x[i] - x[deg + 1] + MOD, MOD - 2) % MOD; for (int i = 1; i \u003c= deg; ++i) w[deg + 1] = 1ll * w[deg + 1] * (x[deg + 1] - x[i] + MOD) % MOD; w[deg + 1] = power(w[deg + 1], MOD - 2); int res = 0; for (int i = 1; i \u003c= deg + 1; ++i) res = 1ll * y[i] * w[i] % MOD * power(k - x[i]) % MOD; res = 1ll * res * c % MOD; return res; } ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:2:3","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"例题 ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:3:0","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"Luogu P4593 教科书般的亵渎 给出一个单调递增的长度为 $n$ 的数列，每次操作可以使数列的值全部减少 $x$，满足 $x$ 恰好是操作开始前数列开头的值域连续段全部被减为小于等于 $0$，操作结束后，将该连续段删除，并获得 $1+2^k+\\cdots +x^k$ 的分数。题面给出数列中没有出现的数，共 $m$ 个。 $1\\le n \\le 10^{13}$，$1\\le m \\le 10$。 把原题面转化为上述模型后，我们需要求 $f(x)=\\sum_{i=1}^{x}i^k$。 这里给出一个结论：一个 $n$ 次函数的前缀和为 $n+1$ 次。 所以考虑先求出 $\\forall i\\in [1,k+2]$ 的 $f(i)$，插值得到 $k+1$ 次的 $f(x)$。 至于题目中的减操作，$\\Theta(m^2)$ 模拟每一段即可。若使用前后缀积优化，则时间复杂度为 $\\Theta(m^2k)$。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cutility\u003e#include \u003cnumeric\u003e#include \u003cvector\u003eusing namespace std; using ll = long long; constexpr int maxm = 50 + 10; constexpr int mod = 1e9 + 7; int t, m; ll n, a[maxm]; int x[maxm], y[maxm]; int fac[maxm], inv[maxm], pre[maxm], suf[maxm]; int power(int x, int y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % mod; x = 1ll * x * x % mod; } return res; } inline int sgnInv(int n) { static int inv[2] = {power(1, mod - 2), power(mod - 1, mod - 2)}; return inv[n % 2]; } void preprocess() { fac[0] = 1; for (int i = 1; i \u003c= maxm - 1; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; inv[maxm - 1] = power(fac[maxm - 1], mod - 2); for (int i = maxm - 2; i \u003e= 0; --i) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; } int interpolation(ll x0, int deg, int x[], int y[]) { int ans = 0; pre[0] = suf[deg + 2] = 1; for (int i = 1; i \u003c= deg + 1; ++i) pre[i] = 1ll * pre[i - 1] * (x0 - i + mod) % mod; for (int i = deg + 1; i \u003e= 1; --i) suf[i] = 1ll * suf[i + 1] * (x0 - i + mod) % mod; for (int i = 1; i \u003c= deg + 1; ++i) { int num = 1ll * y[i] * pre[i - 1] % mod * suf[i + 1] % mod; int den = 1ll * inv[i - 1] * inv[deg - i + 1] % mod * sgnInv(deg - i + 1) % mod % mod; ans = (1ll * ans + 1ll * num * den % mod) % mod; } return (ans + mod) % mod; } int calc(ll x0) { if (x0 \u003c= m + 3) return y[x0]; return interpolation(x0, m + 2, x, y); } int solve() { int ans = 0; for (int i = 1; i \u003c= m + 3; ++i) { x[i] = i; y[i] = (y[i - 1] + power(i, m + 1)) % mod; } for (int i = 1; i \u003c= m; ++i) { ans = (ans + calc(n)) % mod; for (int j = i; j \u003c= m; ++j) ans = (ans - power(a[j], m + 1) + mod) % mod; for (int j = i + 1; j \u003c= m; ++j) a[j] -= a[i]; n -= a[i]; } if (n != 0) ans = (ans + calc(n)) % mod; return ans; } int main() { ios::sync_with_stdio(false); preprocess(); cin \u003e\u003e t; while (t--) { cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= m; ++i) cin \u003e\u003e a[i]; sort(a + 1, a + 1 + m); cout \u003c\u003c solve() \u003c\u003c endl; } return 0; } ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:3:1","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"Luogu P3270 成绩比较 G 系共有 $N$ 位同学，$M$ 门必修课。这 $N$ 位同学的编号为 $0$ 到 $N-1$ 的整数，其中 B 神的编号为 $0$ 号。这 $M$ 门必修课编号为 $0$ 到 $M-1$ 的整数。一位同学在必修课上可以获得的分数是 $1$ 到 $U_i$ 中的一个整数。 如果在每门课上 A 获得的成绩均小于等于 B 获得的成绩，则称 A 被 B 碾压。在 B 神的说法中，G 系共有 $K$ 位同学被他碾压（不包括他自己），而其他 $N-K-1$ 位同学则没有被他碾压。D 神查到了 B 神每门必修课的排名。 这里的排名是指：如果 B 神某门课的排名为 $R$，则表示有且仅有 $R-1$ 位同学这门课的分数大于 B 神的分数，有且仅有 $N-R$ 位同学这门课的分数小于等于 B 神（不包括他自己）。 请你求出所有可能的成绩种类数。 $1\\le N\\le 100$，$1\\le M\\le 100$，$1\\le U_i\\le 10^9$，$1\\le R_i\\le N$。 考虑 DP。先只考虑成绩的相对关系，即先不管每个人的成绩具体是多少。设 $f[i][j]$ 表示前 $i$ 门课程 B 神能够碾压 $j$ 个人的方案数： $$ f[i][j]=\\sum_{k=j}^{N-1} f[i-1][k] \\binom{k}{j} \\binom{n-k-1}{r[i]-1-k+j}\\\\ f[0][N-1] = 1 $$ 这个式子意思是前 $i-1$ 门课中，B 神可以碾压 $k$ 人，但现在其中的 $k-j$ 人这门课成绩比 B 神高，无法被碾压，有 $\\binom{k}{j}$ 种方案，为了保证 B 神排名为 $r[i]$，除了刚才的 $k-j$ 人，还要有 $r[i]-1-k+j$ 人排在 B 神前面，这些人来自未被碾压的 $n-k-1$ 人中有 $\\binom{n-k-1}{r[i]-1-k+j}$ 种方案。 由于每门课的排名固定互相独立，所以设 $d(i)$ 为第 $i$ 门课的人的排名固定时成绩方案数，则有： $$ d(i)=\\sum_{j=1} j^{N-R_i} (U_i-j)^{R_i-1} $$ 这里的算法是枚举 B 神的分数，然后统计每个人可能的分数的方案数。可以发现 $j^{N-R_i} (U_i-j)^{R_i-1}$ 是一个 $N-1$ 次多项式，则 $d(i)$ 是一个 $n$ 次多项式，插值解决。 最后定义 $f[i][j]$ 为考虑成绩的具体取值的方案数： $$ f[i][j]=d(i)\\sum_{k=j}^{n-1} f[i-1][k] \\binom{k}{j} \\binom{n-k-1}{r[i]-1-k+j}\\\\ f[0][N-1]=1 $$ 最后答案为 $f[M][K]$。时间复杂度 $\\Theta(MN^2)$。 #include \u003ciostream\u003eusing namespace std; constexpr int MAXN = 100 + 10; constexpr int MOD = 1e9 + 7; int n, m, k; int u[MAXN], r[MAXN]; int c[MAXN][MAXN], d[MAXN], f[MAXN][MAXN]; int power(int x, int y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % MOD; x = 1ll * x * x % MOD; } return res; } int interpolation(int deg, int k, int x[], int y[]) { int res = 0; for (int i = 1; i \u003c= deg + 1; ++i) { int num = y[i], den = 1; for (int j = 1; j \u003c= deg + 1; ++j) { if (i == j) continue; num = 1ll * num * (k - x[j] + MOD) % MOD; den = 1ll * den * (x[i] - x[j] + MOD) % MOD; } res = (res + 1ll * num * power(den, MOD - 2)) % MOD; } return res; } int calc(int i) { int x[MAXN] = { 0 }, y[MAXN] = { 0 }; for (int j = 1; j \u003c= min(u[i], n + 1); ++j) { x[j] = j; y[j] = (y[j - 1] + 1ll * power(j, n - r[i]) * power(u[i] - j, r[i] - 1)) % MOD; } if (u[i] \u003c= n + 1) return y[u[i]]; return interpolation(n, u[i], x, y); } int main() { ios::sync_with_stdio(false); cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; for (int i = 1; i \u003c= m; ++i) cin \u003e\u003e u[i]; for (int i = 1; i \u003c= m; ++i) cin \u003e\u003e r[i]; for (int i = 0; i \u003c= n; ++i) c[i][0] = c[i][i] = 1; for (int i = 1; i \u003c= n; ++i) for (int j = 1; j \u003c i; ++j) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD; for (int i = 1; i \u003c= m; ++i) d[i] = calc(i); f[0][n - 1] = 1; for (int i = 1; i \u003c= m; ++i) { for (int j = 1; j \u003c n; ++j) { for (int k = j; k \u003c n; ++k) { if (k - j \u003e r[i] - 1) continue; int cnt = 1ll * c[k][j] * c[n - k - 1][r[i] - 1 - (k - j)] % MOD; int pre = 1ll * d[i] * f[i - 1][k] % MOD * cnt % MOD; f[i][j] = (f[i][j] + pre) % MOD; } } } cout \u003c\u003c f[m][k] \u003c\u003c endl; return 0; } ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:3:2","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"Luogu P4463 calc 定义一个长度为 $n$ 的正整数数列 $a_n$ 的权值为 $\\prod_{i=1}a_i$，现在要求你求出所有满足以下条件的数列的权值并对质数 $p$ 取模： $\\forall i,j \\in [1,n]\\wedge i\\ne j$，$a_i\\ne a_j$。 $\\forall i \\in [1,n]$，$a_i\\in [1,k]$。 $1\\le k\\le 10^9$，$1\\le n\\le 500$，$2 \\le p \\le 10^9$，$p\u003ek\u003en+1$。 设 $f[i][j]$ 为不考虑数的顺序情况下，在数列的前 $i$ 个数都属于 $[1,j]$ 的权值和，考虑选或不选 $j$ 这个数，则有： $$ f[i][j]=f[i][j-1]+j\\cdot f[i-1][j-1]\\\\ f[0][j]=1 $$ 最后答案为 $f[n][k]$。可以想到需要插值，现在重点是要知道 $f[n][x]$ 的次数。 设 $d[i][j]$ 为 $f[i][j]$ 的次数. 首先可以知道 $d[0][j]=0$。 对于 $i=1$，仅考虑 $f[1][j]\\longleftarrow j\\cdot f[0][j-1]$，则 $d[1][j] = 1$，而考虑 $f[1][j]\\longleftarrow f[1][j-1]$，相当于做前缀和，则 $d[1][j] = 2$。 对于 $i=2$，仅考虑 $f[2][j]\\longleftarrow j\\cdot f[1][j-1]$，则 $d[2][j] = 3$，而考虑 $f[2][j]\\longleftarrow f[2][j-1]$，相当于做前缀和，则 $d[2][j] = 4$。 etc. 最后得到 $d[n][x]=2n$，则需要处理出 $2n+1$ 个 $f[n][x_i]$。 注意这还没考虑数的顺序，对数列进行全排列，答案为 $n!f[n][k]$。 时间复杂度 $\\Theta(2n^2+8n^3)$。 #include \u003cbits/stdc++.h\u003eusing namespace std; constexpr int MAXN = 500 + 10; int n, k, p, f[MAXN][MAXN * 2]; int x[MAXN * 2], y[MAXN * 2]; void DP() { for (int i = 0; i \u003c= 2 * n; ++i) f[0][i] = 1; for (int i = 1; i \u003c= n; ++i) for (int j = 1; j \u003c= 2 * n; ++j) f[i][j] = (f[i][j - 1] + 1ll * j * f[i - 1][j - 1]) % p; } int power(int x, int y) { int res = 1; while (y) { if (y % 2) res = 1ll * res * x % p; x = 1ll * x * x % p; y /= 2; } return res % p; } int inv(int x) { return power(x, p - 2); } int interpolation(int deg, int k, int x[], int y[]) { int ans = 0; for (int i = 1; i \u003c= deg + 1; ++i) { int num = y[i], den = 1; for (int j = 1; j \u003c= deg + 1; ++j) { if (i == j) continue; num = 1ll * num * (k - x[j] + p) % p; den = 1ll * den * (x[i] - x[j] + p) % p; } ans = (ans + 1ll num * inv(den) % p) % p; } return ans; } int main() { cin \u003e\u003e k \u003e\u003e n \u003e\u003e p; DP(); for (int i = 1; i \u003c= 2 * n + 1; ++i) { x[i] = i; y[i] = f[n][i]; } int ans = interpolation(2 * n, k % p, x, y); for (int i = 1; i \u003c= n; ++i) ans = 1ll * ans * i % p; cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2022-02-07","objectID":"/contents/20220207-lagrange-interpolation-note/:3:3","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"/contents/20220207-lagrange-interpolation-note/"},{"categories":["笔记"],"content":"高斯消元主要用于求解线性方程组的解，同时可以解决某些有后效性的 DP 问题， ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:0:0","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"算法思想 ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:1:0","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"增广矩阵 为了更方便地求解方程组，可以将系数和常数项放入矩阵，接下来就可以用一些矩阵的操作来消元了。 比如有一个方程组如下： $$ \\begin{cases} 3x+2y+3z=10\\\\ 3x+y+4z=12\\\\ x+y+z=4 \\end{cases} $$ 我们可以这么用矩阵表示: $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \\\\ 3 \u0026 1 \u0026 4 \\\\ 1 \u0026 1 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 10 \\\\ 12 \\\\ 1 \\end{bmatrix} $$ 在理论分析和实现代码时，为了方便，通常把两个矩阵拼在一起，这个矩阵就是增广矩阵： $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \u0026 10 \\\\ 3 \u0026 1 \u0026 4 \u0026 12 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \\end{bmatrix} $$ 增广矩阵的第 $i$ 行代笔第 $i$ 个方程，第 $i$ 列表示第 $i$ 个未知数的系数或常数项，接下来用 $x_i$ 表示第 $i$ 个未知数。 ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:1:1","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"初等行变换 初等行变换是指行之间的加减乘等运算。消元的本质就是利用初等行变换，使未知数的系数变为 $0$。具体地，初等行变换是两个行中的元素逐一进行运算，以上面的矩阵为例，记 $row_i$ 表示第 $i$ 行，则 $row_2 \\longleftarrow row_2 - \\frac{2}{3}row_1$ 的结果就是： $$ \\begin{bmatrix} 0 \u0026 -2 \u0026 -\\frac{1}{2} \u0026 -3 \\end{bmatrix} $$ 这个操作使该行的第 $1$ 个元素变为了 $0$，从方程的意义上考虑，就是消去了一个元。 ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:1:2","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"三角矩阵和对角矩阵 三角矩阵是指一个矩阵的一个三角部分全部为 $0$，对角矩阵则是对角线之外的元素均为 $0$。高斯消元中，三角矩阵一般指下三角矩阵，对角矩阵一般指除常数项部分为对角矩阵的矩阵。 假设得到了一个对角矩阵： $$ \\begin{bmatrix} k_1 \u0026 0 \u0026 0 \u0026 c_1\\\\ 0 \u0026 k_2 \u0026 0 \u0026 c_2\\\\ 0 \u0026 0 \u0026 k_3 \u0026 c_3 \\end{bmatrix} $$ 那就相当于是一个个的一元线性方程，直接解出即可。而对角矩阵可以通过三角矩阵得出： $$ \\begin{bmatrix} k_{11} \u0026 k_{12} \u0026 k_{13} \u0026 c_1\\\\ 0 \u0026 k_{22} \u0026 k_{23} \u0026 c_2\\\\ 0 \u0026 0 \u0026 k_{33} \u0026 c_3 \\end{bmatrix} $$ 首先可以解出 $x_3$，然后将 $x_3$ 带入第 $2$ 个方程，则 $k_{23}x_3$ 就成为了常数项，移项一下得到： $$ \\begin{bmatrix} k_{11} \u0026 k_{12} \u0026 k_{13} \u0026 c_1\\\\ 0 \u0026 k_{22} \u0026 0 \u0026 c_2 - k_{23}x_3\\\\ 0 \u0026 0 \u0026 k_{33} \u0026 c_3 \\end{bmatrix} $$ 同理带入 $x_2,x_3$ 到第 $1$ 个方程： $$ \\begin{bmatrix} k_{11} \u0026 0 \u0026 0 \u0026 c_1 - k_{12}x_2 - k_{13}x_3\\\\ 0 \u0026 k_{22} \u0026 0 \u0026 c_2 - k_{23}x_3\\\\ 0 \u0026 0 \u0026 k_{33} \u0026 c_3 \\end{bmatrix} $$ ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:1:3","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"具体步骤与实例 只要从上往下将每行与它下面的行进行运算，每枚举一行就消去一个元，枚举第 $i$ 行则消去 $x_i$，即通过初等行变换把第 $i + 1$ 到 $n$ 的方程的 $x_i$ 系数变为 $0$。最后从下往上带入即可。 以上面的矩阵为例，这里就模拟到得到三角矩阵： $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \u0026 10 \\\\ 3 \u0026 1 \u0026 4 \u0026 12 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \\end{bmatrix} $$ Step 1: $row_2 \\longleftarrow row_2 - \\frac{2}{3}row_1$ $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \u0026 10 \\\\ 0 \u0026 -2 \u0026 -\\frac{1}{2} \u0026 -3 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \\end{bmatrix} $$ Step 2: $row_3 \\longleftarrow row_3 - \\frac{1}{2}row_1$ $$ \\begin{bmatrix} 2 \u0026 2 \u0026 3 \u0026 10 \\\\ 0 \u0026 -2 \u0026 -\\frac{1}{2} \u0026 -3 \\\\ 0 \u0026 0 \u0026 -\\frac{1}{2} \u0026 -4 \\end{bmatrix} $$ Step 3: $row_3 \\longleftarrow row_3 - 0\\cdot row_2$ 增广矩阵不变。 ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:1:4","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"高斯-约旦消元 由于计算机上浮点数的精度有限，要尽可能选择绝对值较大的数作为除数，所以枚举到第 $i$ 行时，可以找到 $x_i$ 的系数最大的方程，与当前行交换，这种方法叫做高斯-约旦消元法。 ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:1:5","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"解的判断 方程组有可能有无数解（含自由元）或无解。得到一个对角矩阵后，若存在对角元素 $k_{ii} = 0$，而常数项 $c_i \\ne 0$，则无解，否则若存在对角元素 $k_{ii} = 0$，而常数项 $c_i = 0$，则含自由元。 ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:1:6","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"代码实现 class EquationGroup { public: enum class Result { UNIQUE, INFINITY, NO_SOLUTION }; void init(int n) { this-\u003en = n; e = vector\u003cvector\u003cdouble\u003e\u003e(n + 1, vector\u003cdouble\u003e(n + 2)); } vector\u003cdouble\u003e \u0026operator[](int x) { return e[x]; } pair\u003cvector\u003cdouble\u003e, Result\u003e solve() { transform(); Result res = calc(); vector\u003cdouble\u003e x(n + 1); for (int i = 1; i \u003c= n; ++i) x[i] = e[i][n + 1]; return {x, res}; } private: vector\u003cvector\u003cdouble\u003e\u003e e; int n; // 未知数个数 void transform() { for (int i = 1; i \u003c= n; ++i) { int p = i; // 选择 e[][i] 绝对值最大的一行进行交换 for (int j = i + 1; j \u003c= n; ++j) if (abs(e[p][i]) \u003c abs(e[j][i])) p = j; if (p != i) for (int j = 1; j \u003c= n + 1; ++j) swap(e[i][j], e[p][j]); // 初等行变换 for (int j = i + 1; j \u003c= n; ++j) { double rate = e[j][i] / e[i][i]; for (int k = 1; k \u003c= n + 1; ++k) e[j][k] -= e[i][k] * rate; } } } Result calc() { Result res = Result::UNIQUE; for (int i = n; i \u003e= 1; --i) { // 把解 x_i 存在 e[i][n + 1] 中 for (int j = i + 1; j \u003c= n; ++j) e[i][n + 1] -= e[i][j] * e[j][n + 1]; if (!e[i][i]) { e[i][n + 1] /= e[i][i]; } else { if (e[i][n + 1]) res = Result::NO_SOLUTION; else if (res != Result::NO_SOLUTION) res = Result::INFINITY; } } return res; } }; ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:2:0","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"例题 ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:3:0","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"Luogu P4035 球形空间产生器 给出一个 $n + 1$ 个 $n$ 维空间的点，求这 $n + 1$ 个点构成的 $n$ 维球体的球心。 $1 \\le n \\le 10$。 设球心为 $(x_1,x_2,\\dots,x_n)$，半径为 $r$，对于球体的某个点 $p$，有如下关系： $$ \\sum_{i = 1}^{n} (p_i - x_i) ^ 2 = r ^ 2\\\\ $$ 展开并移项得到： $$ \\sum_{i = 1}^{n} 2p_ix_i + (r ^ 2 - \\sum_{i = 1}^{n} x_i ^ 2) = \\sum_{i = 1}^{n} p_i ^ 2 $$ 把括号看成一个整体，显然是一个 $n + 1$ 元线性方程组，直接高斯消元求解。 #include \u003ciostream\u003e#include \u003ciomanip\u003e#include \u003ccmath\u003eusing namespace std; constexpr int MAXN = 10 + 5; int n; double pos[MAXN][MAXN], mat[MAXN][MAXN]; void preprocess() { for (int i = 1; i \u003c= n + 1; ++i) { double sum = 0; for (int j = 1; j \u003c= n; ++j) { mat[i][j] = 2 * pos[i][j]; sum += pos[i][j] * pos[i][j]; } mat[i][n + 1] = 1; mat[i][n + 2] = sum; } } void transform(int n) { for (int i = 1; i \u003c= n; ++i) { int p = i; for (int j = i + 1; j \u003c= n; ++j) if (abs(mat[p][i]) \u003c abs(mat[j][i])) p = j; if (i != p) for (int j = i; j \u003c= n + 1; ++j) swap(mat[i][j], mat[p][j]); for (int j = i + 1; j \u003c= n; ++j) { double rate = mat[j][i] / mat[i][i]; for (int k = i; k \u003c= n + 1; ++k) mat[j][k] -= rate * mat[i][k]; } } } void calc(int n) { for (int i = n; i \u003e= 1; --i) { for (int j = i + 1; j \u003c= n; ++j) mat[i][n + 1] -= mat[i][j] * mat[j][n + 1]; mat[i][n + 1] /= mat[i][i]; } } void guass(int n) { transform(n); calc(n); } int main() { ios::sync_with_stdio(false); cin \u003e\u003e n; for (int i = 1; i \u003c= n + 1; ++i) for (int j = 1; j \u003c= n; ++j) cin \u003e\u003e pos[i][j]; preprocess(); guass(n + 1); for (int i = 1; i \u003c= n; ++i) cout \u003c\u003c fixed \u003c\u003c setprecision(3) \u003c\u003c mat[i][n + 2] \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:3:1","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"Codeforces 24D Broken robot $n$ 行 $m$ 列的矩阵，$(1, 1)$ 是矩阵的左上角，$(n, m)$ 是矩阵的右下角。现在你在 $(x, y)$，每次等概率向左，右，下走或原地不动，但不能走出去，问走到最后一行期望的步数。（原地不动也算一步） $1 \\le n, m \\le 10 ^ 3$，$1 \\le x \\le n$，$1 \\le y \\le m$。 先考虑 $m = 1$ 的情况，有 $\\frac{1}{2}$ 的概率留在原地，$\\frac{1}{2}$ 的概率向下走，期望步数为 $2 (m - x)$。 若 $m \u003e 1$，设 $f[i][j]$ 为从 $(i, j)$ 走到最后一行的期望步数，则 $$ f[i][j] = \\begin{cases} \\frac{f[i][j + 1] + f[i + 1][j] + f[i][j]}{3} + 1 \u0026 j = 1\\\\ \\frac{f[i][j - 1] + f[i][j + 1] + f[i + 1][j] + f[i][j]}{4} + 1 \u0026 1 \u003c j \u003c m\\\\ \\frac{f[i][j - 1] + f[i + 1][j] + f[i][j]}{3} + 1 \u0026 j = m \\end{cases} $$ 移项可得： $$ \\begin{cases} 2f[i][j] - f[i][j + 1] - f[i + 1][j] = 3 \u0026 j = 1\\\\ 3f[i][j] - f[i][j - 1] - f[i][j + 1] - f[i + 1][j] = 4 \u0026 1 \u003c j \u003c m\\\\ 2f[i][j] - f[i][j - 1] - f[i + 1][j] = 3 \u0026 j = m \\end{cases} $$ 于是每行的转移就可以解决了。然而暴力消元的复杂度不正确，考虑到每个方程都至多只有三个系数不为 $0$，每一行只会消去下一行的一个元（可以手画一个矩阵），利用这个性质，消元可以做到 $\\Theta(m)$，总的复杂度就是 $\\Theta(m (n-x))$。 #include \u003ciostream\u003e#include \u003ciomanip\u003eusing namespace std; constexpr int MAXN = 1e3 + 5; // * * 0 0 0 0 | * // * * * 0 0 0 | * // 0 * * * 0 0 | * // 0 0 * * * 0 | * // 0 0 0 * * * | * // 0 0 0 0 * * | * int n, m, x, y; double mat[MAXN][MAXN], f[MAXN]; void fill() { mat[1][1] = 2; mat[1][2] = -1; mat[1][m + 1] = 3 + f[1]; for (int i = 2; i \u003c m; ++i) { mat[i][i] = 3; mat[i][i - 1] = -1; mat[i][i + 1] = -1; mat[i][m + 1] = 4 + f[i]; } mat[m][m] = 2; mat[m][m - 1] = -1; mat[m][m + 1] = 3 + f[m]; } void gauss() { for (int i = 1; i \u003c m; ++i) { double rate = mat[i + 1][i] / mat[i][i]; mat[i + 1][i] = 0; mat[i + 1][i + 1] -= rate * mat[i][i + 1]; mat[i + 1][m + 1] -= rate * mat[i][m + 1]; } mat[m][m + 1] /= mat[m][m]; for (int i = m - 1; i \u003e= 1; --i) mat[i][m + 1] = (mat[i][m + 1] - mat[i + 1][m + 1] * mat[i][i + 1]) / mat[i][i]; for (int i = 1; i \u003c= m; ++i) f[i] = mat[i][m + 1]; } int main() { ios::sync_with_stdio(false); cin \u003e\u003e n \u003e\u003e m \u003e\u003e x \u003e\u003e y; if (m == 1) { cout \u003c\u003c 2 * (n - x) \u003c\u003c endl; return 0; } for (int i = n - 1; i \u003e= x; --i) { fill(); gauss(); } cout \u003c\u003c setprecision(8) \u003c\u003c f[y] \u003c\u003c endl; return 0; } ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:3:2","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"Luogu P3232 游走 给定一个 $n$ 个点 $m$ 条边的无向连通图，顶点从 $1$ 编号到 $n$，边从 $1$ 编号到 $m$。 小 Z 在该图上进行随机游走，初始时小 Z 在 $1$ 号顶点，每一步小 Z 以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小 Z 到达 $n$ 号顶点时游走结束，总分为所有获得的分数之和。现在，请你对这 $m$ 条边进行编号，使得小 Z 获得的总分的期望值最小。 $2 \\le n \\le 500$，$1 \\le m \\le 125000$。 设 $f[i]$ 表示走到 $i$ 的期望次数，$deg[i]$ 为点 $x$ 的度，则对于一条边 $(x, y)$，其期望次数为： $$ \\frac{f[x]}{deg[x]} + \\frac{f[y]}{deg[y]} $$ 考虑 $f[i]$ 的转移，设 $j$ 为 $i$ 的上一个结点，则： $$ f[i] = \\sum\\frac{f[j]}{deg[j]} + [i = 1] $$ 因为初始在点 $1$，则期望次数会多 $1$。把这个方程，由于 $n$ 是终点，不参加转移，设 $f[n] = 0$。于是前 $n - 1$ 个转移方程组成一个方程组，解出它即可。 最后算出每条边的期望次数，根据排序不等式，次数越多的边应该编号越小，这样答案更优。 #include \u003ciostream\u003e#include \u003ciomanip\u003e#include \u003ccmath\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; constexpr int MAXN = 500 + 10; constexpr int MAXM = 125000 + 10; struct Equation { double a[MAXN]; double \u0026operator[](int x) { return a[x]; } }; struct EquationGroup { Equation e[MAXN]; int n; void init(int n) { this-\u003en = n; } Equation \u0026operator[](int x) { return e[x]; } void transform() { for (int i = 1; i \u003c= n; ++i) { int p = i; for (int j = i + 1; j \u003c= n; ++j) if (abs(e[p][i]) \u003c abs(e[j][i])) p = j; if (p != i) for (int j = 1; j \u003c= n + 1; ++j) swap(e[i][j], e[p][j]); for (int j = i + 1; j \u003c= n; ++j) { double rate = e[j][i] / e[i][i]; for (int k = 1; k \u003c= n + 1; ++k) e[j][k] -= e[i][k] * rate; } } } void calc() { for (int i = n; i \u003e= 1; --i) { for (int j = i + 1; j \u003c= n; ++j) e[i][n + 1] -= e[i][j] * e[j][n + 1]; e[i][n + 1] /= e[i][i]; } } vector\u003cdouble\u003e solve() { transform(); calc(); vector\u003cdouble\u003e res(n + 1); for (int i = 1; i \u003c= n; ++i) res[i] = e[i][n + 1]; return res; } }; struct Edge { int x, y; double p; bool operator\u003c(const Edge \u0026rhs) const { return p \u003e rhs.p; } }; int n, m; EquationGroup e; vector\u003cint\u003e graph[MAXN]; int deg[MAXN]; Edge edges[MAXM]; double ans; void link(int x, int y) { graph[x].push_back(y); graph[y].push_back(x); ++deg[x]; ++deg[y]; } int main() { ios::sync_with_stdio(false); cout \u003c\u003c fixed \u003c\u003c setprecision(3); cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= m; ++i) { auto \u0026[x, y, p] = edges[i]; cin \u003e\u003e x \u003e\u003e y; link(x, y); } e.init(n - 1); for (int i = 1; i \u003c n; ++i) { for (int j : graph[i]) if (j != n) e[i][j] = -1.0 / deg[j]; e[i][i] = 1; } e[1][n] = 1; auto f = e.solve(); for (int i = 1; i \u003c= m; ++i) { auto \u0026[x, y, p] = edges[i]; p = (x != n ? f[x] / deg[x] : 0) + (y != n ? f[y] / deg[y] : 0); } sort(edges + 1, edges + 1 + m); for (int i = 1; i \u003c= m; ++i) ans += i * edges[i].p; cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:3:3","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["笔记"],"content":"Luogu P3211 XOR 和路径 给定一个无向连通图，有 $n$ 个点和 $m$ 条边，其节点编号为 $1$ 到 $n$，其边的权值为非负整数。从 $1$ 号节点开始，以相等的概率随机选择一个有连边的点，并沿这条边走到下一个节点，重复这个过程，直到走到 $n$ 号节点为止，便得到一条从 $1$ 号节点到 $n$ 号节点的路径，请你求出该算法得到的路径的 XOR 和的期望值。 设 $(x, y, w)$ 为图中的一条边，$1 \\le x, y \\le n$，$0 \\le w \\le 10 ^ 9$，$2 \\le n \\le 100$，$1 \\le m \\le 10000$。图中可能有重边或自环。 首先可能想到设 $f[x]$ 为 $x$ 点的 XOR 期望，方程为 $$ f[x] = \\sum_y \\frac{f[y] \\oplus w(x, y)}{deg[x]} $$ 但是这种方程是无法转移的。先考虑答案是怎么得到的假设有一条路径 $P = \\{w_1, w_2, \\dots, w_k\\}$，其对答案的贡献为： $$ p(w_1 \\oplus w_2 \\oplus \\cdots \\oplus w_k) $$ 如果按位考虑，分子的结果只会是 $0$ 或 $1$，只需要求出分子的结果为 $1$ 的概率。 设 $f[x][0/1]$ 为点 $x$ 到点 $n$ 的路径异或值为 $0/1$ 的概率。于是可以写成方程： $$ f[x][0] = \\sum_y \\frac{f[y][w(x, y)]}{deg[x]}\\\\ f[x][1] = \\sum_y \\frac{f[y][w(x, y) \\oplus 1]}{deg[x]}\\\\ $$ 设当前枚举的位数为 $b$，则对答案的贡献为 $2 ^ b f[1][1]$。上述转移显然可以高斯消元解决，时间复杂度 $\\Theta(n ^ 3 \\log_2 w)$。 注意连接自环不要连两遍。 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003ccmath\u003e#include \u003ciomanip\u003eusing namespace std; constexpr int MAXN = 100 + 10; class EquationGroup { public: void init(int n) { this-\u003en = n; e = vector\u003cvector\u003clong double\u003e\u003e(n + 1, vector\u003clong double\u003e(n + 2, 0)); } vector\u003clong double\u003e \u0026operator[](int x) { return e[x]; } vector\u003clong double\u003e solve() { transform(); calc(); vector\u003clong double\u003e res(n + 1); for (int i = 1; i \u003c= n; ++i) res[i] = e[i][n + 1]; return res; } private: int n; vector\u003cvector\u003clong double\u003e\u003e e; void transform() { for (int i = 1; i \u003c= n; ++i) { int p = i; for (int j = i + 1; j \u003c= n; ++j) if (abs(e[p][i]) \u003c abs(e[j][i])) p = j; if (p != i) for (int j = i; j \u003c= n + 1; ++j) swap(e[i][j], e[p][j]); for (int j = i + 1; j \u003c= n; ++j) { long double rate = e[j][i] / e[i][i]; for (int k = i; k \u003c= n + 1; ++k) e[j][k] -= rate * e[i][k]; } } } void calc() { for (int i = n; i \u003e= 1; --i) { for (int j = i + 1; j \u003c= n; ++j) e[i][n + 1] -= e[i][j] * e[j][n + 1]; e[i][n + 1] /= e[i][i]; } } }; int n, m, mx; EquationGroup e; vector\u003cpair\u003cint, int\u003e\u003e graph[MAXN]; int deg[MAXN]; long double ans; void link(int x, int y, int w) { graph[x].push_back({y, w}); ++deg[x]; if (x != y) { graph[y].push_back({x, w}); ++deg[y]; } } long double calc(int b) { e.init(2 * n); for (int x = 1; x \u003c n; ++x) { e[x][x] += deg[x]; e[x + n][x + n] += deg[x]; for (auto [y, w] : graph[x]) { int w1 = ((w \u003e\u003e b) \u0026 1); e[x][y + w1 * n] += -1; e[x + n][y + (w1 ^ 1) * n] += -1; } } e[n][n] = 1; e[n][2 * n + 1] = 1; e[n + n][2 * n] = 1; e[n + n][2 * n + 1] = 0; auto f = e.solve(); return f[1 + n] * (1 \u003c\u003c b); } int main() { ios::sync_with_stdio(false); cout \u003c\u003c fixed \u003c\u003c setprecision(3); cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= m; ++i) { int x, y, w; cin \u003e\u003e x \u003e\u003e y \u003e\u003e w; link(x, y, w); mx = max(mx, w); } mx = (int) log2(mx); for (int i = 0; i \u003c= mx; ++i) ans += calc(i); cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2022-02-06","objectID":"/contents/20220206-gauss-elimination-note/:3:4","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"/contents/20220206-gauss-elimination-note/"},{"categories":["题解"],"content":"这里给出一种无需换根的 DP 思路。 ","date":"2022-02-04","objectID":"/contents/20220204-luogu-p3647-solution/:0:0","tags":["OI","DP","树形 DP","C++"],"title":"Luogu P3647 连珠线题解","uri":"/contents/20220204-luogu-p3647-solution/"},{"categories":["题解"],"content":"Part 1 我们从结点的添加方式入手，可以把结点分为三类： 初始的结点，这种结点只有一个 通过 Append 添加的结点，以下简称 A 类结点 通过 Insert 添加的结点，以下简称 I 类结点 不换根的思路核心就在于保证转移时的过程符合结点的添加规则。为了方便，我们可以给每条线定向。同时假设 $1$ 为根，$x$ 为当前结点，$y$ 为 $x$ 的一个儿子结点，$fa$ 为 $x$ 的父亲结点。很显然接下来可以分 $6$ 类讨论： 若 $x$ 为初始结点，则其子结点、$fa$ 都应该连向 $x$ 若 $x$ 为 A 类结点 $x$ 向 $fa$ 连一条红线，子结点连向 $x$ $x$ 向其中一个子结点 $y$ 连一条红线，其他子结点以及 $fa$ 连向 $x$ 若 $x$ 为 I 类结点 $x$ 取代一个子结点 $y$ 连向 $fa$ 的红线，然后换成蓝线 $x$ 取代两个个子结点 $y_1$ 和 $y_2$ 之间的红线，然后换成蓝线 $x$ 取代 $fa$ 连向一个子结点 $y$ 的红线，然后换成蓝线 上面的分类讨论中的“连向”可以看成 Append 或 Insert，根据题意计算就可以了。 ","date":"2022-02-04","objectID":"/contents/20220204-luogu-p3647-solution/:1:0","tags":["OI","DP","树形 DP","C++"],"title":"Luogu P3647 连珠线题解","uri":"/contents/20220204-luogu-p3647-solution/"},{"categories":["题解"],"content":"Part 2 接下来根据分类讨论设出状态以及写出方程： long long f[MAXN][6]; /** * f[x][0]: x is initial * f[x][1]: x -\u003e fa * f[x][2]: x -\u003e y * f[x][3]: y -\u003e x -\u003e fa * f[x][4]: y1 -\u003e x -\u003e y2 * f[x][5]: fa -\u003e x -\u003e y */ 设 $cont(x)$ 表示 $x$ 向其父结点连线的贡献，则 $cont(x)=\\max\\{f[x][1],f[x][3]+len(x,fa(x))\\}$。 $$ f[x][0]=\\sum_{y\\in son(x)}cont(y)\\\\ f[x][1]=\\sum_{y\\in son(x)}cont(y)\\\\ f[x][2]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{\\max\\{f[y][0], f[y][2], f[y][4], f[y][5] + len(y,x)\\}-cont(y)\\}\\\\ f[x][3]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{f[y][1]+len(y,x)-cont(y)\\}\\\\ f[x][4]=\\sum_{y\\in son(x)}cont(y)+\\\\\\max_{y_1,y_2\\in son(x)\\wedge y_1\\ne y_2}\\{ f[y_1][1]+len(y_1,x)-cont(y_1)+\\max\\{f[y_2][0], f[y_2][2], f[y_2][4]\\}+len(y_2,x)-cont(y_2)\\}\\\\ f[x][5]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{\\max\\{f[y][0], f[y][2], f[y][4]\\}+len(y,x)-cont(y)\\} $$ 上面的转移都可以看成先从子结点按照 $cont(x)$ 转移，在钦定某个结点按照特定的方式转移，记录下最优的差值在加到 $f$ 里即可。$f[x][4]$ 有两个变量，可以考虑枚举其中一个，用 std::multiset\u003cT\u003e 维护另外一个的最值即可。 时间复杂度 $O(n \\log_2 n)$。 ","date":"2022-02-04","objectID":"/contents/20220204-luogu-p3647-solution/:2:0","tags":["OI","DP","树形 DP","C++"],"title":"Luogu P3647 连珠线题解","uri":"/contents/20220204-luogu-p3647-solution/"},{"categories":["题解"],"content":"Part 3 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cset\u003eusing namespace std; constexpr int MAXN = 200000 + 10; constexpr int INFINITY = 0x7fffffff; int n; vector\u003cpair\u003cint, int\u003e\u003e tree[MAXN]; long long f[MAXN][6]; /** * f[x][0]: x is initial * f[x][1]: x -\u003e fa * f[x][2]: x -\u003e y * f[x][3]: y -\u003e x -\u003e fa * f[x][4]: y1 -\u003e x -\u003e y2 * f[x][5]: fa -\u003e x -\u003e y */ void link(int x, int y, int l) { tree[x].push_back({y, l}); tree[y].push_back({x, l}); } void dfs(int x, int fa) { if (tree[x].size() == 1 \u0026\u0026 fa != 0) { f[x][2] = f[x][3] = f[x][4] = f[x][5] = -INFINITY; return; } long long sum = 0, delta[4] = {-INFINITY, -INFINITY, -INFINITY, -INFINITY}; multiset\u003clong long\u003e val; val.insert(-INFINITY); for (auto [y, l] : tree[x]) { if (y == fa) continue; dfs(y, x); long long cont = max(f[y][1], f[y][3] + l); sum += cont; for (int i = 0; i \u003c 6; ++i) f[x][i] += cont; delta[0] = max(delta[0], max(max(max(f[y][0], f[y][2]), f[y][4]), f[y][5] + l) - cont); delta[1] = max(delta[1], f[y][1] + l - cont); delta[3] = max(delta[3], max(max(f[y][0], f[y][2]), f[y][4]) + l - cont); val.insert(f[y][1] + l - cont); } for (auto [y, l] : tree[x]) { if (y == fa) continue; int cont = max(f[y][1], f[y][3] + l); val.erase(val.find(f[y][1] + l - cont)); delta[2] = max(delta[2], *val.rbegin() + max(max(f[y][0], f[y][2]), f[y][4]) + l - cont); val.insert(f[y][1] + l - cont); } f[x][2] += delta[0]; f[x][3] += delta[1]; f[x][4] += delta[2]; f[x][5] += delta[3]; for (int i = 0; i \u003c 6; ++i) if (f[x][i] \u003c 0) f[x][i] = -INFINITY; } int main() { ios::sync_with_stdio(false); cin \u003e\u003e n; if (n == 1) { cout \u003c\u003c 0 \u003c\u003c endl; return 0; } for (int i = 1; i \u003c n; ++i) { int x, y, l; cin \u003e\u003e x \u003e\u003e y \u003e\u003e l; link(x, y, l); } dfs(1, 0); cout \u003c\u003c max(max(f[1][0], f[1][2]), f[1][4]) \u003c\u003c endl; return 0; } ","date":"2022-02-04","objectID":"/contents/20220204-luogu-p3647-solution/:3:0","tags":["OI","DP","树形 DP","C++"],"title":"Luogu P3647 连珠线题解","uri":"/contents/20220204-luogu-p3647-solution/"}]