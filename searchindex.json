{"categories":[{"title":"Document","uri":"https://ctj12461.vercel.app/categories/document/"},{"title":"Olympiad in Information","uri":"https://ctj12461.vercel.app/categories/olympiad-in-information/"},{"title":"Tech","uri":"https://ctj12461.vercel.app/categories/tech/"}],"posts":[{"content":"æ¦‚è¿° MultiGenerator æ˜¯ä¸€ä¸ªä¸º OI è€Œç”Ÿçš„å¤šçº¿ç¨‹å¹¶è¡Œæ•°æ®ç”Ÿæˆåº“ï¼ŒåŸºäº C++ 17ï¼Œä½¿ç”¨é¢å‘å¯¹è±¡å’Œæ³›å‹ç­‰ Morden C++ é«˜çº§ç‰¹æ€§ï¼Œåªéœ€è¦æ·»åŠ æœ€å°‘çš„é¢å¤–ä»£ç ï¼Œå°±å¯ä»¥è·å¾—æœ€é«˜çš„æ€§èƒ½ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªèƒ½å¤ŸæŒ‡å®šæ•°æ®èŒƒå›´çš„ A + B Problem æ•°æ®ç”Ÿæˆå™¨çš„ç¤ºä¾‹ä»£ç ï¼š\n#include \u0026lt;random\u0026gt; #include \u0026lt;MultiGenerator.hpp\u0026gt; using MultiGenerator::DataConfig; using MultiGenerator::GeneratingTask; using MultiGenerator::SolutionTask; using MultiGenerator::NormalTemplate; using MultiGenerator::entry; using MultiGenerator::testcase; /** æŒ‡å®šæ•°æ®ç”Ÿæˆå™¨ï¼Œä»…éœ€ç»§æ‰¿ä¸€ä¸ªæŠ½è±¡ç±»å’Œå®ç°ä¸€ä¸ªæˆå‘˜å‡½æ•° */ class AddGenerator : public GeneratingTask { private: void generate(std::ostream \u0026amp;data, const DataConfig \u0026amp;config) override { /** DataConfig ä¸ºé…ç½®ä¿¡æ¯ï¼Œå¯ä»¥ç”¨äºå‚¨å­˜æ•°æ®èŒƒå›´ç­‰å…ƒä¿¡æ¯ */ auto minValue = std::stoi(config.get(\u0026quot;minValue\u0026quot;).value()); auto maxValue = std::stoi(config.get(\u0026quot;maxValue\u0026quot;).value()); std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution\u0026lt;\u0026gt; dist(minValue, maxValue); /** åƒ cout ä¸€æ ·è¾“å‡ºç”Ÿæˆç»“æœ */ data \u0026lt;\u0026lt; dist(gen) \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; dist(gen) \u0026lt;\u0026lt; std::endl; } }; /** æŒ‡å®šæ•°æ®æ±‚è§£å™¨ï¼Œä¹Ÿä»…éœ€ç»§æ‰¿ä¸€ä¸ªæŠ½è±¡ç±»å’Œå®ç°ä¸€ä¸ªæˆå‘˜å‡½æ•° */ class AddSolution : public SolutionTask { private: /** å‡å¦‚ä½ æœ‰æ ‡ç¨‹ï¼Œä»…éœ€è¦å§ç¨‹åºç”¨è¿™ä¸ªç±»åŒ…è£…èµ·æ¥ï¼Œå†æŠŠ main() æ”¹ä¸ºè¿™ä¸ªæˆå‘˜å‡½æ•°å³å¯ */ void solve(std::istream \u0026amp;dataIn, std::ostream \u0026amp;dataOut, const DataConfig \u0026amp;) override { int a, b; /** åƒ cin ä¸€æ ·è¯»å…¥æ•°æ® */ dataIn \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; /** åƒ cout ä¸€æ ·è¾“å‡ºç­”æ¡ˆ */ dataOut \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; std::endl; } }; int main() { constexpr int MAX_THREAD_COUNT = 8; constexpr int MAX_TESTCASE_COUNT = 20; constexpr char PROBLEM_NAME[] = \u0026quot;add\u0026quot;; /** åˆ›å»ºä¸€ä¸ªé¢˜ç›®ç”Ÿæˆæ¨¡æ¿ï¼ŒæŒ‡å®šæ•°æ®æ–‡ä»¶åä¸º add#.in/add#.outï¼Œ# æ˜¯æµ‹è¯•ç‚¹ç¼–å·ï¼Œå¯ä»¥å«å­ä»»åŠ¡ç¼–å· */ MultiGenerator::NormalTemplate temp(PROBLEM_NAME); for (int i = 0; i \u0026lt; MAX_TESTCASE_COUNT; ++i) { /** æ·»åŠ æµ‹è¯•ç‚¹é…ç½®ï¼Œå¹¶æŒ‡å®šç”Ÿæˆå™¨å’Œæ±‚è§£å™¨ */ temp.add\u0026lt;AddGenerator, AddSolution\u0026gt;(testcase(i, { entry(\u0026quot;minValue\u0026quot;, i * 1000000), entry(\u0026quot;maxValue\u0026quot;, (i + 1) * 1000000) })); } /** å¼€å§‹æ ¹æ®æŒ‡å®šçš„çº¿ç¨‹æ•°ç”Ÿæˆæ•°æ® */ temp.execute(MAX_THREAD_COUNT); return 0; }  è¦æ±‚  C++ 17 Compiler C++ åŸºç¡€çŸ¥è¯†ï¼ŒåŒ…æ‹¬æœ€åŸºæœ¬çš„æ¨¡æ¿çš„ä½¿ç”¨ï¼ˆåŸºæœ¬éƒ½å¯ä»¥æ»¡è¶³ï¼‰ èƒ½å¤Ÿè®¤çœŸé˜…è¯»æ–‡æ¡£  å®‰è£… ç¼–è¯‘å™¨æ”¯æŒ é¦–å…ˆç¡®ä¿ä½ æœ‰æ”¯æŒ C++ 17 çš„ç¼–è¯‘å™¨ï¼Œå¦‚æœä½ å·²ç»æœ‰äº†ï¼Œå¯ä»¥è·³è¿‡è¿™ä¸€æ­¥ã€‚\nLinux ç»å¤§å¤šæ•°çš„ Linux å‘è¡Œç‰ˆé¢„è£…çš„ GCC ç‰ˆæœ¬éƒ½æ¯”è¾ƒä½ï¼Œä»…èƒ½æ”¯æŒ C++ 11ï¼Œå»ºè®®ä½¿ç”¨åŒ…ç®¡ç†å™¨è¿›è¡Œå®‰è£…æ›´æ–°ç‰ˆæœ¬çš„ GCCï¼Œè‡³å°‘ä¸º GCC 9ï¼Œå»ºè®® GCC 11ï¼Œè¿™é‡Œä»…åˆ—ä¸¾éƒ¨åˆ†å®‰è£…æ–¹æ³•ï¼Œå…·ä½“è¯·æŸ¥é˜…å‘è¡Œç‰ˆçš„åŒ…ç®¡ç†å™¨æ–‡æ¡£ã€‚\nDebian/Ubuntu/Deepin\n$ sudo apt install gcc-9 g++-9  Arch Linux/Manjaro\n$ sudo pacman -S gcc  CentOS/RHEL\n$ sudo yum -y install centos-release-scl $ yum -y install devtoolset-11-gcc devtoolset-11-gcc-c++ devtoolset-11-binutils echo \u0026quot;source /opt/rh/devtoolset-11/enable\u0026quot; \u0026gt;\u0026gt; /etc/profile  Windows æ¨èä½¿ç”¨ TDM-GCCï¼Œè¿›å…¥ä¸‹è½½é¡µé¢ https://jmeubank.github.io/tdm-gcc/download/ï¼Œé€‰æ‹© 64+32-bit çš„å®‰è£…åŒ…ï¼Œå®‰è£…å³å¯ã€‚\nmacOS ä¸€èˆ¬ macOS éƒ½å·²ç»è‡ªå¸¦ LLVM ç¯å¢ƒå’Œ Clangï¼Œå¦‚æœæ²¡æœ‰è¿˜å¯ä»¥é€šè¿‡å®‰è£… Xcode æ¥å®‰è£… g++ã€‚\nå®‰è£… MultiGenerator MultiGenerator æ˜¯ä¸€ä¸ª header-only åº“ï¼Œæ‰€ä»¥æ— éœ€ä»»ä½•ç¼–è¯‘å³å¯ä½¿ç”¨ï¼Œåªéœ€è¦å¤åˆ¶ https://github.com/ctj12461/MultiGenerator/tree/master/src ä¸‹çš„æ‰€æœ‰æ–‡ä»¶åˆ° include è·¯å¾„å³å¯ã€‚\nLinux $ git clone https://github.com/ctj12461/MultiGenerator.git $ sudo cp -r src/* /usr/local/include  å¦‚æœä½ æœ‰ xmakeï¼Œä¹Ÿå¯ä»¥æŒ‰ç…§å¦‚ä¸‹æ–¹å¼å®‰è£…ï¼š\n$ git clone https://github.com/ctj12461/MultiGenerator.git $ cd MultiGenerator $ sudo xmake install --root MultiGenerator  Windows/macOS å¤åˆ¶ https://github.com/ctj12461/MultiGenerator/tree/master/src ä¸‹çš„æ‰€æœ‰æ–‡ä»¶åˆ°ç¼–è¯‘å™¨æä¾›çš„ include è·¯å¾„ä¸‹ï¼Œå…·ä½“è¯·åœ¨ç¼–è¯‘å™¨å®‰è£…è·¯å¾„ä¸‹æœç´¢æˆ–æŸ¥çœ‹ç›¸å…³æ–‡æ¡£ã€‚ä¸€ä¸ªç®€å•çš„åŠæ³•æ˜¯æ‰¾åˆ° iostream çš„ä½ç½®ï¼Œç„¶åç²˜è´´åˆ°ç›¸åŒçš„ç›®å½•ä¸‹å³å¯ã€‚\nå¿«é€Ÿå…¥é—¨ å¯¼å…¥åº“ ä»…éœ€è¦ä½¿ç”¨ #include \u0026lt;MultiGenerator.hpp\u0026gt; å³å¯å¯¼å…¥æœ¬åº“ï¼Œåº“ä¸­æ‰€æœ‰çš„ç±»å’Œå‡½æ•°å…¨éƒ¨å®šä¹‰åœ¨ MultiGenerator å‘½åç©ºé—´ä¸‹ï¼Œå¯ä»¥é€šè¿‡ using namespace MultiGenerator æ¥æ›´åŠ æ–¹ä¾¿åœ°ä½¿ç”¨æœ¬åº“ï¼Œä½†æ˜¯æ›´æ¨èçš„æ–¹æ³•æ˜¯ä»…å¯¹æœ‰éœ€è¦çš„ç±»æˆ–å‡½æ•°ä½¿ç”¨ using å£°æ˜ã€‚\nä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼š\n#include \u0026lt;MultiGenerator.hpp\u0026gt; using MultiGenerator::DataConfig; using MultiGenerator::GeneratingTask; using MultiGenerator::SolutionTask; using MultiGenerator::NormalTemplate; using MultiGenerator::entry; using MultiGenerator::testcase; int main() { return 0; }  äº‹å®ä¸Š MultiGenerator å¯¹å†…éƒ¨å®ç°ç»†èŠ‚åšäº†è¾ƒå¤šçš„å°è£…ï¼Œå¦‚æœæœ‰ä½¿ç”¨ IDE çš„æ™ºèƒ½æç¤ºåŠŸèƒ½ï¼Œå¯èƒ½ä¼šå‘ç°æœ‰è‹¥å¹²å­å‘½åç©ºé—´ï¼Œå¦‚ MultiGenerator::Contextï¼ŒMultiGenerator::Interface ç­‰ç­‰ï¼Œåœ¨ç»å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæ‚¨éƒ½ä¸éœ€è¦ä½¿ç”¨è¿™äº›å†…éƒ¨çš„ç»„ä»¶ï¼Œåªéœ€ä½¿ç”¨å®šä¹‰åœ¨ MultiGenerator ä¸‹çš„éƒ¨åˆ†ï¼Œä¸‹æ–‡ä¹Ÿä»…ä¼šä»‹ç»è¿™ä¸€éƒ¨åˆ†ã€‚\nä»¥ä¸‹æ˜¯æœ¬é¡¹ç›®çš„ç›®å½•ç»“æ„ã€‚\nMultiGenerator/src â”œâ”€â”€ MultiGenerator â”‚Â â”œâ”€â”€ Context â”‚Â â”‚Â â”œâ”€â”€ Environment.hpp â”‚Â â”‚Â â””â”€â”€ Stream.hpp â”‚Â â”œâ”€â”€ Executor â”‚Â â”‚Â â”œâ”€â”€ Channel.hpp â”‚Â â”‚Â â”œâ”€â”€ TaskExecutor.hpp â”‚Â â”‚Â â””â”€â”€ ThreadPool.hpp â”‚Â â”œâ”€â”€ Interface â”‚Â â”‚Â â”œâ”€â”€ Component.hpp â”‚Â â”‚Â â”œâ”€â”€ Template.hpp â”‚Â â”‚Â â””â”€â”€ Utility.hpp â”‚Â â”œâ”€â”€ Variable â”‚Â â”‚Â â”œâ”€â”€ Argument.hpp â”‚Â â”‚Â â””â”€â”€ DataConfig.hpp â”‚Â â””â”€â”€ Workflow â”‚Â â”œâ”€â”€ Callable.hpp â”‚Â â”œâ”€â”€ Runner.hpp â”‚Â â”œâ”€â”€ TaskGroup.hpp â”‚Â â””â”€â”€ Task.hpp â””â”€â”€ MultiGenerator.hpp  åŸºæœ¬æ¦‚å¿µ Task åœ¨ MultiGenerator ä¸­ï¼Œç”Ÿæˆçš„è¿‡ç¨‹å¯ä»¥è¢«æ‹†åˆ†ä¸ºè‹¥å¹²ä¸ªéƒ¨åˆ†ï¼Œæ¯ä¸ªéƒ¨åˆ†æœ‰ä¸åŒçš„åŠŸèƒ½ï¼Œæ¯”å¦‚æ ¹æ®å‚æ•°ç”Ÿæˆæ•°æ®ï¼Œæˆ–è€…è¯»å…¥æ•°æ®å¹¶è¾“å‡ºæ­£ç¡®ç­”æ¡ˆã€‚è¿™æ ·çš„æ¯ä¸ªéƒ¨åˆ†è¢«æˆä¸º Taskã€‚\nMultiGenerator é¢„å®šä¹‰äº† 3 ç§ Taskï¼Œå®ƒä»¬æ˜¯æ›´åŠ å…·ä½“çš„ Taskï¼Œå¹¶è§„å®šäº†ç›¸å…³åŠŸèƒ½çš„æ¥å£ï¼Œä»¥ä¾¿ä½¿ç”¨ï¼š\n GeneratingTaskï¼šè¡¨ç¤ºæ‰€æœ‰ç”Ÿæˆæ•°æ®çš„ Task çš„æŠ½è±¡ç±»ï¼Œå¯ä»¥ç»§æ‰¿è¯¥æŠ½è±¡ç±»å¹¶å®ç°æ¥å£å‡½æ•°æ¥è·å¾—ç”Ÿæˆæ•°æ®çš„åŠŸèƒ½ã€‚ SolutionTaskï¼šè¡¨ç¤ºæ‰€æœ‰æ ¹æ®ç»™å®šæ•°æ®æ±‚è§£ç­”æ¡ˆçš„ Task çš„æŠ½è±¡ç±»ï¼Œå¯ä»¥ç»§æ‰¿è¯¥æŠ½è±¡ç±»å¹¶å®ç°æ¥å£å‡½æ•°æ¥è·å¾—æ±‚è§£ç­”æ¡ˆçš„åŠŸèƒ½ã€‚ä¸€èˆ¬ä½¿ç”¨æ‚¨çš„æ ‡å‡†ç¨‹åºå³ std æ¥å®ç°ã€‚ IntegratedGeneratingTaskï¼šè¡¨ç¤ºæ‰€æœ‰åŒæ—¶ç”Ÿæˆæ•°æ®å’Œæ±‚è§£ç­”æ¡ˆçš„ Task çš„æŠ½è±¡ç±»ï¼Œå¯ä»¥ç”¨äºå®ç°å¿…é¡»åŒæ—¶ç”Ÿæˆå’Œæ±‚è§£çš„ç”Ÿæˆå™¨ï¼Œæ¯”å¦‚ä¸€äº›å¼ºåˆ¶åœ¨çº¿é¢˜ç›®ã€‚  æ‚¨åªéœ€å®ç°è¿™äº›æŠ½è±¡ç±»çš„æ¥å£ï¼Œå¹¶é€šè¿‡ç»™å®šçš„æµè¿›è¡Œ IO æ“ä½œï¼Œæ— éœ€è€ƒè™‘æ–‡ä»¶ç³»ç»Ÿç›¸å…³çš„é—®é¢˜ï¼ŒMultiGenerator å¯ä»¥å¤„ç†å®ƒä»¬ã€‚\nTemplate Template è§„å®šäº†ä¸€é“é¢˜ç›®çš„ç”Ÿæˆç¨‹åºåº”è¯¥å¦‚ä½•è°ƒç”¨ Taskï¼Œæ¯”å¦‚æ™®é€šçš„é¢˜ç›®ï¼Œæ²¡æœ‰å¼ºåˆ¶åœ¨çº¿æ“ä½œï¼Œæ­¤æ—¶åªéœ€è¦åˆ†åˆ«ç”Ÿæˆæ•°æ®å’Œæ±‚è§£ç­”æ¡ˆï¼Œå°±å¯ä»¥ä½¿ç”¨ NormalTemplate æ¥ç®¡ç†è¿™äº› GeneratingTask å’Œ SolutionTaskã€‚\nMultiGenerator é¢„å®šä¹‰äº† 2 ç§ Templateï¼š\n NormalTemplateï¼šå¯ä»¥è°ƒç”¨å®ç°äº† GeneratingTask å’Œ SolutionTask çš„ç±»ï¼Œç”¨äºæ™®é€šçš„æ•°æ®ç”Ÿæˆï¼Œç”±äºç”Ÿæˆå’Œæ±‚è§£æ˜¯å¯åˆ†ç¦»çš„ï¼Œæ‰€ä»¥å¯ä»¥æ›´å¥½åœ°åˆ©ç”¨ç³»ç»Ÿèµ„æºè¿›è¡Œå¹¶è¡Œä¼˜åŒ–ã€‚ IntegratedTemplateï¼šå¯ä»¥è°ƒç”¨å®ç°äº† IntegratedGeneratingTask çš„ç±»ï¼Œå¯ä»¥ç”¨äºéœ€è¦å¼ºåˆ¶åœ¨çº¿çš„é¢˜ç›®çš„æ•°æ®ç”Ÿæˆã€‚  Template å¯ä»¥æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºé¢˜ç›®çš„åç§°ï¼Œæ‰€æœ‰ç”Ÿæˆçš„æ•°æ®éƒ½ä¼šè‡ªåŠ¨å¸¦ä¸Šè¯¥åç§°ã€‚ç„¶åæ‚¨å¯ä»¥å‘ Template æ·»åŠ æµ‹è¯•ç‚¹ä¿¡æ¯ï¼Œå¦‚è¦ä½¿ç”¨çš„ç”Ÿæˆå™¨ï¼ˆå®ç°äº† GeneratingTaskï¼‰å’Œæ±‚è§£å™¨ï¼ˆå®ç°äº† SolutionTaskï¼‰ï¼Œæµ‹è¯•ç‚¹ç¼–å·ï¼Œæµ‹è¯•ç‚¹çš„æ•°æ®è§„æ¨¡é…ç½®ç­‰ã€‚éšå Template ä¼šè‡ªåŠ¨å°†è¿™äº›å‚æ•°ä¼ ç»™ Taskï¼Œå®ç°æ•°æ®ç”Ÿæˆçš„å®šåˆ¶ã€‚\nå¦‚æœæ‚¨éœ€è¦å¯¹ä¸åŒçš„æµ‹è¯•ç‚¹åº”ç”¨ä¸åŒçš„ç”Ÿæˆå™¨ï¼Œæ¯”å¦‚åœ¨ä½¿ç”¨ NormalTemplate æ—¶ï¼Œéœ€è¦æ„é€ å…·æœ‰ç‰¹æ®Šæ€§è´¨çš„æ•°æ®ï¼Œæ‚¨å¯ä»¥å®šä¹‰å¤šä¸ªç”Ÿæˆå™¨ï¼Œåªè¦å®ƒä»¬å®ç°äº† GeneratingTaskï¼Œå°±å¯ä»¥è¢« Template è°ƒç”¨ï¼Œè€Œæ— éœ€åšä»»ä½•çš„ç‰¹æ®Šåˆ¤æ–­ã€‚\ntestcase testcase æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå¯ä»¥ç”¨äºç”Ÿæˆä¸€ä¸ªæµ‹è¯•ç‚¹çš„é…ç½®ï¼Œè¿™ä¸ªæµ‹è¯•ç‚¹å¯ä»¥æ˜¯ä¸€ä¸ªå­ä»»åŠ¡ä¸­çš„æµ‹è¯•ç‚¹ã€‚å®ƒè¿˜æ¥å—ä¸€ä¸ª std::unordered_map\u0026lt;std::string, std::string\u0026gt; ä½œä¸ºæµ‹è¯•ç‚¹é…ç½®ï¼Œè¿™é‡Œé€‰ç”¨ std::string ä½œä¸ºé”®å’Œå€¼æ˜¯å› ä¸ºè¿™æ ·å¯ä»¥æœ€ç®€å•çš„å®ç°é…ç½®ï¼Œå‡å¦‚æ‚¨éœ€è¦åŒæ—¶ä¼ å…¥ int å’Œ double çš„å€¼ä½œä¸ºé…ç½®ï¼Œstd::string å¯ä»¥å¾ˆå¥½åœ°å‚¨å­˜å®ƒä»¬ã€‚åé¢ä¼šè¯¦ç»†ä»‹ç»å¦‚ä½•ä½¿ç”¨è¯¥å‡½æ•°ã€‚\nDataConfig DataConfig å‚¨å­˜äº†æµ‹è¯•ç‚¹é…ç½®ä¿¡æ¯ï¼ˆä¸åŒ…æ‹¬æµ‹è¯•ç‚¹ç¼–å·ï¼Œäº‹å®ä¸Šå¾ˆå°‘æƒ…å†µä¼šéœ€è¦ç¼–å·ï¼Œå› ä¸º MultiGenerator ä¼šåœ¨å¤–éƒ¨è‡ªåŠ¨å¤„ç†æµ‹è¯•ç‚¹ç¼–å·ï¼Œæ— éœ€ Task å†…éƒ¨æ’æ‰‹ï¼‰ï¼Œtestcase å‡½æ•°æ‰€æ¥å—çš„ std::unordered_map\u0026lt;std::string, std::string\u0026gt; ä¹Ÿå°±æ˜¯æ„é€ å®ƒçš„å‚æ•°ã€‚\nDataConfig ä¸ä¼šè‡ªåŠ¨è½¬æ¢å€¼åˆ°æ‚¨æ‰€éœ€è¦çš„ç±»å‹ï¼Œå®ƒåªä¼šè¿”å›ä¸€ä¸ª std::stringï¼Œä½†æ˜¯è½¬æ¢ç±»å‹å¤§å¤šæ•°æƒ…å†µä¸‹åªéœ€è¦ä½¿ç”¨ std::stoi() æˆ– std::stof() å®Œæˆï¼Œæ›´åŠ é«˜çº§çš„ä¹Ÿä»…éœ€è¦ä½¿ç”¨ std::stringstream å³å¯ã€‚\nåˆ›å»º Task MultiGenerator æ‰€æä¾›çš„ Task å·²ç»æ‹¥æœ‰å¤§éƒ¨åˆ†åŠŸèƒ½ï¼Œå¦‚å¦‚ä½•å¤„ç†æ–‡ä»¶åï¼Œå¦‚ä½•ä¸æ–‡ä»¶ç³»ç»Ÿäº¤äº’ï¼Œä½†å®ƒå”¯ç‹¬ä¸çŸ¥é“å…·ä½“è¯¥å¦‚ä½•ç”Ÿæˆæ•°æ®ï¼Œæ‰€ä»¥æ‚¨åªéœ€è¦é€šè¿‡ç»§æ‰¿ç›¸å…³ Task æ¥å®ç°æ¥å£ï¼Œä»è€Œè¡¥ä¸Šç¼ºå¤±çš„ä¸€éƒ¨åˆ†åŠŸèƒ½ã€‚\nGeneratingTask å‰é¢æåˆ° GeneratingTask è¡¨ç¤ºæ‰€æœ‰ç”Ÿæˆæ•°æ®çš„ Taskï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¿™ä¹ˆå†™ï¼š\nclass MyGenerator : public GeneratingTask { /** è¿™é‡Œåªå¯ä»¥ä½¿ç”¨ private æˆ– protected */ private: /** å®ç°è¿™ä¸ªæ¥å£ */ void generate(std::ostream \u0026amp;data, const DataConfig \u0026amp;config) override { /** é€šè¿‡ DataConfig è·å–é…ç½®ï¼Œget å†…å¡«ä¸Šè‡ªå®šä¹‰çš„é”® */ int someValue = std::stoi(config.get(\u0026quot;some key\u0026quot;).value()); /** åœ¨è¿™é‡Œå®ç°ç”Ÿæˆæ•°æ® */ int someResult = someFunction(); /** è¾“å‡ºç»“æœ */ data \u0026lt;\u0026lt; someResult \u0026lt;\u0026lt; std::endl; } int sumeFunction() { return /* ... */; } };  å¦‚æœæ‚¨ä¸äº†è§£ C++ çš„é¢å‘å¯¹è±¡ç‰¹æ€§ï¼Œæ‚¨å¯æŸ¥é˜…ç›¸å…³èµ„æ–™ï¼Œæˆ–è€…ç›´æ¥å¤åˆ¶ä¸Šé¢çš„æ¨¡æ¿ï¼Œæ‚¨åªè¦ä¿ç•™ä¸Šè¿° generate(std::ostream \u0026amp;data, const DataConfig \u0026amp;config) æˆå‘˜å‡½æ•°å³å¯ã€‚\nSolutionTask class MySolution : public SolutionTask { private: void solve(std::istream \u0026amp;dataIn, std::ostream \u0026amp;dataOut, const DataConfig \u0026amp;) override { int someValue; /** åƒ std::cin ä¸€æ ·è¯»å…¥æ•°æ® */ dataIn \u0026gt;\u0026gt; someValue; int someResult = someFunction(); /** åƒ std::cout ä¸€æ ·è¾“å‡ºç­”æ¡ˆ */ dataOut \u0026lt;\u0026lt; someResult \u0026lt;\u0026lt; std::endl; } int sumeFunction() { return /* ... */; } };  è¿˜æ˜¯åŒæ ·çš„é“ç†ï¼Œæ‚¨åªéœ€è¦ä¿ç•™ void solve(std::istream \u0026amp;dataIn, std::ostream \u0026amp;dataOut, const DataConfig \u0026amp;config) æˆå‘˜å‡½æ•°ï¼Œå¹¶åœ¨å…¶ä¸­å¡«ä¸Šè‡ªå·±çš„ä¸œè¥¿å³å¯ã€‚\nç†è®ºä¸Šæ‚¨å¯ä»¥ç›´æ¥å°† std çš„ä¸œè¥¿å¤åˆ¶è¿› MySolution è¿™ä¸ªç±»ï¼Œå¹¶æŠŠ main() å‡½æ•°æ”¹ä¸ºè¿™ä¸ªæˆå‘˜å‡½æ•°ï¼Œç„¶ååšå¥½åˆå§‹åŒ–å·¥ä½œï¼Œå› ä¸ºæ‰€æœ‰çš„ Task éƒ½æ˜¯è¦åœ¨å †ä¸Šåˆ†é…å†…å­˜ç„¶åè¿è¡Œçš„ï¼Œæ‰€ä»¥ä¸èƒ½å¤Ÿä¿è¯æ‰€æœ‰æ•°æ®éƒ½å’Œå…¨å±€å˜é‡ä¸€æ ·è¢«åˆå§‹åŒ–ä¸º 0ã€‚å¯¹äºæ•°ç»„ï¼Œå¯ä»¥å°†å…¶æ›¿æ¢ä¸º std::arrayï¼Œå®ƒä¼šé»˜è®¤åˆå§‹åŒ–æ‰€æœ‰çš„å…ƒç´ ä¸º 0ï¼Œä¸”åœ¨ä½¿ç”¨ä¸Šå’ŒåŸç”Ÿæ•°ç»„æ²¡æœ‰ä»»ä½•å·®åˆ«ï¼ŒåŒ…æ‹¬æ€§èƒ½å¼€é”€ã€‚\nIntegratedGeneratingTask å¦‚æœæ‚¨éœ€è¦åŒæ—¶ç”Ÿæˆå’Œæ±‚è§£ï¼Œé‚£ IntegratedGeneratingTask ä¼šæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é€‰æ‹©ï¼Œå®ƒåŒæ—¶æä¾›äº†ä¸¤ä¸ªè¾“å‡ºæµï¼Œåˆ†åˆ«è¿æ¥äº†æ•°æ®çš„æ–‡ä»¶ï¼ˆ*.inï¼‰å’Œç­”æ¡ˆçš„æ–‡ä»¶ï¼ˆ*.outï¼‰ã€‚\nclass MyIntegratedGenerator : public IntegratedGeneratingTask { private: void generate(std::ostream \u0026amp;dataIn, std::ostream \u0026amp;dataOut, const DataConfig \u0026amp;config) override { while (/* æ¡ä»¶ */) { auto someData = /* ... */; auto someAnswer = /* ... */; dataIn \u0026lt;\u0026lt; someData \u0026lt;\u0026lt; std::endl; dataOut \u0026lt;\u0026lt; someAnswer \u0026lt;\u0026lt; std::endl; } } };  IntegratedGeneratingTask ä¸€èˆ¬ç”¨äºä¸ºå¼ºåˆ¶åœ¨çº¿é¢˜ç›®æˆ–ä¸€äº›å¤æ‚çš„æ•°æ®ç»“æ„é¢˜ç›®ç”Ÿæˆæ•°æ®ã€‚\nä½¿ç”¨ testcase åˆ›å»ºæµ‹è¯•ç‚¹é…ç½® testcase å‡½æ•°å¯ä»¥ç”¨äºåˆ›å»ºæµ‹è¯•ç‚¹çš„é…ç½®ï¼Œå…¶æœ‰ä¸¤ä¸ªé‡è½½ï¼š\nstd::shared_ptr\u0026lt;Variable::Argument\u0026gt; testcase(int id, const std::unordered_map\u0026lt;std::string, std::string\u0026gt; \u0026amp;config); std::shared_ptr\u0026lt;Variable::Argument\u0026gt; testcase(int subtaskId, int id, const std::unordered_map\u0026lt;std::string, std::string\u0026gt; \u0026amp;config)  è¿™ä¸¤ä¸ªå‡½æ•°éƒ½è¿”å› Variable::Argument çš„æ™ºèƒ½æŒ‡é’ˆï¼Œå…¶å‚¨å­˜ç€æµ‹è¯•ç‚¹çš„é…ç½®å‚æ•°ã€‚ä»å‡½æ•°ç­¾åå¯ä»¥å¾ˆå®¹æ˜“åœ°çœ‹å‡ºç¬¬ä¸€ä¸ªæ˜¯ç”¨äºåˆ›å»ºæ— å­ä»»åŠ¡çš„æµ‹è¯•ç‚¹ï¼Œè€Œç¬¬äºŒä¸ªæ˜¯åˆ›å»ºæœ‰å­ä»»åŠ¡çš„æµ‹è¯•ç‚¹ã€‚\nè¿™ä¸¤ä¸ªå‡½æ•°éƒ½åœ¨æœ€åæ¥å—ä¸€ä¸ª std::unordered_map\u0026lt;std::string, std::string\u0026gt; ä½œä¸ºæµ‹è¯•ç‚¹é…ç½®ï¼Œä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨å¯ä»¥å¾ˆæ–¹ä¾¿åœ°ä¼ å…¥è¿™ä¸ªå‚æ•°ã€‚æ‚¨è¿˜å¯ä»¥ä½¿ç”¨ entry å‡½æ•°åˆ›å»ºä¸€ä¸ªé”®å€¼å¯¹ï¼Œä½¿ä»£ç æ›´åŠ ç®€å•æ˜“è¯»ï¼š\ntemplate \u0026lt;typename Value\u0026gt; std::pair\u0026lt;std::string, std::string\u0026gt; entry(const std::string \u0026amp;key, const Value \u0026amp;value);  ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œåªéœ€è¦å°†è¿”å›çš„ Variable::Argument æŒ‡é’ˆå†ä¼ ç»™ Template å³å¯ï¼Œæ— éœ€åšé¢å¤–çš„å·¥ä½œã€‚\nå¦‚æœè¦åˆ›å»ºç¼–å·ä¸º 2ï¼Œå¸¦æœ‰ n = 10 ä¸” m = 5 çš„é…ç½®ï¼Œå¯ä»¥è¿™æ ·è·å¾—é…ç½®å‚æ•°ï¼š\nauto arg = testcase(2, { entry(\u0026quot;n\u0026quot;, 10), entry(\u0026quot;m\u0026quot;, 5) });  å¦‚æœè¦åˆ›å»ºå­ä»»åŠ¡ç¼–å·ä¸º 1ï¼Œå­ä»»åŠ¡å†…çš„ç¼–å·ä¸º 5ï¼Œå¸¦æœ‰ str = \u0026quot;abc\u0026quot; ä¸” n = 1 çš„é…ç½®ï¼Œå¯ä»¥è¿™æ ·è·å¾—é…ç½®å‚æ•°ï¼š\nauto arg = testcase(1, 5, { entry(\u0026quot;str\u0026quot;, \u0026quot;abc\u0026quot;), entry(\u0026quot;n\u0026quot;, 1) });  æŠŠ Task ä¼ ç»™ Template å¦‚ä¸Šæ–‡æ‰€è¿°ï¼ŒTemplate è§„å®šäº†ä¸€é“é¢˜ç›®çš„ç”Ÿæˆç¨‹åºåº”è¯¥å¦‚ä½•è°ƒç”¨ Taskï¼Œä¸” MultiGenerator å®šä¹‰äº† NormalTemplate å’Œ IntegratedTemplateï¼Œä¸¤ç§ Template ä½¿ç”¨æ–¹æ³•æ˜¯ä¸€æ ·çš„ï¼Œä»¥ä¸‹ä»¥ NormalTemplate ä¸ºä¾‹ã€‚\næ„é€  NormalTemplate éœ€è¦ä¼ å…¥ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºé¢˜ç›®çš„åå­—ã€‚\nNormalTemplate temp(\u0026quot;problem\u0026quot;);  éšåå¯ä»¥ä½¿ç”¨ add æˆå‘˜å‡½æ•°åˆ›å»ºæµ‹è¯•ç‚¹é…ç½®ï¼Œç­¾åå¦‚ä¸‹ï¼š\ntemplate \u0026lt;typename Generator, typename Solution\u0026gt; void NormalTemplate::add(std::shared_ptr\u0026lt;Variable::Argument\u0026gt; arg);  å…¶ä¸­ Generator æ˜¯ç”¨æˆ·è‡ªå®šä¹‰çš„å®ç°äº† GeneratingTask çš„ç±»ï¼Œæ¯”å¦‚ä¸Šæ–‡ç¤ºä¾‹ä¸­çš„ MyGeneratorï¼ŒSolution åˆ™æ˜¯å®ç°äº† SolutionTask çš„ç±»ï¼Œæ¯”å¦‚ä¸Šæ–‡ç¤ºä¾‹ä¸­çš„ MySolutionã€‚\nIntegratedTemplate çš„ add å‡½æ•°ç­¾åå¦‚ä¸‹ï¼š\ntemplate \u0026lt;typename IntegratedGenerator\u0026gt; void IntegratedTemplate::add(std::shared_ptr\u0026lt;Variable::Argument\u0026gt; arg);  å…¶ä¸­ IntegratedGenerator æ˜¯ç”¨æˆ·è‡ªå®šä¹‰çš„å®ç°äº† IntegratedGeneratingTask çš„ç±»ï¼Œæ¯”å¦‚ä¸Šæ–‡ç¤ºä¾‹ä¸­çš„ MyIntegratedGeneratorã€‚\næ‚¨éœ€è¦æŠŠ testcase å‡½æ•°è¿”å›çš„ç»“æœä¼ ç»™è¿™äº›å‡½æ•°ï¼š\ntemp.add\u0026lt;MyGenerator, MySolution\u0026gt;(testcase(1, {}));  è¿™æ · NormalTemplate å°±ä¼šçŸ¥é“è¦å¯¹ç¬¬ 1 ä¸ªæµ‹è¯•ç‚¹åº”ç”¨ MyGenerator ç”Ÿæˆæ•°æ®ï¼Œç”¨ MySolution æ±‚è§£ç­”æ¡ˆï¼Œå¹¶ä¸”ç”Ÿæˆçš„æ–‡ä»¶ä¸º problem1.in å’Œ problem1.outã€‚\nå¯ä»¥ç»§ç»­ä½¿ç”¨ add å‡½æ•°æ·»åŠ æµ‹è¯•ç‚¹ï¼Œä½¿ç”¨æ–¹æ³•æ˜¯ä¸€æ ·çš„ï¼Œåªéœ€ä¿®æ”¹ testcase å‡½æ•°ä¸­çš„æµ‹è¯•ç‚¹ç¼–å·å³å¯ã€‚æ³¨æ„å¦‚æœæµ‹è¯•ç‚¹ç¼–å·å‡ºç°é‡å¤ï¼Œå¯èƒ½ä¼šå¯¼è‡´ç¨‹åºå´©æºƒã€‚\nå¼€å§‹ç”Ÿæˆæ•°æ® è¿™ä¸€éƒ¨åˆ†å¾ˆç®€å•ï¼Œåªéœ€è¦æŒ‡å®šå¹¶è¡Œä»»åŠ¡æ•°å³å¯ï¼š\ntemp.execute(8);  ä¸€èˆ¬å¹¶è¡Œä»»åŠ¡æ•°ä¼šè®¾å®šä¸ºæ‚¨çš„ CPU æ ¸å¿ƒæ•°æˆ–è€…çº¿ç¨‹æ•°ã€‚å¦‚æœæ‚¨ä¸çŸ¥é“æ‚¨çš„ CPU æ ¸å¿ƒæ•°ï¼Œå¯ä»¥ä½¿ç”¨ std:ğŸ§µ:hardware_concurrency å‡½æ•°æŸ¥è¯¢ï¼š\ntemp.execute(std:ğŸ§µ:hardware_concurrency());  å®Œæ•´ç¤ºä¾‹ æœ€ä¸Šé¢çš„ç¤ºä¾‹å°±æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­ï¼Œå‚è€ƒé‚£ä¸ªå³å¯ã€‚\n","id":0,"section":"posts","summary":"æ¦‚è¿° MultiGenerator æ˜¯ä¸€ä¸ªä¸º OI è€Œç”Ÿçš„å¤šçº¿ç¨‹å¹¶è¡Œæ•°æ®ç”Ÿæˆåº“ï¼ŒåŸºäº C++ 17ï¼Œä½¿ç”¨é¢å‘å¯¹è±¡å’Œæ³›å‹ç­‰ Morden C++ é«˜çº§ç‰¹æ€§ï¼Œåªéœ€è¦æ·»åŠ æœ€å°‘çš„é¢å¤–ä»£ç ï¼Œå°±å¯ä»¥è·å¾—æœ€é«˜çš„æ€§èƒ½ã€‚ä»¥","tags":["C++","OI","å¤šçº¿ç¨‹","MultiGenerator","é¡¹ç›®"],"title":"MultiGenerator ä½¿ç”¨æ–‡æ¡£","uri":"https://ctj12461.vercel.app/contents/20220404-multigenerator-document/","year":"2022"},{"content":"std::function å’Œ std::bind æ˜¯ C++ ä¸­éå¸¸å¸¸ç”¨çš„ä¸¤ä¸ªå·¥å…·ï¼Œç„¶è€Œè¦æ­£ç¡®ä½¿ç”¨è¿™ä¸¤ä¸ªå·¥å…·è¿˜è¦æ›´æ·±å…¥çš„ç†è§£ã€‚\næœ€è¿‘å†™é¡¹ç›®æ—¶é‡åˆ°éœ€è¦å°†ä¸å¯å¤åˆ¶æ„é€ çš„å¯¹è±¡ä¼ ç»™ std::bind çš„æƒ…å†µï¼Œç»“æœé‡åˆ°äº†ç¼–è¯‘é”™è¯¯ã€‚ä»£ç é€»è¾‘å¯ä»¥æŠ½è±¡ä¸ºä¸‹é¢è¿™æ ·ï¼š\n#include \u0026lt;functional\u0026gt; class Class { public: Class() {} Class(const Class \u0026amp;) = delete; Class \u0026amp;operator=(const Class \u0026amp;) = delete; Class(Class \u0026amp;\u0026amp;) = default; Class \u0026amp;operator=(Class \u0026amp;\u0026amp;) = default; }; void call(std::function\u0026lt;void()\u0026gt; func) { func(); } int main() { auto func = std::bind([](Class \u0026amp;) { /* code */ }, Class()); call(std::move(func)); return 0; }  è¿™ä¸ªé”™è¯¯ Language Server æ˜¯æ£€æµ‹ä¸åˆ°çš„ï¼Œåªæœ‰åœ¨ç¼–è¯‘åæ‰èƒ½å‘ç°ã€‚ç¼–è¯‘é”™è¯¯ä¿¡æ¯å¦‚ä¸‹ï¼š\nIn file included from project.cpp:1: In file included from /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/functional:59: /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/bits/std_function.h:159:10: error: call to implicitly-deleted copy constructor of 'std::_Bind\u0026lt;(lambda at project.cpp:19:27) (Class)\u0026gt;' new _Functor(*__source._M_access\u0026lt;const _Functor*\u0026gt;()); ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/bits/std_function.h:196:8: note: in instantiation of member function 'std::_Function_base::_Base_manager\u0026lt;std::_Bind\u0026lt;(lambda at project.cpp:19:27) (Class)\u0026gt;\u0026gt;::_M_clone' requested here _M_clone(__dest, __source, _Local_storage()); ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/bits/std_function.h:283:13: note: in instantiation of member function 'std::_Function_base::_Base_manager\u0026lt;std::_Bind\u0026lt;(lambda at project.cpp:19:27) (Class)\u0026gt;\u0026gt;::_M_manager' requested here _Base::_M_manager(__dest, __source, __op); ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/bits/std_function.h:423:35: note: in instantiation of member function 'std::_Function_handler\u0026lt;void (), std::_Bind\u0026lt;(lambda at project.cpp:19:27) (Class)\u0026gt;\u0026gt;::_M_manager' requested here _M_manager = \u0026amp;_My_handler::_M_manager; ^ project.cpp:20:10: note: in instantiation of function template specialization 'std::function\u0026lt;void ()\u0026gt;::function\u0026lt;std::_Bind\u0026lt;(lambda at project.cpp:19:27) (Class)\u0026gt;, void, void\u0026gt;' requested here call(std::move(func)); ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/functional:493:7: note: explicitly defaulted function was implicitly deleted here _Bind(const _Bind\u0026amp;) = default; ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/functional:412:29: note: copy constructor of '_Bind\u0026lt;(lambda at project.cpp:19:27) (Class)\u0026gt;' is implicitly deleted because field '_M_bound_args' has a deleted copy constructor tuple\u0026lt;_Bound_args...\u0026gt; _M_bound_args; ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:744:17: note: explicitly defaulted function was implicitly deleted here constexpr tuple(const tuple\u0026amp;) = default; ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:599:19: note: copy constructor of 'tuple\u0026lt;Class\u0026gt;' is implicitly deleted because base class '_Tuple_impl\u0026lt;0, Class\u0026gt;' has a deleted copy constructor class tuple : public _Tuple_impl\u0026lt;0, _Elements...\u0026gt; ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:435:17: note: explicitly defaulted function was implicitly deleted here constexpr _Tuple_impl(const _Tuple_impl\u0026amp;) = default; ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:408:7: note: copy constructor of '_Tuple_impl\u0026lt;0, Class\u0026gt;' is implicitly deleted because base class '_Head_base\u0026lt;0UL, Class\u0026gt;' has a deleted copy constructor : private _Head_base\u0026lt;_Idx, _Head\u0026gt; ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:86:17: note: explicitly defaulted function was implicitly deleted here constexpr _Head_base(const _Head_base\u0026amp;) = default; ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:125:39: note: copy constructor of '_Head_base\u0026lt;0, Class, true\u0026gt;' is implicitly deleted because field '_M_head_impl' has a deleted copy constructor [[__no_unique_address__]] _Head _M_head_impl; ^ project.cpp:7:5: note: 'Class' has been explicitly marked deleted here Class(const Class \u0026amp;) = delete; ^ 1 error generated.  è¿™ä¸ªç¼–è¯‘ä¿¡æ¯å…·æœ‰ä¸€å®šçš„è¯¯å¯¼æ€§ï¼Œæœ‰å¯èƒ½é¦–å…ˆä¼šæƒ³åˆ°çš„æ˜¯ std::bind ç”Ÿæˆçš„å‡½æ•°å¯¹è±¡ä¸æ”¯æŒå¤åˆ¶æ„é€ å’Œç§»åŠ¨æ„é€ ï¼Œä½†å®é™…ä¸ŠæŸ¥çœ‹æºç åå‘ç°ï¼Œstd::bind è¿”å›ä¸€ä¸ª _Bind\u0026lt;_Signature\u0026gt; ç±»ï¼Œå…¶ä¸­ä¸€ä¸ªç‰¹åŒ–ä¸ºï¼š\ntemplate \u0026lt;typename _Functor, typename... _Bound_args\u0026gt; class _Bind\u0026lt;_Functor(_Bound_args...)\u0026gt; : public _Weak_result_type\u0026lt;_Functor\u0026gt; { _Functor _M_f; tuple\u0026lt;_Bound_args...\u0026gt; _M_bound_args; // ... };  å…¶ä¸­ _M_f åœ¨è¿™é‡Œæ˜¯ç¼–è¯‘å™¨å°† lambda è¡¨è¾¾å¼è½¬æ¢åçš„å‡½æ•°å¯¹è±¡ï¼Œå¤åˆ¶æ„é€ å’Œç§»åŠ¨æ„é€ éƒ½å¯ä»¥æ”¯æŒï¼Œ_M_bound_args åˆ™æ˜¯ç»‘å®šçš„å‚æ•°ï¼Œä½¿ç”¨ std::tuple å®ç°ï¼Œå…¶å¤åˆ¶æ„é€ å‡½æ•°å’Œç§»åŠ¨æ„é€ å‡½æ•°å‡ä¸º = defaultï¼Œæ‰€ä»¥è‡³å°‘ç§»åŠ¨æ„é€ å‡½æ•°ä¹Ÿæ˜¯å¯ç”¨çš„ï¼Œä¹Ÿå°±æ˜¯ std::bind è¿”å›çš„è¿™ä¸ªå‡½æ•°å¯¹è±¡ _Bind\u0026lt;_Signature\u0026gt; ä¹Ÿæ˜¯å¯ä»¥ç§»åŠ¨æ„é€ çš„ï¼Œå› æ­¤ std::move(func) æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚\næ‰€ä»¥é—®é¢˜å‡ºåœ¨ std::function ä¸Šï¼Œå†æŸ¥çœ‹ std::function çš„æºç ï¼Œæ‰¾åˆ°å…¶æ„é€ å‡½æ•°å¯¹å…¶ä»–å‡½æ•°å¯¹è±¡çš„é‡è½½ï¼š\ntemplate \u0026lt;typename _Functor, typename = /* ... */, typename = /* ... */\u0026gt; function(_Functor __f) : _Function_base() { typedef _Function_handler\u0026lt;_Res(_ArgTypes...), _Functor\u0026gt; _My_handler; if (_My_handler::_M_not_empty_function(__f)) { _My_handler::_M_init_functor(_M_functor, std::move(__f)); _M_invoker = \u0026amp;_My_handler::_M_invoke; _M_manager = \u0026amp;_My_handler::_M_manager; } }  å¦‚æœ std::function æ¥å—äº†ä¸€ä¸ªå‡½æ•°å¯¹è±¡ï¼Œé‚£ä¹ˆå°±ä¼šä½¿ç”¨ _My_handler::_M_init_functor(_M_functor, std::move(__f)) å°†è¯¥å‡½æ•°å¯¹è±¡å¤åˆ¶åˆ°è‡ªèº«å†…éƒ¨çš„ _M_functor æˆå‘˜ä¸Šï¼Œè€Œè¿™ä¸ªå‡½æ•°æœ€ç»ˆä¼šè°ƒç”¨ä»¥ä¸‹ä¸¤ä¸ªå‡½æ•°ä¹‹ä¸€ï¼š\nstatic void _M_init_functor(_Any_data \u0026amp;__functor, _Functor \u0026amp;\u0026amp;__f, true_type) { ::new (__functor._M_access()) _Functor(std::move(__f)); } static void _M_init_functor(_Any_data \u0026amp;__functor, _Functor \u0026amp;\u0026amp;__f, false_type) { __functor._M_access\u0026lt;_Functor *\u0026gt;() = new _Functor(std::move(__f)); }  äº‹å®ä¸Šä¹Ÿåªä¼šè°ƒç”¨ä»¥ä¸Šè¿™å‡ ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªè¿‡ç¨‹ä¹Ÿéƒ½æ˜¯ç§»åŠ¨æ„é€ ï¼Œç†è®ºä¸Šå³ä½¿åˆ é™¤äº†å¤åˆ¶æ„é€ å‡½æ•°ä¹Ÿæ˜¯å¯ä»¥æ­£å¸¸å·¥ä½œçš„ï¼Œå…¶å®é—®é¢˜å‡ºåœ¨å…¶ä»–å‡½æ•°ä½¿ç”¨äº†å¤åˆ¶ï¼Œæ¯”å¦‚ä¸‹é¢è¿™å¯¹ï¼š\nstatic void _M_clone(_Any_data \u0026amp;__dest, const _Any_data \u0026amp;__source, true_type) { ::new (__dest._M_access()) _Functor(__source._M_access\u0026lt;_Functor\u0026gt;()); } static void _M_clone(_Any_data \u0026amp;__dest, const _Any_data \u0026amp;__source, false_type) { __dest._M_access\u0026lt;_Functor *\u0026gt;() = new _Functor(*__source._M_access\u0026lt;const _Functor *\u0026gt;()); }  è¿™é‡Œ __source._M_access\u0026lt;_Functor\u0026gt;() æ˜¾ç„¶ä¸æ˜¯å³å€¼ï¼Œåªèƒ½è°ƒç”¨å¤åˆ¶æ„é€ å‡½æ•°ã€‚è€Œæ¨¡æ¿å®ä¾‹åŒ–æ˜¯å…¨éƒ¨çš„ï¼Œä¸æ˜¯åªå¯¹æœ‰ä½¿ç”¨åˆ°çš„ä»£ç è¿›è¡Œå¤„ç†ã€‚ç»“è®ºå°±æ˜¯ä¸å¯ä»¥ç”¨ std::function ä¿å­˜ä¸å¯å¤åˆ¶æ„é€ çš„å‡½æ•°å¯¹è±¡ï¼ŒåŒ…æ‹¬è¿™ç§ std::bindï¼Œå› æ­¤è§£å†³æ–¹æ¡ˆä¹Ÿå°±æ˜¯ä¸ä½¿ç”¨ std::functionã€‚ç„¶è€Œè¿™æ ·å°±ä¸å®¹æ˜“å¯¹å‡½æ•°ç­¾åè¿›è¡Œé™åˆ¶ï¼Œæ¯”å¦‚ä¸‹é¢çš„è¿™ç§æ–¹æ³•ï¼š\n#include \u0026lt;functional\u0026gt; class Class { public: Class() {} Class(const Class \u0026amp;) = delete; Class \u0026amp;operator=(const Class \u0026amp;) = delete; Class(Class \u0026amp;\u0026amp;) = default; Class \u0026amp;operator=(Class \u0026amp;\u0026amp;) = default; }; template \u0026lt;typename Functor\u0026gt; void call(Functor func) { func(); } int main() { auto func = std::bind([](Class \u0026amp;) { /* code */ }, Class()); call(std::move(func)); return 0; }  ","id":1,"section":"posts","summary":"std::function å’Œ std::bind æ˜¯ C++ ä¸­éå¸¸å¸¸ç”¨çš„ä¸¤ä¸ªå·¥å…·ï¼Œç„¶è€Œè¦æ­£ç¡®ä½¿ç”¨è¿™ä¸¤ä¸ªå·¥å…·è¿˜è¦æ›´æ·±å…¥çš„ç†è§£ã€‚ æœ€è¿‘å†™é¡¹ç›®æ—¶é‡åˆ°éœ€è¦å°†ä¸å¯å¤åˆ¶æ„é€ çš„å¯¹è±¡ä¼ ç»™ std::bind çš„æƒ…å†µï¼Œç»“æœé‡åˆ°äº†ç¼–","tags":["C++","æ ‡å‡†åº“","å‡½æ•°å¯¹è±¡","æŠ€æœ¯"],"title":"std::function å’Œ std::bind çš„ä½¿ç”¨é™·é˜±","uri":"https://ctj12461.vercel.app/contents/20220329-traps-of-std-function-and-std-bind/","year":"2022"},{"content":"è®°å½•ä¸€ä¸‹å®‰è£… Arch Linux åçš„å¸¸ç”¨è½¯ä»¶å®‰è£…ä»¥åŠé…ç½®ã€‚\nyay ä½¿ç”¨ yay ä» AUR ä¸Šä¸‹è½½å„ç§å®˜æ–¹ä»“åº“æ‰€æ²¡æœ‰çš„åŒ…ã€‚\né¡¹ç›®ä¸»é¡µï¼šhttps://github.com/Jguer/yayã€‚\nä»æºç å®‰è£…ï¼š\n$ pacman -S --needed git base-devel $ git clone https://aur.archlinux.org/yay.git $ cd yay $ makepkg -si  æˆ–è€…ä¸‹è½½äºŒè¿›åˆ¶åŒ…ï¼š\n$ pacman -S --needed git base-devel $ git clone https://aur.archlinux.org/yay-bin.git $ cd yay-bin $ makepkg -si  ç”¨æ³•ä¸ pacman ä¸€è‡´ã€‚\ndebtap debtap æ˜¯ AUR åŒ…ï¼Œç”¨äºå°† deb åŒ…è½¬æ¢ä¸º pacman å¯ä»¥ä½¿ç”¨çš„åŒ…ã€‚\nå®‰è£…ï¼š\n$ yay -S debtap  å®‰è£…åå¯ä»¥ç¼–è¾‘ /usr/bin/debtapï¼Œæ›¿æ¢æ‰€æœ‰çš„ http://ftp.debian.org/debian/dists ä¸º https://mirrors.ustc.edu.cn/debian/distsï¼Œæ›¿æ¢æ‰€æœ‰çš„ http://archive.ubuntu.com/ubuntu/dists ä¸º https://mirrors.ustc.edu.cn/ubuntu/dists/ã€‚\nä½¿ç”¨ï¼š\n$ sudo debtap -u # æ›´æ–°æºåˆ—è¡¨ $ debtap -q package.deb # è½¬æ¢ deb åŒ…ï¼Œ-q è¡¨ç¤ºä¸è¦ç¼–è¾‘é™¤å…ƒæ•°æ®ä¹‹å¤–çš„ä¿¡æ¯ $ sudo pacman -U package.tar.xz # å®‰è£…ç”Ÿæˆçš„åŒ…  clementine ä¸€ä¸ªè·¨å¹³å°çš„éŸ³ä¹æ’­æ”¾å™¨ï¼Œä¸ä»…å¯ä»¥æ’­æ”¾å„ç§æ ¼å¼çš„éŸ³ä¹ï¼Œè¿˜æ”¯æŒæå–æ­Œæ›²çš„å…ƒä¿¡æ¯ã€‚\nå®‰è£…ï¼š\n$ sudo pacman -S clementine $ sudo pacman -S gst-plugins-good gst-plugins-base \\ gst-libav gst-plugins-bad gst-plugins-ugly  ç”±äº clementine ä½¿ç”¨äº† GStreamerï¼Œæ‰€ä»¥è¿˜è¦å®‰è£…å¿…è¦çš„æ’ä»¶ï¼Œå¦åˆ™æ— æ³•æ’­æ”¾éŸ³ä¹ã€‚\nwireshark åŸºäº Qt ç¼–å†™çš„å¼€æºæŠ“åŒ…å·¥å…·ã€‚\nå¯ä»¥ç¼–è¯‘æºç ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ç”¨ pacman å®‰è£…ï¼š\n$ sudo pacman -S wireshark  é»˜è®¤æƒ…å†µä¸‹åªèƒ½ä½¿ç”¨ root ç”¨æˆ·è¿è¡Œæ‰å¯ä»¥è®¿é—®ç½‘å¡ç­‰è®¾å¤‡ï¼Œé€šè¿‡ä¿®æ”¹ç”¨æˆ·ç»„è®¾ç½®ä½¿å¾—å¸¸ç”¨ç”¨æˆ·å¯ä»¥ç›´æ¥ä½¿ç”¨ï¼š\n$ sudo groupadd wireshark # æ–°å»ºä¸€ä¸ªä¸“ç”¨çš„ç”¨æˆ·ç»„ $ sudo chgrp wireshark /usr/bin/dumpcap # å°†dumpcapæ›´æ”¹ä¸ºwiresharkç”¨æˆ·ç»„ $ sudo chmod 4755 /usr/bin/dumpcap # 4 è¡¨ç¤ºæ‰§è¡Œæ—¶ç”¨æˆ·å¯ä»¥ä¸æ‰€æœ‰è€…æœ‰ç›¸åŒæƒé™ $ sudo gpasswd -a ctj12461 wireshark # æ·»åŠ è‡ªå·±  é™„ wireshark è¿‡æ»¤å‡ºéŸ³ä¹çš„ HTTP request çš„ patternï¼š\n(tcp.port == 80 || udp.port == 80) \u0026amp;\u0026amp; (http.request.uri contains \u0026quot;mp3\u0026quot; || http.request.uri contains \u0026quot;m4a\u0026quot; || http.request.uri contains \u0026quot;mp4\u0026quot; || http.request.uri contains \u0026quot;flac\u0026quot; || http.request.uri contains \u0026quot;ogg\u0026quot;)  VS Code å¦‚æœç›´æ¥ç”¨åŒ…ç®¡ç†å™¨å®‰è£… codeï¼Œåˆ™ä¼šå®‰è£… Code - OSSï¼Œè¿™ä¸ªè™½ç„¶ä¹Ÿæ˜¯ VS Codeï¼Œä½†åœ¨åè®®ä¸Šä¸ Microsoft æä¾›çš„ Visual Studio Code ä¸åŒï¼Œæ‰€ä»¥æ‰€å¸¦æœ‰çš„å†…å®¹ä¹Ÿæœ‰æ‰€å·®åˆ«ï¼Œæ¯”å¦‚æ— æ³•ç™»é™† Microsoft å¸å·ï¼Œæ— æ³•åŒæ­¥è®¾ç½®ç­‰ã€‚\nå¦‚æœæœ‰éœ€è¦ï¼Œå¯ä»¥ç”¨ yay å®‰è£… visual-studio-code-binï¼š\n$ yay -S visual-studio-code-bin  ä¹Ÿæ˜¯ç›´æ¥è¾“å…¥ code è¿è¡Œã€‚\nWPS 2019 for Linux ç›®å‰ WPS å¯¹ Microsoft Office çš„æ”¯æŒæ˜¯æœ€å¥½çš„ï¼Œè€Œä¸”è¿˜åœ¨ç¨³å®šæ›´æ–°ï¼Œæ¨èä½¿ç”¨ã€‚\nä½¿ç”¨ yay å®‰è£…ï¼Œå¹¶ä¸”è¦å®‰è£…å¯é€‰çš„ä¾èµ–åŒ…ï¼š\n$ yay -S wps-office-cn wps-office-mime-cn wps-office-mui-zh-cn # å®‰è£…ä¸­æ–‡ç¯å¢ƒçš„ WPS $ yay -S ttf-wps-fonts wps-office-fonts # å®‰è£…å­—ä½“  å¦‚æœä½¿ç”¨ KDEï¼Œå¯èƒ½ä¼šé‡åˆ°å­—ä½“æ¨¡ç³Šçš„æƒ…å†µï¼Œè¿™æ˜¯ç”±ç¼©æ”¾ä¸ä¸º 100% å¼•èµ·çš„é—®é¢˜ï¼ŒWPS ä½¿ç”¨äº† Qt æ‰€ä»¥åªè¦åœ¨è¿è¡Œå‰åŠ ä¸Šç¯å¢ƒå˜é‡ QT_SCREEN_SCALE_FACTORS=1 å³å¯ï¼Œå¯¹äºå¯åŠ¨å™¨æˆ–æ¡Œé¢ä¸Šçš„ Desktop Entryï¼Œåªè¦åœ¨ /usr/share/applications ä¸‹ä¿®æ”¹æ‰€æœ‰å« wps çš„ Desktop Entry æ–‡ä»¶å³å¯ï¼ŒæŒ‰ç…§ä¸‹é¢ä¿®æ”¹å³å¯ï¼š\n# /usr/share/applications/wps-office-wps.desktop Exec=env QT_SCREEN_SCALE_FACTORS=1 /usr/bin/wps %U  è¿™ä¸ªæ–¹æ³•è¿˜é€‚ç”¨äºå…¶ä»–çš„ Qt ç¨‹åºã€‚\nfcitx 5 fcitx 5 ä½¿ç”¨ç®€å•ï¼Œæ¯”è¾ƒæ¨èã€‚\nå®‰è£…ï¼š\n$ sudo pacman -S fcitx5-im fcitx5-configtool fcitx5-chinese-addons fcitx5-rime  æ·»åŠ ç¯å¢ƒå˜é‡åˆ° /etc/environment ä»¥æ­£å¸¸ä½¿ç”¨ fcitx5ï¼š\nGTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx INPUT_METHOD=fcitx SDL_IM_MODULE=fcitx GLFW_IM_MODULE=ibus  å¦‚æœæ— æ³•å¼€æœºå¯åŠ¨ï¼Œåˆ™æ‰§ä»¥ä¸‹å‘½ä»¤ï¼š\n# é€šè¿‡åœ¨ autostart ç›®å½•ä¸‹æ·»åŠ å¯åŠ¨é¡¹ $ cp /usr/share/applications/org.fcitx.Fcitx5.desktop ~/.config/autostart/  è¯åº“å®‰è£…ï¼Œå¯ä»¥è‡ªå·±é€‰æ‹©ï¼š\n$ sudo pacman -S fcitx5-pinyin-zhwiki $ yay -S fcitx5-pinyin-sougou $ yay -S fcitx5-pinyin-zhwiki-rime $ yay -S fcitx5-pinyin-moegirl-rime  è§£å†³ä¸­æ–‡ä¸‹æŒ‰ [ å’Œ ] è¾“å‡ºä¸ºå…¶ä»–ç¬¦å·ï¼šç¼–è¾‘ /usr/share/fcitx5/punctuation/punc.mb.zh_CNï¼ŒæŠŠ [ å’Œ ] æ˜ å°„çš„å­—ç¬¦ä¿®æ”¹ä¸º ã€ å’Œ ã€‘ã€‚\nIcalingua++ ä¸€ä¸ª OICQ å‰ç«¯ï¼ŒåŸºäºå·²ç»è¢«å°æ€çš„ Icalinguaï¼Œæ‹¥æœ‰å¤§å¤šæ•°å®ç”¨åŠŸèƒ½ã€‚GitHub é¡¹ç›®ä¸»é¡µï¼šhttps://github.com/icalingua-plus-plus/icalingua-plus-plusã€‚æœ‰å„ç§å®‰è£…æ–¹å¼ï¼Œå¦‚ AppImageã€pacmanã€yayã€‚\nè‹¥ä½¿ç”¨ pacman å®‰è£…ï¼Œåˆ™éœ€å…ˆä¸‹è½½è½¯ä»¶åŒ…ï¼Œæ¯”å¦‚æ˜¯ icalingua-2.6.1-1-x86_64.pkg.tar.zstï¼Œåˆ™ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š\n$ sudo pacman -U icalingua-2.6.1-1-x86_64.pkg.tar.zst  è‹¥ä½¿ç”¨ yayï¼š\n$ yay -S icalingua++  è¿™é‡Œè¿˜æ˜¯è¦è¯´ä¸€å¥ï¼štx nm*lã€‚\n","id":2,"section":"posts","summary":"è®°å½•ä¸€ä¸‹å®‰è£… Arch Linux åçš„å¸¸ç”¨è½¯ä»¶å®‰è£…ä»¥åŠé…ç½®ã€‚ yay ä½¿ç”¨ yay ä» AUR ä¸Šä¸‹è½½å„ç§å®˜æ–¹ä»“åº“æ‰€æ²¡æœ‰çš„åŒ…ã€‚ é¡¹ç›®ä¸»é¡µï¼šhttps://github.com/Jgue","tags":["Linux","Arch Linux","é…ç½®"],"title":"Arch Linux å¸¸ç”¨è½¯ä»¶é…ç½®","uri":"https://ctj12461.vercel.app/contents/20220317-arch-linux-software-config/","year":"2022"},{"content":"äºŒåˆ†å›¾ å®šä¹‰ å¦‚æœä¸€ä¸ªå›¾ $G=(V,E)$ ä¸­çš„ç»“ç‚¹å¯ä»¥è¢«åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸”ä¸¤ä¸ªéƒ¨åˆ†ä¹‹å†…çš„ç‚¹äº’ç›¸æ²¡æœ‰è¿è¾¹ï¼Œåˆ™ç§°è¿™ç§å›¾ä¸ºäºŒåˆ†å›¾ã€‚å¦‚æœæ¯ä¸ªç»“ç‚¹çš„åº¦æ•°ç›¸ç­‰ä¸”éƒ½ä¸º $k$ï¼Œåˆ™ç§°è¿™ç§äºŒåˆ†å›¾ä¸º $k$ - æ­£åˆ™äºŒåˆ†å›¾ã€‚\nåˆ¤æ–­ å¯¹å›¾çš„ç»“ç‚¹è¿›è¡Œé»‘ç™½æŸ“è‰²ï¼Œç›¸è¿çš„ç»“ç‚¹æŸ“ä¸åŒçš„é¢œè‰²ï¼Œè‹¥æœ€åæ»¡è¶³æ¯æ¡è¾¹çš„ä¸¤ä¸ªç«¯ç‚¹é¢œè‰²ä¸ç›¸åŒï¼Œåˆ™è¿™ä¸ªå›¾æ˜¯äºŒåˆ†å›¾ã€‚æ ‘ä¹Ÿæ˜¯äºŒåˆ†å›¾ã€‚\næŸ“è‰² è¿™é‡Œçš„æŸ“è‰²ä¸åŒäºåˆ¤æ–­çš„æŸ“è‰²ï¼Œå®ƒæŒ‡çš„æ˜¯å¯¹è¾¹è¿›è¡ŒæŸ“è‰²ã€‚è‹¥æŸ“ $k$ ç§é¢œè‰²ï¼Œåˆ™ç§°å…¶ä¸ºäºŒåˆ†å›¾çš„ $k$ æŸ“è‰²ã€‚\nå¯¹äºä¸€ä¸ª $k$ - æ­£åˆ™äºŒåˆ†å›¾æ¥è¯´ï¼Œå®ƒä¸€å®šå¯ä»¥è¢« $k$ æŸ“è‰²ï¼Œè€Œå¯¹äºä¸€èˆ¬çš„äºŒåˆ†å›¾ï¼Œè‹¥å…¶æœ€å¤§åº¦æ•°ä¸º $k$ï¼Œåˆ™å®ƒä¹Ÿå¯ä»¥è¢« $k$ æŸ“è‰²ã€‚\nåŒ¹é… åœ¨äºŒåˆ†å›¾çš„è¾¹é›†ä¸­é€‰å‡ºä¸€ä¸ªéç©ºå­é›†ï¼Œä¸”è¿™ä¸ªéç©ºå­é›†å†…æ²¡æœ‰ä¸¤æ¡è¾¹è¿æ¥äº†ä¸€ä¸ªç›¸åŒçš„ç«¯ç‚¹ï¼Œåˆ™è¿™ä¸ªéç©ºå­é›†è¢«ç§°ä¸ºäºŒåˆ†å›¾çš„ä¸€ä¸ªåŒ¹é…ï¼ŒåŒæ ·å¯¹äºä¸€èˆ¬å›¾ä¹Ÿæœ‰ç±»ä¼¼çš„æ¦‚å¿µã€‚\nè‹¥ä¸€ä¸ªåŒ¹é…çš„æ‰€å«çš„è¾¹æ•°æœ€å¤§ï¼Œåˆ™ç§°è¿™ä¸ªåŒ¹é…ä¸ºæœ€å¤§åŒ¹é…ã€‚\nè‹¥äºŒåˆ†å›¾ä¸¤è¾¹çš„ç»“ç‚¹ä¸ªæ•°ç›¸åŒï¼Œä¸”å­˜åœ¨ä¸€ä¸ªåŒ¹é…æ»¡è¶³å…¶ä¸­çš„è¾¹è¿æ¥äº†æ‰€æœ‰çš„ç‚¹ï¼Œåˆ™è¿™ä¸ªåŒ¹é…è¢«ç§°ä¸ºè¿™ä¸ªäºŒåˆ†å›¾çš„å®Œç¾åŒ¹é…æˆ–è€…å®Œå¤‡åŒ¹é…ã€‚\nè‹¥æ¯æ¡è¾¹æœ‰è¾¹æƒï¼Œä¸”ä¸€ä¸ªåŒ¹é…çš„æ‰€å«çš„è¾¹çš„æƒå€¼å’Œæœ€å¤§ï¼Œåˆ™è¿™ä¸ªåŒ¹é…è¢«ç§°ä¸ºè¿™ä¸ªäºŒåˆ†å›¾çš„æœ€å¤§æƒåŒ¹é…ã€‚\nåŒˆç‰™åˆ©ç®—æ³• äº¤æ›¿è·¯ å‡è®¾åœ¨äºŒåˆ†å›¾æœ€å¤§åŒ¹é…çš„è¿‡ç¨‹ä¸­ï¼Œå·²ç»æ‰¾åˆ°äº†ä¸€äº›è¾¹ä½œä¸ºä¸€ä¸ªåŒ¹é…ï¼Œåˆ™ä¸€æ¡äº¤æ›¿è·¯å°±æ˜¯ä¸€ä¸ªåŒ¹é…è¾¹å’ŒéåŒ¹é…è¾¹äº¤æ›¿è¿æ¥ç»„æˆçš„ç®€å•è·¯å¾„ã€‚\næ ¹æ®äºŒåˆ†å›¾çš„å®šä¹‰ï¼Œå‡è®¾ä¸€æ¡äº¤æ›¿è·¯çš„èµ·ç‚¹åœ¨å·¦è¾¹ï¼Œä¸”ç¬¬ä¸€æ¡è¾¹æ˜¯åŒ¹é…è¾¹ï¼Œåˆ™è¿™æ¡äº¤æ›¿è·¯ä¸­çš„åŒ¹é…è¾¹ä¸€å®šéƒ½æ˜¯ä»å·¦è¾¹åˆ°å³è¾¹ï¼Œè€ŒéåŒ¹é…è¾¹ä¸€å®šæ˜¯ä»å³è¾¹åˆ°å·¦è¾¹ã€‚\näº¤æ›¿è·¯ä¸Šçš„ç»“ç‚¹æœ€å¤šè¿æ¥ä¸€æ¡åŒ¹é…è¾¹å’Œä¸€æ¡éåŒ¹é…è¾¹ï¼Œæ‰€ä»¥å¦‚æœæŠŠäº¤æ›¿è·¯ä¸Šçš„åŒ¹é…è¾¹å˜ä¸ºéåŒ¹é…è¾¹ï¼ŒéåŒ¹é…è¾¹å˜ä¸ºåŒ¹é…è¾¹ï¼Œåˆ™ä»ç„¶æ»¡è¶³æ¡ä»¶ï¼Œä¹Ÿå°±æ˜¯äº¤æ›¿è·¯è¾¹é›†çš„åŒ¹é…è¾¹é›†çš„è¡¥é›†ä¹Ÿå¯ä»¥æ˜¯åŒ¹é…ã€‚\nå¢å¹¿è·¯ åŒˆç‰™åˆ©ç®—æ³•çš„æ ¸å¿ƒå°±æ˜¯æ‰¾å¢å¹¿è·¯ï¼Œè¿™æ¡å¢å¹¿è·¯æ˜¯ä¸€æ¡äº¤æ›¿è·¯ã€‚æ¯æ¬¡å¢å¹¿ä»å·¦è¾¹å¼€å§‹ï¼Œç¬¬ä¸€æ¡è¾¹æ˜¯éåŒ¹é…è¾¹ï¼Œæœ€åä¸€æ¡è¾¹ä¹Ÿæ˜¯éåŒ¹é…è¾¹ï¼Œæ ¹æ®ä¸Šæ–‡çš„æè¿°ï¼Œè¿™æ ·çš„è·¯å¾„çš„è¾¹æ•°ä¸ºå¥‡æ•°ï¼ŒéåŒ¹é…è¾¹ä¸ªæ•°æ¯”åŒ¹é…è¾¹ä¸ªæ•°å¤š $1$ï¼Œè‹¥æŠŠåŒ¹é…è¾¹ä¸éåŒ¹é…è¾¹åè½¬ï¼Œåˆ™åè½¬åçš„è¾¹é›†ä»ç„¶æ˜¯ä¸€ä¸ªåˆæ³•çš„åŒ¹é…ï¼Œä¸”æ¯”åŸæ¥çš„åŒ¹é…çš„è¾¹æ•°å¤šäº† $1$ã€‚å¦‚æœèƒ½æ‰¾åˆ°ä¸€æ¡è¿™æ ·çš„å¢å¹¿è·¯ï¼Œåˆ™æ­¤æ¬¡å¢å¹¿æˆåŠŸã€‚\nå…·ä½“æ¥è¯´ï¼Œæ¯”å¦‚ä¸€ä¸ªå·¦è¾¹çš„ç»“ç‚¹ $x$ æ‰¾åˆ°äº†ä¸€ä¸ªå³è¾¹çš„ç»“ç‚¹ $y$ï¼Œå®ƒæ²¡æœ‰ä¸å…¶ä»–å·¦è¾¹çš„ç»“ç‚¹åŒ¹é…è¿‡ï¼Œåˆ™ $e(x,y)$ å¯ä»¥ä½œä¸ºä¸€ä¸ªåŒ¹é…è¾¹ï¼Œåè½¬è¾¹é›†å‰ï¼Œæœ‰ $1$ æ¡åŒ¹é…è¾¹ï¼Œ$0$ æ¡éåŒ¹é…è¾¹ï¼Œå¢å¹¿æˆåŠŸã€‚\nå¦‚æœå³è¾¹çš„ç»“ç‚¹ $y$ å·²ç»æœ‰åŒ¹é…äº†ï¼Œé‚£ä¹ˆå°±å¯ä»¥è®©åŸæ¥ $y$ çš„åŒ¹é… $x\u0026rsquo;$ æ–°æ‰¾ä¸€ä¸ªç‚¹ $y\u0026rsquo;$ï¼Œå¦‚æœèƒ½å¤Ÿæ‰¾åˆ°è¿™ä¸ª $y\u0026rsquo;$ï¼Œé‚£ä¹ˆ $e(x\u0026rsquo;,y\u0026rsquo;)$ æˆä¸ºä¸€ä¸ªåŒ¹é…è¾¹ï¼Œ$y$ å°±æ— éœ€å’Œ $x\u0026rsquo;$ åŒ¹é…äº†ï¼Œä¹Ÿå°±æ˜¯è¯´ $y$ å·²ç»å˜ä¸ºäº†ä¸€ä¸ªæ²¡æœ‰åŒ¹é…çš„ç‚¹ï¼Œ$x$ å°±å¯ä»¥ä¸ $y$ åŒ¹é…äº†ã€‚å¦‚æœ $x\u0026rsquo;$ æ‰¾ä¸åˆ° $y\u0026rsquo;$ï¼Œé‚£ä¹ˆ $x\u0026rsquo;$ å°±è¦ä¿æŒåŸæ ·ï¼Œå’Œ $y$ åŒ¹é…ï¼Œé‚£ä¹ˆ $x$ å°±ä¸å¯ä»¥å’Œ $y$ åŒ¹é…ï¼Œåªèƒ½ç»§ç»­å¯»æ‰¾ä¸‹ä¸€ä¸ªå¯èƒ½çš„ç»“ç‚¹ã€‚\nå¯¹äº $x\u0026rsquo;$ï¼Œå®ƒæ‰¾ $y\u0026rsquo;$ çš„è¿‡ç¨‹å’Œ $x$ æ‰¾ $y$ çš„è¿‡ç¨‹æ˜¯ä¸€æ ·çš„ï¼Œæ‰€ä»¥å¯ä»¥é€’å½’å®ç°ã€‚\næ€»ç»“ä¸€ä¸‹ï¼Œä¸€ä¸ªç»“ç‚¹ $x$ çš„å¯»æ‰¾è¿‡ç¨‹å¯ä»¥åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š\n æ‰¾åˆ°ä¸€ä¸ªæœªåŒ¹é…ç»“ç‚¹ $y$ï¼Œä¸å®ƒåŒ¹é… è®©ä¸€ä¸ªå·²åŒ¹é…çš„ç»“ç‚¹ $y$ å’Œ $y$ çš„å¦ä¸€è¾¹çš„ç»“ç‚¹ $x\u0026rsquo;$ å–æ¶ˆåŒ¹é…ï¼Œè®© $x\u0026rsquo;$ æ‰¾æ–°åŒ¹é…ç‚¹ $y\u0026rsquo;$ï¼Œè‹¥å–æ¶ˆæˆåŠŸï¼Œåˆ™ $x$ ä¸ $y$ å¯ä»¥åŒ¹é…  å¯ä»¥å‘ç° $x$ å¯»æ‰¾æˆåŠŸï¼Œåˆ™åŒ¹é…è¾¹éƒ½å˜æˆäº†éåŒ¹é…è¾¹ï¼ŒåŸæ¥çš„éåŒ¹é…è¾¹éƒ½å˜æˆäº†åŒ¹é…è¾¹ï¼Œä¹Ÿå°±æ˜¯æ‰¾å¢å¹¿è·¯çš„è¿‡ç¨‹ï¼Œç„¶åå¯¹è¿™æ¡å¢å¹¿è·¯çš„åŒ¹é…è¾¹ä¸éåŒ¹é…è¾¹åè½¬ï¼ŒåŒ¹é…è¾¹æ•°åŠ  $1$ã€‚å°±è¿™æ ·å¯¹äºå·¦è¾¹çš„æ¯ä¸ªç»“ç‚¹éƒ½å¢å¹¿ï¼Œå°è¯•æ‰¾åˆ°å·¦è¾¹çš„æ¯ä¸ªç»“ç‚¹å¯¹åº”çš„åŒ¹é…ï¼Œæœ€åå°±æ‰¾åˆ°äº†æœ€å¤§åŒ¹é…ã€‚\næ—¶é—´å¤æ‚åº¦æ˜¯ $O(|V||E|)$ çš„ï¼Œä¸€èˆ¬æƒ…å†µä¸‹è·‘ä¸æ»¡è¿™ä¸ªä¸Šç•Œã€‚\nä»£ç å®ç° bool augment(int x) { for (int y : graph[x]) { if (vis[y]) continue; // æ— è®ºæ˜¯å¦å¢å¹¿æˆåŠŸï¼Œå¯¹äºå½“å‰å¢å¹¿è·¯ä¸Šçš„ç»“ç‚¹ï¼Œä¸‹æ¬¡éƒ½å¯ä»¥ä¸ç”¨å†èµ°è¿™ä¸ªç‚¹ vis[y] = true; // y æ²¡æœ‰åŒ¹é…æˆ–è€…å–æ¶ˆ y çš„åŒ¹é…æˆåŠŸ if (!match[y] || augment(match[y])) { match[y] = x; return true; // æ‰¾åˆ°åŒ¹é…ç‚¹ï¼Œå¢å¹¿æˆåŠŸ } } return false; // æ²¡æœ‰æ‰¾åˆ°ç»“ç‚¹ï¼Œå¢å¹¿å¤±è´¥ } int hungary() { int res = 0; for (int i = 1; i \u0026lt;= n; ++i) match[i] = 0; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) // æ¯æ¬¡å¢å¹¿éƒ½è¦æ¸…ç©º vis[j] = false; if (augment(i)) ++res; } return res; }  äºŒåˆ†å›¾æœ€å¤§åŒ¹é…æ€§è´¨ ç›¸å…³æ¦‚å¿µ å‡è®¾æœ‰ä¸€ä¸ªå›¾ $G=(V,E)$ï¼Œä¸‹é¢æ˜¯ä¸€äº›å¸¸è§çš„æ¦‚å¿µï¼š\n è¾¹è¦†ç›–ï¼šè¾¹è¦†ç›–æ˜¯ $E$ çš„ä¸€ä¸ªå­é›† $E\u0026rsquo;$ï¼Œ$\\forall\\ x \\in E$ï¼Œæ»¡è¶³ $x$ æ˜¯è¾¹ $e$ çš„ç«¯ç‚¹ï¼Œä¸” $e \\in E\u0026rsquo;$ï¼Œä¹Ÿå°±æ˜¯ $E\u0026rsquo;$ ä¸­çš„è¾¹çš„ç«¯ç‚¹çš„å¹¶é›†æ˜¯ $V$ ç‹¬ç«‹é›†ï¼šç‹¬ç«‹é›†æ˜¯ $V$ çš„ä¸€ä¸ªå­é›† $V\u0026rsquo;$ï¼Œ$\\forall\\ x,y \\in V$ï¼Œæ»¡è¶³ $e(x,y) \\notin E$ï¼Œä¹Ÿå°±æ˜¯ç‹¬ç«‹é›†ä¸­çš„ç‚¹äº’ä¸ç›¸è¿ å›¢ï¼šå›¢æ˜¯å›¾ $G$ çš„ä¸€ä¸ªå­å›¾ $G\u0026rsquo;=(V\u0026rsquo;,E\u0026rsquo;)$ï¼Œ$V\u0026rsquo; \\subseteq V$ï¼Œ$E\u0026rsquo; \\subseteq E$ï¼Œä¸”å›¢æ˜¯å®Œå…¨å›¾ï¼Œå³ $\\forall\\ x,y \\in V$ï¼Œæ»¡è¶³ $e(x,y) \\in E\u0026rsquo;$ï¼Œä¹Ÿå°±æ˜¯å›¢ä¸­çš„ç‚¹äº’ç›¸è¿è¾¹ ç‚¹è¦†ç›–ï¼šç‚¹è¦†ç›–æ˜¯ $V$ çš„ä¸€ä¸ªå­é›† $V\u0026rsquo;$ï¼Œ$\\forall\\ e(x,y) \\in V$ï¼Œæ»¡è¶³ $x \\in V\u0026rsquo;$ æˆ– $y \\in V\u0026rsquo;$ï¼Œä¹Ÿå°±æ˜¯ $V\u0026rsquo;$ ä¸­çš„ç‚¹æ‰€è¿çš„è¾¹çš„å¹¶é›†æ˜¯ $E$  ç­‰å¼ è‹¥ä¸€ä¸ªå›¾æ˜¯äºŒåˆ†å›¾ï¼Œåˆ™æœ‰å¦‚ä¸‹æ€§è´¨ï¼š\n è‹¥äºŒåˆ†å›¾ä¸å­˜åœ¨å­¤ç«‹çš„ç‚¹ï¼Œåˆ™ $|$æœ€å°è¾¹è¦†ç›–$| = |V| - |$æœ€å¤§åŒ¹é…$|$ $|$æœ€å¤§ç‹¬ç«‹é›†$| = |$è¡¥å›¾çš„æœ€å¤§å›¢$| = |V| - |$æœ€å¤§åŒ¹é…$|$ $|$æœ€å°ç‚¹è¦†ç›–$| = |$æœ€å¤§åŒ¹é…$|$  ä¸ DAG çš„å…³ç³» å¯¹äºä¸€ä¸ª DAG $G$ï¼Œæ„é€ äºŒåˆ†å›¾ $G\u0026rsquo;$ï¼Œæ»¡è¶³ $G$ ä¸­çš„æœ‰å‘è¾¹ $e(x,y)$ ä¸ $G\u0026rsquo;$ ä¸­çš„è¾¹ $e(x,y\u0026rsquo;)$ ä¸€ä¸€å¯¹åº”ï¼Œå…¶ä¸­ $x$ å’Œ $y\u0026rsquo;$ åœ¨ä¸¤è¾¹ã€‚æ­¤æ—¶æ»¡è¶³ $|G$ çš„æœ€å°è·¯å¾„è¦†ç›–$| = |G\u0026rsquo;$ çš„æœ€å°ç‚¹è¦†ç›–$|$ã€‚è·¯å¾„è¦†ç›–æŒ‡é€‰å‡ºä¸€äº›è·¯å¾„ $p$ ç»„æˆä¸€ä¸ªé›†åˆ $P$ï¼Œæ»¡è¶³å›¾ä¸­æ‰€æœ‰ç‚¹éƒ½è¢«è‡³å°‘ä¸€ä¸ª $p$ ç»è¿‡ï¼Œä¸” $p \\in P$ã€‚\nå»ºæ¨¡ç›¸å…³ å¯ä»¥é€šè¿‡ä¸€äº›è½¬åŒ–æŠŠé¢˜ç›®è½¬åŒ–ä¸ºäºŒåˆ†å›¾çš„é—®é¢˜ï¼Œç”¨ä¸Šé¢çš„æ€§è´¨è§£å†³ï¼Œè¯¦æƒ…è§ä¸‹é¢çš„ä¾‹é¢˜ã€‚\nä¾‹é¢˜ Luogu P2055 å‡æœŸçš„å®¿èˆ  å­¦æ ¡æ”¾å‡äº†â€¦â€¦æœ‰äº›åŒå­¦å›å®¶äº†ï¼Œè€Œæœ‰äº›åŒå­¦åˆ™æœ‰ä»¥å‰çš„å¥½æœ‹å‹æ¥æ¢è®¿ï¼Œé‚£ä¹ˆä½å®¿å°±æ˜¯ä¸€ä¸ªé—®é¢˜ã€‚\næ¯”å¦‚ A å’Œ B éƒ½æ˜¯å­¦æ ¡çš„å­¦ç”Ÿï¼ŒA è¦å›å®¶ï¼Œè€Œ C æ¥çœ‹ Bï¼ŒC ä¸ A ä¸è®¤è¯†ã€‚æˆ‘ä»¬å‡è®¾æ¯ä¸ªäººåªèƒ½ç¡å’Œè‡ªå·±ç›´æ¥è®¤è¯†çš„äººçš„åºŠã€‚é‚£ä¹ˆä¸€ä¸ªè§£å†³æ–¹æ¡ˆå°±æ˜¯ B ç¡ A çš„åºŠè€Œ C ç¡ B çš„åºŠã€‚è€Œå®é™…æƒ…å†µå¯èƒ½éå¸¸å¤æ‚ï¼Œæœ‰çš„äººå¯èƒ½è®¤è¯†å¥½å¤šåœ¨æ ¡å­¦ç”Ÿï¼Œåœ¨æ ¡å­¦ç”Ÿä¹‹é—´ä¹Ÿä¸ä¸€å®šéƒ½äº’ç›¸è®¤è¯†ã€‚\næˆ‘ä»¬å·²çŸ¥ä¸€å…±æœ‰ $n$ ä¸ªäººï¼Œå¹¶ä¸”çŸ¥é“å…¶ä¸­æ¯ä¸ªäººæ˜¯ä¸æ˜¯æœ¬æ ¡å­¦ç”Ÿï¼Œä¹ŸçŸ¥é“æ¯ä¸ªæœ¬æ ¡å­¦ç”Ÿæ˜¯å¦å›å®¶ã€‚é—®æ˜¯å¦å­˜åœ¨ä¸€ä¸ªæ–¹æ¡ˆä½¿å¾—æ‰€æœ‰ä¸å›å®¶çš„æœ¬æ ¡å­¦ç”Ÿå’Œæ¥çœ‹ä»–ä»¬çš„å…¶ä»–äººéƒ½æœ‰åœ°æ–¹ä½ã€‚\n$T$ ç»„æ•°æ®ï¼Œ$1\\le T\\le 20$ï¼Œ$1\\le n\\le 50$ã€‚\n æ¯ä¸ªäººåªèƒ½ç¡ä¸€å¼ åºŠï¼Œä¸€å¼ åºŠä¹Ÿåªèƒ½è¢«ä¸€ä¸ªäººç¡ï¼Œæ‰€ä»¥è¿™å°±æ˜¯ä¸€ä¸ªäºŒåˆ†å›¾æœ€å¤§åŒ¹é…çš„é—®é¢˜ï¼ŒæŠŠç•™åœ¨å­¦æ ¡çš„å­¦ç”Ÿå’Œå¤–æ ¡çš„å­¦ç”Ÿæ”¾åœ¨å·¦è¾¹ï¼Œæœ¬æ ¡çš„å­¦ç”Ÿçš„åºŠæ”¾åœ¨å³è¾¹ï¼Œå¦‚æœ A å’Œ B æ˜¯æœ‹å‹ï¼Œåˆ™å®ƒä»¬å¯ä»¥ç¡å¯¹æ–¹çš„åºŠï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œå°±æŠŠ A å‘ B çš„åºŠè¿è¾¹ï¼ŒæŠŠ B å‘ A çš„åºŠè¿è¾¹ï¼Œæ±‚æœ€å¤§åŒ¹é…å³å¯ã€‚\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; constexpr int MAX_N = 50 + 5; int t, n; bool local[MAX_N], home[MAX_N]; vector\u0026lt;int\u0026gt; graph[MAX_N]; int match[MAX_N]; bool vis[MAX_N]; void clear() { for (int i = 1; i \u0026lt;= n; ++i) { graph[i].clear(); match[i] = 0; } } bool augment(int x) { for (int y : graph[x]) { if (vis[y]) continue; vis[y] = true; if (!match[y] || augment(match[y])) { match[y] = x; return true; } } return false; } bool hungary() { int tot = 0, cnt = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (local[i] \u0026amp;\u0026amp; home[i]) continue; ++tot; for (int j = 1; j \u0026lt;= n; ++j) vis[j] = false; if (augment(i)) ++cnt; } return tot == cnt; } void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; local[i]; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; home[i]; clear(); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { bool fri; cin \u0026gt;\u0026gt; fri; if (fri) { if (local[j]) graph[i].push_back(j); if (local[i]) graph[j].push_back(i); } } if (local[i] \u0026amp;\u0026amp; !home[i]) graph[i].push_back(i); } cout \u0026lt;\u0026lt; (hungary() ? \u0026quot;^_^\u0026quot; : \u0026quot;T_T\u0026quot;) \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; }  Luogu P6268 èˆä¼š  æŸå­¦æ ¡è¦å¬å¼€ä¸€ä¸ªèˆä¼šã€‚å·²çŸ¥å­¦æ ¡æ‰€æœ‰ $n$ åå­¦ç”Ÿä¸­ï¼Œæœ‰ $m$ å¯¹ç”·ç”Ÿå’Œå¥³ç”Ÿäº’ç›¸è·³è¿‡èˆï¼Œä¸€ä¸ªç”·ç”Ÿæˆ–ä¸€ä¸ªå¥³ç”Ÿå¯èƒ½å’Œå¤šä¸ªäººäº’ç›¸è·³è¿‡èˆã€‚åœ¨è¿™ä¸ªèˆä¼šä¸Šï¼Œè¦æ±‚è¢«é‚€è¯·çš„å­¦ç”Ÿä¸­çš„ä»»ä½•ä¸€å¯¹ç”·ç”Ÿå’Œå¥³ç”Ÿäº’ç›¸éƒ½ä¸èƒ½è·³è¿‡èˆã€‚æ±‚è¿™ä¸ªèˆä¼šæœ€å¤šèƒ½é‚€è¯·å¤šå°‘ä¸ªå­¦ç”Ÿå‚åŠ ã€‚\n$1\\le n\\le 1000$ï¼Œ$1\\le m\\le 2000$ã€‚\n æŠŠè·³è¿‡èˆçš„ç”·ç”Ÿå’Œå¥³ç”Ÿè¿è¾¹ï¼Œå› ä¸ºä¸å¯èƒ½å’ŒåŒæ€§è·³èˆï¼Œæ‰€ä»¥å¯ä»¥æŠŠè¿™ä¸ªå›¾çœ‹æˆäºŒåˆ†å›¾ï¼Œç”·ç”Ÿåœ¨å·¦è¾¹ï¼Œå¥³ç”Ÿåœ¨å³è¾¹ï¼Œè¦æ±‚é€‰å‡ºçš„åŒå­¦ä¹‹é—´æ²¡æœ‰äº’ç›¸è·³è¿‡èˆï¼Œæ˜¾ç„¶åŒæ€§å¯ä»¥æ»¡è¶³è¿™ä¸ªæ¡ä»¶ï¼Œå¯¹äºå¼‚æ€§ï¼Œåªè¦æ²¡æœ‰äº’ç›¸è·³è¿‡èˆï¼Œä¹Ÿå°±æ˜¯åœ¨å›¾ä¸­æ²¡æœ‰è¿è¾¹ï¼Œè¿™ä¸ªé—®é¢˜å°±æ˜¯æ±‚äºŒåˆ†å›¾çš„æœ€å¤§ç‹¬ç«‹é›†ã€‚å»ºå‡ºå›¾åå…ˆæŸ“è‰²ï¼Œåˆ†å‡ºäºŒåˆ†å›¾çš„ä¸¤éƒ¨åˆ†ï¼Œæ²¡æœ‰è¿è¾¹çš„ç‚¹å¯ä»¥åˆ†åˆ°ä»»æ„ä¸€éï¼Œç„¶ååˆ©ç”¨ $|$æœ€å¤§ç‹¬ç«‹é›†$| = |V| - |$æœ€å¤§åŒ¹é…$|$ æ±‚å‡ºç­”æ¡ˆå³å¯ã€‚\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; constexpr int MAX_N = 1000 + 10; constexpr int MAX_M = 2000 + 10; int n, m; int col[MAX_N]; vector\u0026lt;int\u0026gt; tmp[MAX_N], graph[MAX_N]; bool vis[MAX_N]; int match[MAX_N]; void link(vector\u0026lt;int\u0026gt; graph[], int x, int y) { graph[x].push_back(y); } void coloring(int x, int now) { if (vis[x]) return; col[x] = now; vis[x] = true; for (int y : tmp[x]) { if (!now) link(graph, x, y); coloring(y, now ^ 1); } } bool augment(int x) { for (int y : graph[x]) { if (vis[y]) continue; vis[y] = true; if (!match[y] || augment(match[y])) { match[y] = x; return true; } } return false; } int hungary() { int res = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (col[i]) continue; for (int j = 1; j \u0026lt;= n; ++j) vis[j] = false; if (augment(i)) ++res; } return res; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; ++x; ++y; link(tmp, x, y); link(tmp, y, x); } for (int i = 1; i \u0026lt;= n; ++i) if (!vis[i]) coloring(i, 0); cout \u0026lt;\u0026lt; n - hungary() \u0026lt;\u0026lt; endl; return 0; }  Luogu P1129 çŸ©é˜µæ¸¸æˆ  å° Q æ˜¯ä¸€ä¸ªéå¸¸èªæ˜çš„å­©å­ï¼Œé™¤äº†å›½é™…è±¡æ£‹ï¼Œä»–è¿˜å¾ˆå–œæ¬¢ç©ä¸€ä¸ªç”µè„‘ç›Šæ™ºæ¸¸æˆâ€•â€•çŸ©é˜µæ¸¸æˆã€‚çŸ©é˜µæ¸¸æˆåœ¨ä¸€ä¸ª $n \\times n$ é»‘ç™½æ–¹é˜µè¿›è¡Œï¼ˆå¦‚åŒå›½é™…è±¡æ£‹ä¸€èˆ¬ï¼Œåªæ˜¯é¢œè‰²æ˜¯éšæ„çš„ï¼‰ã€‚æ¯æ¬¡å¯ä»¥å¯¹è¯¥çŸ©é˜µè¿›è¡Œä¸¤ç§æ“ä½œï¼š\n è¡Œäº¤æ¢æ“ä½œï¼šé€‰æ‹©çŸ©é˜µçš„ä»»æ„ä¸¤è¡Œï¼Œäº¤æ¢è¿™ä¸¤è¡Œï¼ˆå³äº¤æ¢å¯¹åº”æ ¼å­çš„é¢œè‰²ï¼‰ã€‚ åˆ—äº¤æ¢æ“ä½œï¼šé€‰æ‹©çŸ©é˜µçš„ä»»æ„ä¸¤åˆ—ï¼Œäº¤æ¢è¿™ä¸¤åˆ—ï¼ˆå³äº¤æ¢å¯¹åº”æ ¼å­çš„é¢œè‰²ï¼‰ã€‚  æ¸¸æˆçš„ç›®æ ‡ï¼Œå³é€šè¿‡è‹¥å¹²æ¬¡æ“ä½œï¼Œä½¿å¾—æ–¹é˜µçš„ä¸»å¯¹è§’çº¿ï¼ˆå·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„è¿çº¿ï¼‰ä¸Šçš„æ ¼å­å‡ä¸ºé»‘è‰²ã€‚\nå¯¹äºæŸäº›å…³å¡ï¼Œå° Q ç™¾æ€ä¸å¾—å…¶è§£ï¼Œä»¥è‡´ä»–å¼€å§‹æ€€ç–‘è¿™äº›å…³å¡æ˜¯ä¸æ˜¯æ ¹æœ¬å°±æ˜¯æ— è§£çš„ï¼äºæ˜¯å° Q å†³å®šå†™ä¸€ä¸ªç¨‹åºæ¥åˆ¤æ–­è¿™äº›å…³å¡æ˜¯å¦æœ‰è§£ã€‚\n$T$ ç»„æ•°æ®ï¼Œ$1\\le T\\le 20$ï¼Œ$1\\le n\\le 200$ã€‚\n é¦–å…ˆï¼Œå¦‚æœæœ‰ä¸¤ä¸ªé»‘è‰²æ ¼å­åœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—ï¼Œåˆ™ä¸å¯èƒ½é€šè¿‡ä»»ä½•æ“ä½œå°†å®ƒä»¬æ‹†åˆ†åˆ°ä¸åŒè¡Œæˆ–ä¸åŒåˆ—ï¼Œåˆå› ä¸ºä¸»å¯¹è§’çº¿ä¸Šçš„æ ¼å­ä¸¤ä¸¤ä¸åœ¨åŒä¸€è¡Œä¹Ÿä¸åœ¨åŒä¸€åˆ—ï¼Œåˆ™æ¸¸æˆæœ‰è§£çš„æ¡ä»¶å°±æ˜¯å­˜åœ¨ $n$ ä¸ªé»‘è‰²æ ¼å­ä¸¤ä¸¤ä¸åœ¨åŒä¸€è¡Œä¹Ÿä¸åœ¨åŒä¸€åˆ—ã€‚ç”±äºåœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—çš„æ ¼å­æœ€å¤šåªèƒ½å¯¹ç­”æ¡ˆæœ‰ $1$ çš„è´¡çŒ®ï¼Œæ‰€ä»¥å¯ä»¥å¼ºåˆ¶åªé€‰æ‹©ä¸€è¡Œæˆ–ä¸€åˆ—ä¸­çš„ä¸€ä¸ªæ ¼å­ã€‚\nè€ƒè™‘æŠŠæ¯ä¸€è¡Œå»ºä¸€ä¸ªç»“ç‚¹æ”¾åœ¨å·¦è¾¹ï¼Œç”¨ $x$ è¡¨ç¤ºï¼Œæ¯ä¸€åˆ—å»ºä¸€ä¸ªç»“ç‚¹æ”¾åœ¨å³è¾¹ï¼Œç”¨ $y\u0026rsquo;$è¡¨ç¤ºï¼Œå¦‚æœæ ¼å­ $x,y$ ä¸ºé»‘è‰²ï¼Œåˆ™è¿ä¸€æ¡è¾¹ $e(x,y\u0026rsquo;)$ã€‚è¿™æ ·åšä¸€ä¸ªäºŒåˆ†å›¾æœ€å¤§åŒ¹é…ï¼Œå°±æ»¡è¶³äº†æ¯ä¸€è¡Œæˆ–æ¯ä¸€åˆ—æœ€å¤šæœ‰ $1$ çš„è´¡çŒ®çš„æ¡ä»¶ï¼Œå¦‚æœæœ€åå­˜åœ¨å®Œç¾åŒ¹é…ï¼Œåˆ™æ¸¸æˆæœ‰è§£ï¼Œå¦åˆ™æ— è§£ã€‚\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; constexpr int MAX_N = 200 + 10; int t, n; vector\u0026lt;int\u0026gt; graph[MAX_N]; bool vis[MAX_N]; int match[MAX_N]; void link(int x, int y) { graph[x].push_back(y); } void clear() { for (int i = 1; i \u0026lt;= n; ++i) { graph[i].clear(); match[i] = 0; } } bool augment(int x) { for (int y : graph[x]) { if (vis[y]) continue; vis[y] = true; if (!match[y] || augment(match[y])) { match[y] = x; return true; } } return false; } int hungary() { int res = 0; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) vis[j] = false; if (augment(i)) ++res; } return res; } void solve() { cin \u0026gt;\u0026gt; n; clear(); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { int col; cin \u0026gt;\u0026gt; col; if (col) link(i, j); } } cout \u0026lt;\u0026lt; (hungary() == n ? \u0026quot;Yes\u0026quot; : \u0026quot;No\u0026quot;) \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; }  Luogu P1963 å˜æ¢åºåˆ—  ç»™å‡ºä¸€ä¸ªåºåˆ— $0,1,2,\\dots, n-1$ï¼Œä¸€ä¸ªå˜æ¢åºåˆ— $T$ å¯ä»¥ $i$ å˜ä¸º $T_i$ï¼Œ$T$ å¯ä»¥è§†ä¸ºä¸€ä¸ªæ’åˆ—ä¸” $T_i \\in [0,n-1]$ã€‚$\\forall\\ x,y \\in [0,n-1]$ï¼Œå®šä¹‰å®ƒä»¬çš„è·ç¦» $D(x,y)=\\min(|x-y|,n-|x-y|)$ï¼Œå³æŠŠ $x,y$ çœ‹æˆç¯ä¸Šçš„ç‚¹æ—¶çš„è·ç¦»ã€‚ç»™å‡ºæ¯ä¸ª $D(i,T_i)$ï¼Œæ±‚å‡ºä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„åºåˆ— $T$ ä¸”å­—å…¸åºæœ€å°ï¼Œæˆ–åˆ¤æ–­æ— è§£ã€‚\n$1\\le n\\le 10000$ã€‚\n è®¾ $d_i=D(i,T_i)$ï¼Œåˆ™ $i$ å¯¹äºçš„å¯èƒ½çš„ $T_i$ ä¸º $x-d_i,x+d_i,x-(n-d_i),x+(n-d_i)$ ä¸”æ»¡è¶³åœ¨ $[0,n-1]$ ä¹‹å†…ã€‚åŒæ—¶æ³¨æ„åˆ¤æ–­è¿™äº› $T_i$ å¸¦å…¥ $D(i,T_i)$ çš„è®¡ç®—å¼æ—¶æ˜¯å¦èƒ½å¤Ÿæ»¡è¶³æ¡ä»¶ï¼Œå³ $d_i\\le n-d_i$ï¼Œå¦‚æœä¸èƒ½æ»¡è¶³ï¼Œé‚£ä¹ˆè¿™å°±ä¸æ˜¯åˆæ³•çš„ $D(i,T_i)$ï¼Œä¹Ÿå°±æ— è§£äº†ã€‚\nç„¶åå°±æ˜¯äºŒåˆ†å›¾æœ€å¤§åŒ¹é…äº†ï¼Œæ¯ä¸ª $i$ ä»å·¦è¾¹å‘å³è¾¹å¯èƒ½çš„ $T_i$ è¿è¾¹ï¼Œå¯ä»¥å…ˆæ±‚å‡ºä¸€ä¸ªå¯è¡Œè§£ã€‚åœ¨æ±‚å¯è¡Œè§£çš„è¿‡ç¨‹ä¸­ï¼Œä¸ºäº†èƒ½å¤Ÿè®©æŸäº›ç‚¹èƒ½å¤ŸåŒ¹é…ï¼Œæˆ‘ä»¬æ–­å¼€äº†ä¸€äº›å·²åŒ¹é…ç‚¹çš„åŒ¹é…å…³ç³»ï¼Œæ‰€ä»¥è¿™ä¸ªå¯è¡Œè§£ä¸ä¸€å®šæ»¡è¶³å­—å…¸åºæœ€å°ã€‚\næˆ‘ä»¬å¯ä»¥å†è·‘ä¸€éæœ€å¤§åŒ¹é…ï¼Œè®©ä»å‰å¾€åè´ªå¿ƒåœ°è®©æ¯ä¸ªç‚¹å…ˆæ–­å¼€å·²æœ‰çš„åŒ¹é…ï¼Œé‡æ–°é€‰æ‹©ç¼–å·æ›´å°çš„ç‚¹ï¼Œè¿™ä¸ªè¿‡ç¨‹å°±æ˜¯å¢å¹¿çš„è¿‡ç¨‹ï¼ŒåŒæ—¶æ ¹æ®è´ªå¿ƒçš„æ€æƒ³ï¼Œæ›´å‰é¢çš„ç‚¹é€‰æ‹©çš„ç¼–å·æ›´å°ä¸€å®šæ¯”åé¢é€‰è¿™ä¸ªç¼–å·æ›´ä¼˜ï¼Œå¦‚æœåœ¨é‡æ–°å¢å¹¿çš„è¿‡ç¨‹ä¸­é‡åˆ°è¦æ›´æ”¹æ›´å‰é¢çš„ç‚¹çš„åŒ¹é…æ—¶ï¼Œç›´æ¥é€€å‡ºå³å¯ï¼Œå³ä½¿ç°åœ¨æ— æ³•æ¢åˆ°æ›´å°çš„ç¼–å·ï¼Œä¹Ÿèƒ½å¤Ÿä¿è¯æ€»ä½“ä¸Šçš„ç­”æ¡ˆæ›´ä¼˜ã€‚\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; constexpr int MAX_N = 1e4 + 10; int n, d[MAX_N]; std::vector\u0026lt;int\u0026gt; graph[MAX_N]; bool vis[MAX_N], fixed[MAX_N]; int match[MAX_N], ans[MAX_N]; inline void link(int x, int y) { graph[x].push_back(y); } bool augment(int x) { for (int y : graph[x]) { if (vis[y]) continue; vis[y] = true; if (match[y] == -1 || augment(match[y])) { match[y] = x; return true; } } return false; } bool exchange(int x) { if (fixed[x]) return false; for (int y : graph[x]) { if (vis[y]) continue; vis[y] = true; if (match[y] == -1 || exchange(match[y])) { match[y] = x; return true; } } return false; } bool hungary() { int res = 0; for (int i = 0; i \u0026lt; n; ++i) match[i] = -1; for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) vis[j] = false; if (augment(i)) ++res; } if (res != n) return false; for (int i = 0; i \u0026lt; n; ++i) { int other = -1; for (int j = 0; j \u0026lt; n; ++j) { vis[j] = false; if (match[j] == i) other = j; } match[other] = -1; if (!exchange(i)) match[other] = i; fixed[i] = true; } return true; } int main() { std::ios::sync_with_stdio(false); std::cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i) { std::cin \u0026gt;\u0026gt; d[i]; if (d[i] \u0026gt; n - d[i]) continue; if (i - d[i] \u0026gt;= 0) link(i, i - d[i]); if (i + d[i] \u0026lt; n) link(i, i + d[i]); if (i - (n - d[i]) \u0026gt;= 0) link(i, i - (n - d[i])); if (i + (n - d[i]) \u0026lt; n) link(i, i + (n - d[i])); } if (hungary()) { for (int i = 0; i \u0026lt; n; ++i) ans[match[i]] = i; for (int i = 0; i \u0026lt; n; ++i) std::cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; std::cout \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026quot;No Answer\u0026quot; \u0026lt;\u0026lt; std::endl; } return 0; }  UVa 1663 Purifying Machine  ç»™å‡º $m$ ä¸ªé•¿åº¦ä¸º $n$ çš„æ¨¡æ¿ 01 ä¸²ï¼ŒæŸäº›ä¸²å«æœ‰è‡³å¤šä¸€ä¸ª *ï¼Œè¡¨ç¤ºæ­¤å¤„å¯ä»¥åŒ¹é… 0 æˆ– 1ï¼Œæ ¹æ®è¿™äº›æ¨¡æ¿æ„é€ å‡ºä¸€ä¸ªæ•°å­—é›†åˆï¼Œæ»¡è¶³å…¶ä¸­çš„æ•°å­—çš„äºŒè¿›åˆ¶è¡¨ç¤ºéƒ½ä¸º $n$ ä½ï¼Œä¸”èƒ½å¤ŸåŒ¹é…æ¯ä¸€ä¸ªæ¨¡æ¿ä¸²ï¼Œè¦æ±‚ä½ æ„é€ ä¸€äº› 01 ä¸²ï¼Œæœ€å¤šä¹Ÿå¯ä»¥å«æœ‰è‡³å¤šä¸€ä¸ª *ï¼Œä½¿å¾—è¿™äº›æ•°å­—èƒ½å¤Ÿå’Œè‡³å°‘ä¸€ä¸ª 01 ä¸²åŒ¹é…ï¼Œä¸”è¯¥é›†åˆå¤–çš„æ•°å­—å‡ä¸èƒ½å’Œä»»æ„ä¸€ä¸ª 01 ä¸²åŒ¹é…ï¼Œæ±‚æœ€å°çš„ 01 ä¸²ä¸ªæ•°ã€‚\n$1\\le n\\le 10$ï¼Œ$1\\le m\\le 1000$ã€‚\n å®¹æ˜“è¯æ˜ä¸å­˜åœ¨ $3$ ä¸ªåŠä»¥ä¸Šçš„æ•°å­—åœ¨äºŒè¿›åˆ¶è¡¨ç¤ºä¸‹åªæœ‰ $1$ ä½äº’ä¸ç›¸åŒï¼Œæ‰€ä»¥å¯ä»¥æŠŠæ¯ä¸ªæ•°å­—çœ‹ä½œç»“ç‚¹ï¼Œæ¯ä¸ªå« * çš„ 01 ä¸²çœ‹ä½œè¿æ¥ä¸¤ä¸ªåŒ¹é…çš„æ•°å­—çš„ç»“ç‚¹çš„è¾¹ï¼Œåˆ™è¿™ä¸ªå›¾æ˜¯äºŒåˆ†å›¾ã€‚\nä½†æ˜¯è¿™ä¸ªäºŒåˆ†å›¾å¹¶ä¸ä¸€å®šè¿é€šï¼Œå¯¹äºé‚£äº›å­¤ç«‹çš„ç»“ç‚¹ï¼ˆæ•°å­—ï¼‰ï¼Œåªèƒ½ç”¨å›ºå®šçš„ 01 ä¸²å–åŒ¹é…å®ƒä»¬ã€‚å¯¹äºå‰©ä¸‹çš„è¿é€šçš„ç»“ç‚¹ï¼Œè¦æœ‰æœ€å°‘çš„å« * çš„ 01 ä¸²åŒ¹é…æ¯ä¸ªç»“ç‚¹ï¼Œç›¸å½“äºé€‰å‡ºæœ€å°‘çš„è¾¹ï¼Œä½¿å¾—æ¯ä¸ªç»“ç‚¹éƒ½æ˜¯è¿™ä¸ªè¾¹é›†ä¸­çš„æŸæ¡è¾¹çš„ç«¯ç‚¹ï¼Œè¿™å°±æ˜¯æœ€å°è¾¹è¦†ç›–é—®é¢˜ã€‚\nå…ˆå¯¹äºŒåˆ†å›¾æŸ“è‰²ï¼Œåšä¸€éæœ€å¤§åŒ¹é…ï¼Œå†åˆ©ç”¨ $|$æœ€å°è¾¹è¦†ç›–$| = |V| - |$æœ€å¤§åŒ¹é…$|$ æ±‚å‡ºè¿é€šéƒ¨åˆ†çš„ç­”æ¡ˆï¼Œå†åŠ ä¸Šå­¤ç«‹éƒ¨åˆ†çš„ç­”æ¡ˆå°±æ˜¯æ€»ç­”æ¡ˆäº†ã€‚\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAX_N = 10; const int MAX_NODE = (1 \u0026lt;\u0026lt; MAX_N); int n, m; vector\u0026lt;int\u0026gt; tmp[MAX_NODE], graph[MAX_NODE]; int match[MAX_NODE]; bool selected[MAX_NODE], exist[MAX_NODE], vis[MAX_NODE], col[MAX_NODE]; int selectedTot, graphTot; char str[MAX_N + 1]; void link(vector\u0026lt;int\u0026gt; graph[], int x, int y) { graph[x].push_back(y); } bool augment(int x) { for (int i = 0; i \u0026lt; (int) graph[x].size(); ++i) { int y = graph[x][i]; if (vis[y]) continue; vis[y] = true; if (match[y] == -1 || augment(match[y])) { match[y] = x; return true; } } return false; } int hungary() { int res = 0; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) match[i] = -1; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) { if (!exist[i] || col[i]) continue; for (int j = 0; j \u0026lt; (1 \u0026lt;\u0026lt; n); ++j) vis[j] = false; if (augment(i)) ++res; } return res; } void coloring(int x, bool now) { if (vis[x]) return; col[x] = now; vis[x] = true; for (int i = 0; i \u0026lt; (int) tmp[x].size(); ++i) { int y = tmp[x][i]; if (!now) link(graph, x, y); coloring(y, !now); } } int convert(char str[], int len) { int res = 0; for (int i = len - 1; i \u0026gt;= 0; --i) res = (res \u0026lt;\u0026lt; 1) + (str[i] - '0'); return res; } void clear() { selectedTot = graphTot = 0; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) { vis[i] = selected[i] = exist[i] = col[i] = false; tmp[i].clear(); graph[i].clear(); } } void input() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; clear(); for (int i = 1; i \u0026lt;= m; ++i) { cin \u0026gt;\u0026gt; str; for (int j = 0, k = n - 1; j \u0026lt; k; ++j, --k) swap(str[j], str[k]); int pos = -1; for (int j = 0; j \u0026lt; n; ++j) { if (str[j] == '*') { pos = j; break; } } if (pos == -1) { int id = convert(str, n); selected[id] = true; } else { str[pos] = '0'; int id = convert(str, n); selected[id] = true; str[pos] = '1'; id = convert(str, n); selected[id] = true; str[pos] = '*'; } } } void build() { for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) if (selected[i]) ++selectedTot; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) { for (int j = 0; j \u0026lt; n; ++j) { int id1 = (i \u0026amp; (~(1 \u0026lt;\u0026lt; j))), id2 = (i | (1 \u0026lt;\u0026lt; j)); if (selected[id1] \u0026amp;\u0026amp; selected[id2]) { exist[id1] = exist[id2] = true; link(tmp, id1, id2); link(tmp, id2, id1); } } } for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) { if (!exist[i]) continue; ++graphTot; coloring(i, false); } } bool solve() { input(); if (n == 0 \u0026amp;\u0026amp; m == 0) return true; build(); cout \u0026lt;\u0026lt; ((selectedTot - graphTot) + (graphTot - hungary())) \u0026lt;\u0026lt; endl; return false; } int main() { ios::sync_with_stdio(false); bool end = false; do end = solve(); while (!end); return 0; }  ","id":3,"section":"posts","summary":"äºŒåˆ†å›¾ å®šä¹‰ å¦‚æœä¸€ä¸ªå›¾ $G=(V,E)$ ä¸­çš„ç»“ç‚¹å¯ä»¥è¢«åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸”ä¸¤ä¸ªéƒ¨åˆ†ä¹‹å†…çš„ç‚¹äº’ç›¸æ²¡æœ‰è¿è¾¹ï¼Œåˆ™ç§°è¿™ç§å›¾ä¸ºäºŒåˆ†å›¾ã€‚å¦‚æœæ¯ä¸ªç»“ç‚¹çš„åº¦æ•°ç›¸ç­‰ä¸”éƒ½ä¸º $k$ï¼Œåˆ™","tags":["OI","å›¾è®º","äºŒåˆ†å›¾","å»ºæ¨¡","C++"],"title":"äºŒåˆ†å›¾åŒ¹é…å­¦ä¹ ç¬”è®°","uri":"https://ctj12461.vercel.app/contents/20220222-bipartite-graph-matching-note/","year":"2022"},{"content":"è«æ¯”ä¹Œæ–¯åæ¼”å¯ä»¥ç”¨äºä¼˜åŒ–ä¸€ç±»å¼å­çš„è®¡ç®—ã€‚\nè«æ¯”ä¹Œæ–¯å‡½æ•° å®šä¹‰ è«æ¯”ä¹Œæ–¯å‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ï¼š\n$$ \\mu(n)= \\begin{cases} 0 \u0026amp; \\exists\\ p^2 \\mid n \\wedge p\u0026gt;1\\\\ (-1)^k \u0026amp; n=\\prod_{i=1}^{k} p_i \\end{cases} $$\nä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœ $n$ å«æœ‰å¹³æ–¹çº¦æ•°ï¼Œåˆ™ $\\mu(n)=0$ï¼Œå¦åˆ™ $\\mu(n)=(-1)^k$ï¼Œå…¶ä¸­ $k$ ä¸º $n$ ä¸­çš„æœ¬è´¨ä¸åŒçš„è´¨çº¦æ•°ä¸ªæ•°ã€‚\næ€§è´¨ ç§¯æ€§å‡½æ•° $\\mu(n)$ ä¸ºç§¯æ€§å‡½æ•°ï¼Œè¯æ˜å¦‚ä¸‹ï¼š\nè®¾ $a,b$ æ»¡è¶³ $\\gcd(a,b)=1$ã€‚\n è‹¥ $a,b$ å…¶ä¸­ä¸€ä¸ªæ•°å«æœ‰å¹³æ–¹çº¦æ•°ï¼Œåˆ™å®ƒä»¬çš„ä¹˜ç§¯ä¹Ÿä¸€å®šå«æœ‰å¹³æ–¹çº¦æ•°ï¼Œæ­¤æ—¶å®ƒä»¬çš„è«æ¯”ä¹Œæ–¯å‡½æ•°å€¼éƒ½ä¸º $0$ï¼Œå³ $\\mu(ab)=\\mu(a)\\mu(b)=0$ã€‚ å¦åˆ™ $a,b$ éƒ½ä¸å«æœ‰å¹³æ–¹çº¦æ•°ï¼Œåˆ™è®¾å®ƒä»¬çš„è´¨çº¦æ•°ä¸ªæ•°åˆ†åˆ«ä¸º $k_a,k_b$ï¼Œåˆ™ $\\mu(a)=(-1)^{k_a},\\mu(b)=(-1)^{k_b}$ï¼Œå› ä¸ºæ»¡è¶³ $\\gcd(a,b)=1$ï¼Œæ•… $ab$ çš„è´¨çº¦æ•°ä¸ªæ•°ä¸º $k_a+k_b$ï¼Œ$\\mu(ab)=(-1)^{k_a+k_b}=(-1)^{k_a}(-1)^{k_b}=\\mu(a)\\mu(b)$ã€‚  Q.E.D.\nä¸å¸¸æ•°å‡½æ•°çš„å·ç§¯ è¿™ä¸ªæ€§è´¨ååˆ†é‡è¦ï¼Œæ˜¯åæ¼”çš„åŸºç¡€ã€‚è¿™ä¸ªæ€§è´¨å¯ä»¥å†™æˆ $I * \\mu= \\epsilon$ï¼Œæˆ–è€…ï¼š\n$$ \\sum_{d\\mid n}I(\\frac{n}{d})\\mu(d)=\\epsilon(n) $$\nç»å¸¸ç®€è®°ä¸ºï¼š\n$$ \\sum_{d\\mid n} \\mu(d) = [n=1] $$\n$\\epsilon$ æ˜¯ Dirchlet å·ç§¯çš„å•ä½å…ƒå‡½æ•°ã€‚\nè¯æ˜å¦‚ä¸‹ï¼š\nè€ƒè™‘ $d$ ä½œä¸º $n$ çš„çº¦æ•°ï¼Œå…¶è‡ªèº«å¯¹æ•´ä½“çš„è´¡çŒ®ï¼Œè®¾ $n,d$ çš„å”¯ä¸€åˆ†è§£åˆ†åˆ«ä¸º $n=\\prod_{i=1}^{k} p_i^{c_i}$ï¼Œ$d=\\prod_{i=1}^{k} p_i^{c\u0026rsquo;_i}$ã€‚\n è‹¥ $\\exists\\ p_i$ æ»¡è¶³ $p_i^2 \\mid d$ï¼Œåˆ™ $\\mu(d)=0$ï¼Œå®¹æ˜“å‘ç°è¿™æ ·çš„ $d$ çš„å”¯ä¸€åˆ†è§£ä¸­ï¼Œå­˜åœ¨ä¸€ä¸ª $c\u0026rsquo;_i\u0026gt;1$ã€‚ è‹¥ $n\\ne 1$ï¼Œåˆ™ $k\\ne 0$ï¼Œå¯¹ç­”æ¡ˆæœ‰è´¡çŒ®çš„ $d$ ä¸€å®šæ»¡è¶³ $\\forall\\ i\\in [1,k],c_i\\in [0,1]$ï¼Œä¹Ÿå°±æ˜¯æ¯ä¸ª $p_i$ é€‰ä¸€æ¬¡æˆ–ä¸é€‰ã€‚æšä¸¾ $d$ é€‰çš„è´¨çº¦æ•°ä¸ªæ•° $i$ï¼š $$ \\sum_{i=0}^{k} (-1)^i \\binom{k}{i}= \\sum_{i=0}^{k} \\binom{k}{i} 1^{k-i} (-1)^i= [1+(-1)]^k=0 $$ ç‰¹æ®Šè€ƒè™‘ $n=1$ï¼Œæ­¤æ—¶ $k=0$ï¼š $$ \\sum_{i=0}^{k} (-1)^i \\binom{k}{i}= (-1)^0 \\binom{0}{0}=1 $$  ç»¼ä¸Šï¼Œ$\\sum_{d\\mid n} \\mu(d) = \\sum_{i=0}^{k} (-1)^i \\binom{k}{i} = [n=1]$\nQ.E.D.\nå®¹æ–¥ç³»æ•° $\\mu(n)$ çš„æœ¬è´¨å…¶å®æ˜¯å®¹æ–¥ç³»æ•°ï¼Œæ¯”å¦‚è¿™ä¸ªé—®é¢˜ï¼šé•¿åº¦ä¸º $n$ çš„æ•´æ•°åºåˆ—ï¼Œæ¯ä¸ªæ•°çš„å–å€¼èŒƒå›´ä¸º $[1,m]$ï¼Œæ±‚æ»¡è¶³åºåˆ—å…ƒç´ çš„ $\\gcd$ ä¸º $1$ çš„åºåˆ—ä¸ªæ•°ã€‚\nç›´æ¥è®¡ç®—æ¯”è¾ƒéš¾ï¼Œå¯ä»¥ç”¨å®¹æ–¥åŸç†ï¼Œå…ˆè®¾ $f(x)$ ä¸ºåºåˆ—å…ƒç´ çš„ $\\gcd$ ä¸º $x$ çš„å€æ•°çš„åºåˆ—ä¸ªæ•°ï¼Œå†è€ƒè™‘é‡å¤ã€‚æ˜¾ç„¶ $f(x)=\\lfloor \\frac{m}{x} \\rfloor^{n}$ã€‚å‡è®¾æˆ‘ä»¬ç”¨å…¨é›†çš„å¤§å° $f(1)$ å‡å»ä¸åˆæ³•çš„éƒ¨åˆ†ï¼Œå¯¹ $f$ çš„è‡ªå˜é‡å–å€¼è¿›è¡Œè®¨è®ºï¼š\n è‹¥ $x=x_0^k$ ä¸” $k\u0026gt;1$ï¼Œæ˜¾ç„¶ $x$ æ˜¯ $x_0$ çš„å€æ•°ä¸” $x_0$ å¯¹åº”çš„åºåˆ—é›†åˆåŒ…å«äº† $x$ çš„æƒ…å†µï¼Œæ‰€ä»¥ $x$ ä¸éœ€è¦å†è¢«é‡å¤è®¡ç®—ã€‚ è‹¥ $x=ab$ï¼Œåˆ™ $a,b$ å¯¹åº”çš„åºåˆ—é›†åˆåŒ…å«äº† $x$ çš„æƒ…å†µ  è‹¥ $a,b$ å¯¹ç­”æ¡ˆéƒ½æœ‰è´¡çŒ®ï¼Œåˆ™ $x$ çš„è´¡çŒ®è¢«å¤šç®—äº†ä¸€æ¬¡ è‹¥ $a,b$ å…¶ä¸­ä¸€ä¸ªå¯¹ç­”æ¡ˆéƒ½æœ‰è´¡çŒ®ï¼Œåˆ™ $x$ æ²¡æœ‰è¢«é‡å¤è®¡ç®— è‹¥ $a,b$ å…¶ä¸­å¯¹ç­”æ¡ˆéƒ½æ²¡æœ‰è´¡çŒ®ï¼Œåˆ™ $x$ ä¹Ÿä¸éœ€è¦å¯¹ç­”æ¡ˆæœ‰è´¡çŒ®   è‹¥ $x=abc$ï¼Œåˆ™ $a,b,c$ å¯¹åº”çš„åºåˆ—é›†åˆåŒ…å«äº† $x$ çš„æƒ…å†µ  è‹¥ $a,b,c$ å¯¹ç­”æ¡ˆéƒ½æœ‰è´¡çŒ®ï¼Œæ ¹æ®æƒ…å†µ 2ï¼Œ$x$ å¯¹åº”çš„åºåˆ—é›†åˆå«äº $a,b,c,ab,bc,ab$ ä¸­ï¼Œè€Œ $ab,bc,ab$ éƒ½æŠŠ $a,b,c$ çš„é›†åˆä¸­çš„ $x$ çš„æƒ…å†µæ‰£æ‰äº†ï¼Œæ‰€ä»¥ç°åœ¨è¦æŠŠ $x$ çš„è´¡çŒ®åŠ å›å»ã€‚ è‹¥ $a,b,c$ å…¶ä¸­ä¸€ä¸ªå¯¹ç­”æ¡ˆéƒ½æ²¡æœ‰è´¡çŒ®ï¼Œåˆ™åŒæƒ…å†µ 2ï¼Œä¸éœ€è¦åŠ è´¡çŒ® è‹¥ä»… $a,b,c$ å…¶ä¸­ä¸€ä¸ªå¯¹ç­”æ¡ˆéƒ½æœ‰è´¡çŒ®ï¼Œåˆ™åŒæƒ…å†µ 1ï¼Œä¸éœ€è¦åŠ è´¡çŒ® è‹¥ $a,b,c$ å…¶ä¸­å¯¹ç­”æ¡ˆéƒ½æ²¡æœ‰è´¡çŒ®ï¼Œåˆ™ $x$ ä¹Ÿä¸éœ€è¦å¯¹ç­”æ¡ˆæœ‰è´¡çŒ®   etc.  å¯ä»¥çœ‹å‡ºä¸€ä¸ªè§„å¾‹ï¼š\n è‹¥ $x$ ä¸ºæŸä¸ªæ•°çš„è´¡çŒ®ä¸”ä¸ç­‰äºé‚£ä¸ªæ•°ï¼Œåˆ™ç›¸å½“äºå«æœ‰å¹³æ–¹çº¦æ•°ï¼Œå¯ä»¥ç›¸å½“äºå®ƒçš„è´¡çŒ®ä¹˜ $0$ å¦åˆ™è€ƒè™‘å®ƒèƒ½å¤Ÿæ‹†æˆ $x=abc\\cdots$ï¼Œè‹¥å…¶ä¸­ä¸€ä¸ªçš„è´¡çŒ®ä¸º $0$ï¼Œåˆ™ $x$ æœ¬èº«ä¹Ÿä¸éœ€è¦å¯¹ç­”æ¡ˆæœ‰è´¡çŒ®ï¼Œä¹Ÿå°±æ˜¯å…¶ä¸­ä¸€ä¸ªæ•°æœ‰å¹³æ–¹çº¦æ•°ï¼Œå®ƒå°±ä¸éœ€è¦æœ‰è´¡çŒ® è‹¥éƒ½æœ‰ $a,b,c,\\dots$ éƒ½æœ‰è´¡çŒ®ï¼Œåˆ™è´¡çŒ®æ˜¯æ­£è¿˜æ˜¯è´Ÿï¼Œå–å†³äº $a,b,c,\\dots$ çš„ä¸ªæ•°ï¼Œä¸ºå¥‡æ•°åˆ™ä¸ºè´Ÿè´¡çŒ®ï¼Œå¦åˆ™ä¸ºæ­£è´¡çŒ®ã€‚  è¿™ä¸ $\\mu(n)$ çš„å®šä¹‰å®Œå…¨ä¸€è‡´ï¼Œæ‰€ä»¥æˆ‘ä»¬å®Œå…¨å¯ä»¥æŠŠ $\\mu(n)$ å½“æˆå®¹æ–¥ç³»æ•°ã€‚\nè«æ¯”ä¹Œæ–¯åæ¼” åæ¼”å…¬å¼ çº¦æ•°åæ¼”å…¬å¼ $$ f(n)=\\sum_{d\\mid n} g(d) \\implies g(n) = \\sum_{d\\mid n} \\mu(\\frac{n}{d}) f(d) $$\nå€æ•°åæ¼”å…¬å¼ $$ f(n)=\\sum_{n\\mid d} g(d) \\implies g(n) = \\sum_{n\\mid d} \\mu(\\frac{d}{n}) f(d) $$\nå¸¸è§ç»“è®º $$ \\epsilon(n) = \\sum_{d\\mid n}\\mu(d)\\\\ \\varphi(n) = \\sum_{d\\mid n}\\mu(\\frac{n}{d})d = \\sum_{d\\mid n}\\mu(d)\\frac{n}{d}\\\\ d(n) = \\sum_{x\\mid n} I(\\frac{n}{x})I(x) = \\sum_{x\\mid n}1\\\\ \\sigma(n) = \\sum_{d\\mid n} I(\\frac{n}{d})d = \\sum_{d\\mid n} d $$\næˆ–è€…æ˜¯ Dirchlet å·ç§¯å½¢å¼ï¼š\n$$ \\epsilon = I * \\mu\\\\ \\varphi = \\mu * id\\\\ d = I * I\\\\ \\sigma = I * id $$\nåº”ç”¨ å¦‚æœä¸€ä¸ªå‡½æ•° $g(n)$ éš¾ä»¥è®¡ç®—ï¼Œä½†çŸ¥é“äº†å®ƒä¸å¦ä¸€ä¸ªå‡½æ•° $f(x)$ çš„å…³ç³»ï¼Œå¦‚ Dirchlet å·ç§¯çš„å½¢å¼ï¼Œåˆ™å¯ä»¥é€šè¿‡è«æ¯”ä¹Œæ–¯åæ¼”å¾—åˆ°ã€‚æˆ–è€…å¯ä»¥é€šè¿‡è«æ¯”ä¹Œæ–¯åæ¼”å¯¹å¼å­è¿›è¡Œå˜æ¢åŒ–ç®€ï¼Œæ–¹ä¾¿è®¡ç®—ã€‚\nä¾‹é¢˜ Luogu P2522 Problem b  å¯¹äºç»™å‡ºçš„ $n$ ä¸ªè¯¢é—®ï¼Œæ¯æ¬¡æ±‚æœ‰å¤šå°‘ä¸ªæ•°å¯¹ $(x,y)$ï¼Œæ»¡è¶³ $a \\le x \\le b$ï¼Œ$c \\le y \\le d$ï¼Œä¸” $\\gcd(x,y) = k$ã€‚\n$1\\le n,k\\le 5\\times 10^4$ï¼Œ$1\\le a\\le b\\le 5\\times 10^4$ï¼Œ$1\\le c\\le d\\le 5\\times 10^4$ã€‚\n è®¾ $S(n,m)=\\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)=k]$ï¼Œåˆ™æ¯æ¬¡è¯¢é—®çš„ç­”æ¡ˆä¸º $S(b,d)-S(a-1,d)-S(b,c-1)+S(a-1,c-1)$ã€‚æ¥ä¸‹æ¥è¿›è¡Œ $S(n,m)$ çš„æ¨å¯¼ï¼š\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} S(n,m) \u0026amp; = \\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)=k]\\\\ \u0026amp; = \\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(\\frac{i}{k},\\frac{i}{k})=1]\\\\ \u0026amp; = \\sum_{i=1}^{\\floor{\\frac{n}{k}}} \\sum_{j=1}^{\\floor{\\frac{m}{k}}} [\\gcd(i,j)=1]\\\\ \\end{aligned} $$\næ³¨æ„åˆ° $[\\gcd(i,j)=1]$ ä¸ $\\epsilon(\\gcd(i,j))$ ç­‰ä»·ï¼Œç”¨ $\\epsilon(\\gcd(i,j))$ æ›¿æ¢ï¼š\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} S(n,m) \u0026amp; = \\sum_{i=1}^{\\floor{\\frac{n}{k}}} \\sum_{j=1}^{\\floor{\\frac{m}{k}}} [\\gcd(i,j)=1]\\\\ \u0026amp; = \\sum_{i=1}^{\\floor{\\frac{n}{k}}} \\sum_{j=1}^{\\floor{\\frac{m}{k}}} \\epsilon(\\gcd(i,j))\\\\ \u0026amp; = \\sum_{i=1}^{\\floor{\\frac{n}{k}}} \\sum_{j=1}^{\\floor{\\frac{m}{k}}} \\sum_{d\\mid \\gcd(i,j)} \\mu(d)\\\\ \\end{aligned} $$\nå˜æ¢æ±‚å’Œé¡ºåºï¼Œå…ˆæšä¸¾ $d$ï¼Œåˆ™ $d\\mid \\gcd(i,j)$ï¼Œä¹Ÿå°±æ˜¯ $d\\mid i \\wedge d\\mid j$ï¼Œåˆ™åç»­æšä¸¾ $i,j$ ä¹Ÿè¦æ»¡è¶³èƒ½å¤Ÿè¢« $d$ æ•´é™¤ï¼š\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} S(n,m) \u0026amp; = \\sum_{i=1}^{\\floor{\\frac{n}{k}}} \\sum_{j=1}^{\\floor{\\frac{m}{k}}} \\sum_{d\\mid \\gcd(i,j)} \\mu(d)\\\\ \u0026amp; = \\sum_{d=1}^{\\min\\left(\\floor{\\frac{n}{k}},\\floor{\\frac{m}{k}}\\right)} \\mu(d) \\sum_{i=1}^{\\floor{\\frac{n}{k}}} [d\\mid i]\\sum_{j=1}^{\\floor{\\frac{m}{k}}} [d\\mid j]\\\\ \u0026amp; = \\sum_{d=1}^{\\min\\left(\\floor{\\frac{n}{k}},\\floor{\\frac{m}{k}}\\right)} \\mu(d) \\floor{\\frac{\\floor{\\frac{n}{k}}}{d}} \\floor{\\frac{\\floor{\\frac{m}{k}}}{d}}\\\\ \u0026amp; = \\sum_{d=1}^{\\min\\left(\\floor{\\frac{n}{k}},\\floor{\\frac{m}{k}}\\right)} \\mu(d) \\floor{\\frac{n}{dk}} \\floor{\\frac{m}{dk}}\\\\ \\end{aligned} $$\nåé¢çš„ $\\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\floor{\\frac{n}{dk}} \\floor{\\frac{m}{dk}}$ ç”¨æ•°è®ºåˆ†å—ä¼˜åŒ–ï¼Œè¿™ä¸ªå¼å­å°±ä»…æœ‰ $O(\\sqrt{n}+\\sqrt{m})$ ç§å–å€¼ï¼Œä¸”ç›¸åŒçš„å–å€¼éƒ½åœ¨è¿ç»­çš„ä¸€æ®µåŒºé—´ï¼Œæ‰€ä»¥å¯ä»¥é¢„å¤„ç† $\\sum_{d=1}^{\\min(n,m)} \\mu(d)$ï¼Œæ¯ä¸€æ®µåŒºé—´å°±æ˜¯ $\\mu(d)$ çš„åŒºé—´å’Œä¹˜åé¢çš„å¼å­ã€‚\nè®¤ä¸º $a,b,c,d$ åŒé˜¶ï¼Œåˆ™æ—¶é—´å¤æ‚åº¦ $O(a+n\\sqrt{a})$ã€‚\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAX_N = 5e4; int n, t, mu[MAX_N + 10], prime[MAX_N + 10], notPrime[MAX_N + 10]; void sieve(int n) { mu[1] = 1; notPrime[1] = 1; for (int i = 1; i \u0026lt;= n; ++i) { if (!notPrime[i]) { prime[++t] = i; mu[i] = -1; } for (int j = 1; j \u0026lt;= t; ++j) { if (i * prime[j] \u0026gt; n) break; notPrime[i * prime[j]] = true; mu[i * prime[j]] = i % prime[j] == 0 ? 0 : -mu[i]; if (i % prime[j] == 0) break; } } for (int i = 1; i \u0026lt;= n; ++i) mu[i] += mu[i - 1]; } // è¿™é‡Œå…¶å®ç®—çš„æ˜¯ gcd(i, j) = 1 çš„ä¸ªæ•° // ä¹Ÿå°±æ˜¯ S(n, m) = calc(n / k, m / k) int calc(int n, int m) { int res = 0; for (int l = 1, r; l \u0026lt;= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); res += (mu[r] - mu[l - 1]) * (n / l) * (m / l); } return res; } int main() { sieve(); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { int a, b, c, d, k, res = 0; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d \u0026gt;\u0026gt; k; res += calc(b / k, d / k); res -= calc(b / k, (c - 1) / k); res -= calc((a - 1) / k, d / k); res += calc((a - 1) / k, (c - 1) / k); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } return 0; }  Luogu P2257 YY çš„ GCD  ç»™å‡º $n,m$ï¼Œæ±‚æ»¡è¶³ $1\\le x\\le n,1\\le y\\le m$ ä¸” $\\gcd(x,y)$ ä¸ºè´¨æ•°çš„æœ‰åºæ•°å¯¹ $(x,y)$ ä¸ªæ•°ã€‚\næœ‰ $t$ ç»„æ•°æ®ï¼Œ$1\\le t\\le 10^4$ï¼Œ$1\\le n,m\\le 10^7$ã€‚\n è®¾è´¨æ•°é›†ä¸º $\\mathrm{P}$ï¼Œåˆ™æˆ‘ä»¬è¦æ±‚å‡ºä»¥ä¸‹å¼å­ï¼š\n$$ \\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)\\in \\mathrm{P}] $$\nè€ƒè™‘æšä¸¾ $p=\\gcd(i,j) \\in \\mathrm{P}$ï¼Œåˆ™ï¼š\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} \\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)\\in \\mathrm{P}] \u0026amp; = \\sum_{p\\in \\mathrm{P}} \\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j) = p]\\\\ \u0026amp; = \\sum_{p\\in \\mathrm{P}} \\sum_{d=1}^{\\min\\left(\\floor{\\frac{n}{p}},\\floor{\\frac{m}{p}}\\right)} \\mu(d) \\floor{\\frac{n}{dp}} \\floor{\\frac{m}{dp}} \\end{aligned} $$\nè¿™æ ·å­åšç»å¯¹ä¼š TLEï¼Œå› ä¸ºå¦‚æœä½¿ç”¨è¿™ä¸ªå½¢å¼è¿›è¡Œè®¡ç®—ï¼Œå¿…é¡»è¦æšä¸¾ $p$ï¼Œæ‰€ä»¥è¿›è¡Œä¼˜åŒ–ï¼Œè®¾ $t=dp$ï¼Œåˆ™ $d=\\frac{t}{p}$ï¼Œæ‰€ä»¥å¼å­å˜æˆè¿™æ ·ï¼š\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} \\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)\\in \\mathrm{P}] \u0026amp; = \\sum_{p\\in \\mathrm{P}} \\sum_{d=1}^{\\min\\left(\\floor{\\frac{n}{p}},\\floor{\\frac{m}{p}}\\right)} \\mu(d) \\floor{\\frac{n}{dp}} \\floor{\\frac{m}{dp}}\\\\ \u0026amp; = \\sum_{p\\in \\mathrm{P}} \\sum_{p\\mid t} \\mu(\\frac{t}{p}) \\floor{\\frac{n}{t}} \\floor{\\frac{m}{t}}\\\\ \u0026amp; = \\sum_{t=1}^{\\min(n,m)} \\floor{\\frac{n}{t}} \\floor{\\frac{m}{t}} \\sum_{p \\mid t} \\mu(\\frac{t}{p}) \\end{aligned} $$\nå¯ä»¥æŠŠåé¢çš„ $\\sum_{p \\mid t} \\mu(\\frac{t}{p})$ çœ‹æˆä¸€ä¸ªä¸ $t$ æœ‰å…³çš„å‡½æ•°ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡æšä¸¾æ¯ä¸ªè´¨æ•° $p$ï¼Œè®©å®ƒå»è´¡çŒ®å®ƒçš„æ¯ä¸€ä¸ªå€æ•°ï¼Œè¿™ä¸ªå¯ä»¥ $O(n \\log_2 n)$ é¢„å¤„ç†ï¼Œå† $O(n)$ é¢„å¤„ç†å‰ç¼€å’Œï¼Œç„¶åæ¯æ¬¡è¯¢é—®å°±å¯ä»¥ç›´æ¥æ•°è®ºåˆ†å—äº†ã€‚\nåŒæ ·è®¤ä¸º $n,m$ åŒé˜¶ï¼Œåˆ™æ—¶é—´å¤æ‚åº¦ $O(n \\log_2 n+t\\sqrt{n})$ã€‚\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAX_N = 1e7 + 10; int prime[MAX_N], notPrime[MAX_N], mu[MAX_N]; long long sum[MAX_N]; int n, m, t, l; void sieve() { notPrime[0] = notPrime[1] = true; mu[1] = 1; for (int i = 2; i \u0026lt; MAX_N; ++i) { if (!notPrime[i]) { prime[++l] = i; mu[i] = -1; } for (int j = 1; j \u0026lt;= l; ++j) { if (i * prime[j] \u0026gt; MAX_N - 1) break; notPrime[i * prime[j]] = true; mu[i * prime[j]] = i % prime[j] ? -mu[i] : 0; if (i % prime[j] == 0) break; } } for (int i = 1; i \u0026lt;= l; ++i) for (int j = 1; prime[i] * j \u0026lt; MAX_N; ++j) sum[prime[i] * j] += mu[j]; for (int i = 2; i \u0026lt; MAX_N; ++i) sum[i] += sum[i - 1]; } long long calc(int n, int m) { long long res = 0; for (int l = 1, r; l \u0026lt;= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); res += (sum[r] - sum[l - 1]) * (n / l) * (m / l); } return res; } int main() { sieve(); cin \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= t; ++i) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; cout \u0026lt;\u0026lt; calc(n, m) \u0026lt;\u0026lt; endl; } return 0; }  Luogu P3704 æ•°å­—è¡¨æ ¼  è®¾ $f_i$ ä¸ºæ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬ $i$ é¡¹ï¼Œæ±‚: $$ \\prod_{i=1}^{n} \\prod_{j=1}^{m} f_{\\gcd(i,j)} \\bmod (10^9+7) $$\n$t$ ç»„æ•°æ®ï¼Œ$1\\le t\\le 10^3$ï¼Œ$1\\le n,m\\le 10^6$ã€‚\n å…ˆæšä¸¾ $d$ ä½œä¸º $\\gcd(i,j)$ï¼Œè€ƒè™‘æ¯ä¸ª $f(d)$ ä¼šè¢«ä¹˜å‡ æ¬¡ï¼Œä¹Ÿå°±æ˜¯æŠŠå¼å­åŒ–æˆè¿™æ ·ï¼š\n$$ \\prod_{d=1}^{\\min(n,m)} f(d)^{\\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)=d]} $$\né¦–å…ˆå¯ä»¥åŒ–ç®€æŒ‡æ•°ï¼Œè®¾æŒ‡æ•°ä¸º $t(d)$ï¼š\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} t(d)=\\sum_{k=1}^{\\min\\left(\\floor{\\frac{n}{d}},\\floor{\\frac{m}{d}}\\right)} \\mu(k) \\floor{\\frac{n}{dk}} \\floor{\\frac{m}{dk}}\\\\ \\prod_{d=1}^{\\min(n,m)} f(d)^{\\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)=d]} = \\prod_{d=1}^{\\min(n,m)} f(d)^{t(d)}\\\\ $$\nç°åœ¨å·²ç»å¯ä»¥ä½¿ç”¨æ•°è®ºåˆ†å—å¥—æ•°è®ºåˆ†å— A äº†è¿™é“é¢˜äº†ï¼Œåªè¦å†é¢„å¤„ç†ä¸€ä¸ªå‰ç¼€ç§¯åŠå…¶é€†å…ƒï¼Œæ—¶é—´å¤æ‚åº¦ $O(n+tn^{\\frac{3}{4}}\\log_2 n)$ã€‚ä½ æ²¡æœ‰çœ‹é”™ï¼Œå¯ä»¥ $\\Theta(n)$ é¢„å¤„ç†æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å‰ç¼€ç§¯çš„é€†å…ƒã€‚\nè¿™ä¸ªç®—æ³•è·‘å¾—å·¨æ…¢ï¼Œå®ç°ä¸å¥½å°±ä¼š TLEã€‚è¿›è¡Œç”¨ä¸Šé¢çš„æŠ€å·§è¿›è¡Œä¼˜åŒ–ï¼Œè®¾ $p=dk$ï¼Œåˆ™ $k=\\frac{p}{d}$ï¼Œåˆ™ï¼š\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} t(d) = \\sum_{d\\mid p} \\mu(\\frac{p}{d}) \\floor{\\frac{n}{p}} \\floor{\\frac{m}{p}} $$\nå…ˆæšä¸¾ $p$ï¼Œç°åœ¨ $p$ ä»æŒ‡æ•°ä¸Šå˜åˆ°äº†åº•æ•°ä¸Šï¼Œæ‰€ä»¥åŠ å˜ä¸ºä¹˜ï¼Œä¹Ÿå°±æ˜¯å˜æ¢æ±‚ç§¯é¡ºåºï¼š\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} \\prod_{d=1}^{\\min(n,m)} f(d)^{t(d)} \u0026amp; = \\prod_{p=1}^{\\min(n,m)} \\prod_{d\\mid p} f(d)^{\\mu(\\frac{p}{d}) \\floor{\\frac{n}{p}} \\floor{\\frac{m}{p}}}\\\\ \u0026amp; = \\prod_{p=1}^{\\min(n,m)} \\left(\\prod_{d\\mid p} f(d)^{\\mu(\\frac{p}{d})}\\right)^{\\floor{\\frac{n}{p}} \\floor{\\frac{m}{p}}} \\end{aligned} $$\næ‰€ä»¥ç°åœ¨åªè¦é¢„å¤„ç†å‡º $\\prod_{d\\mid p} f(d)^{\\mu(\\frac{p}{d})}$ï¼Œå†åšå‰ç¼€ç§¯ï¼Œå¾ˆæ˜æ˜¾å¯ä»¥ $O(n\\log_2 n)$ é¢„å¤„ç†è¿™ä¸ªå¼å­ï¼Œç”¨ä¸Šæ–‡çš„è´¡çŒ®æ³•å®ç°å³å¯ã€‚\nè‡³äºæ±‚æ–æ³¢é‚£å¥‘æ•°åˆ—å‰ç¼€ç§¯çš„é€†å…ƒçš„æ–¹æ³•ï¼Œå…¶å®é€‚ç”¨äºä»»æ„çš„æ­£æ•´æ•°åºåˆ—ã€‚å…·ä½“å¯ä»¥çœ‹è¿™é‡Œã€‚\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAX_N = 1e6 + 10; constexpr int MOD = 1e9 + 7; int t, n, m; int prime[MAX_N], mu[MAX_N], tot; bool notPrime[MAX_N]; int fib[MAX_N], ifib[MAX_N]; int prod[MAX_N], iprod[MAX_N]; int tmp[MAX_N]; int power(int x, int y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % MOD; x = 1ll * x * x % MOD; } return res; } void preprocessMu(int n) { notPrime[1] = true; mu[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; mu[i] = -1; } for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * prime[j] \u0026lt;= n; ++j) { notPrime[i * prime[j]] = true; if (i % prime[j]) { mu[i * prime[j]] = -mu[i]; } else { mu[i * prime[j]] = 0; break; } } } } void preprocessFib(int n) { fib[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) fib[i] = (fib[i - 1] + fib[i - 2]) % MOD; tmp[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) tmp[i] = 1ll * tmp[i - 1] * fib[i] % MOD; int itmp = power(tmp[n], MOD - 2); for (int i = n; i \u0026gt;= 1; --i) { ifib[i] = 1ll * itmp * tmp[i - 1] % MOD; itmp = 1ll * itmp * fib[i] % MOD; } } void preprocessProd(int n) { for (int i = 1; i \u0026lt;= n; ++i) prod[i] = 1; for (int i = 1; i \u0026lt;= n; ++i) { if (!mu[i]) continue; if (mu[i] == 1) { for (int j = i, k = 1; j \u0026lt;= n; j += i, ++k) prod[j] = 1ll * prod[j] * fib[k] % MOD; } else { for (int j = i, k = 1; j \u0026lt;= n; j += i, ++k) prod[j] = 1ll * prod[j] * ifib[k] % MOD; } } prod[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { tmp[i] = prod[i]; prod[i] = 1ll * prod[i - 1] * prod[i] % MOD; } iprod[n] = power(prod[n], MOD - 2); for (int i = n - 1; i \u0026gt;= 0; --i) iprod[i] = 1ll * iprod[i + 1] * tmp[i + 1] % MOD; } void solve() { int res = 1; for (int l = 1, r; l \u0026lt;= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); res = 1ll * res * power(1ll * prod[r] * iprod[l - 1] % MOD, 1ll * (n / l) * (m / l) % (MOD - 1)) % MOD; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(false); preprocessMu(MAX_N - 10); preprocessFib(MAX_N - 10); preprocessProd(MAX_N - 10); cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; solve(); } return 0; }  SPOJ GCDMAT GCD OF MATRIX  ç»™å‡º $n,m$ï¼Œå¹¶ç»™å‡º $t$ ç»„è¯¢é—®ï¼Œæ¯ç»„è¯¢é—®ç»™å‡º $i_1,j_1,i_2,j_2$ï¼Œæ±‚ï¼š $$ \\sum_{i=i_1}^{i_2} \\sum_{j=j_1}^{j_2} \\gcd(i,j) $$\n$1\\le t\\le 500$ï¼Œ$1\\le n,m\\le 5\\times 10^4$ï¼Œ$1\\le i_1\\le i_2 \\le n$ï¼Œ$1\\le j_1\\le j_2 \\le m$ã€‚\n å…ˆè®¾ $S(n,m)=\\sum_{i=1}^{n} \\sum_{i=1}^{m} \\gcd(i,j)$ï¼Œè¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¥—è·¯çš„å¼å­ï¼Œç”¨åˆ°äº† $\\varphi = \\mu * id$ çš„ç»“è®ºï¼š\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} S(n,m) \u0026amp; = \\sum_{d=1}^{\\min(n,m)} d \\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)=d]\\\\ \u0026amp; = \\sum_{d=1}^{\\min(n,m)} d \\sum_{k=1}^{\\min\\left(\\floor{\\frac{n}{d}},\\floor{\\frac{m}{d}}\\right)} \\mu(k) \\floor{\\frac{n}{dk}} \\floor{\\frac{m}{dk}}\\\\ \\end{aligned} $$\nè®¾ $p=dk$ï¼š\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} S(n,m) \u0026amp; = \\sum_{d=1}^{\\min(n,m)} d \\sum_{k=1}^{\\min\\left(\\floor{\\frac{n}{d}},\\floor{\\frac{m}{d}}\\right)} \\mu(k) \\floor{\\frac{n}{dk}} \\floor{\\frac{m}{dk}}\\\\ \u0026amp; = \\sum_{d}^{\\min(n,m)} d \\sum_{d \\mid p} \\mu(\\frac{p}{d}) \\floor{\\frac{n}{p}}\\floor{\\frac{m}{p}}\\\\ \u0026amp; = \\sum_{p=1}^{\\min(n,m)} \\floor{\\frac{n}{p}}\\floor{\\frac{m}{p}} \\sum_{d \\mid p} \\mu(\\frac{p}{d}) d \\\\ \u0026amp; = \\sum_{p=1}^{\\min(n,m)} \\varphi(p) \\floor{\\frac{n}{p}}\\floor{\\frac{m}{p}} \\end{aligned} $$\næ—¶é—´å¤æ‚åº¦ $O(n+t\\sqrt{n})$ã€‚\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAX_N = 1e6 + 10; constexpr int MOD = 1e9 + 7; int t, n, m, i1, i2, j1, j2; int prime[MAX_N], phi[MAX_N], tot; bool notPrime[MAX_N]; void preprocess(int n) { notPrime[1] = 1; phi[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; phi[i] = i - 1; } for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * prime[j] \u0026lt;= n; ++j) { notPrime[i * prime[j]] = true; if (i % prime[j]) { phi[i * prime[j]] = phi[i] * (prime[j] - 1); } else { phi[i * prime[j]] = phi[i] * prime[j]; break; } } } for (int i = 2; i \u0026lt;= n; ++i) { phi[i] = phi[i - 1] + phi[i]; if (phi[i] \u0026gt;= MOD) phi[i] -= MOD; } } int calc(int n, int m) { int res = 0; for (int l = 1, r, e = min(n, m), val; l \u0026lt;= e; l = r + 1) { r = min(n / (n / l), m / (m / l)); val = 1ll * (n / l) * (m / l) % MOD; res = (res + 1ll * (phi[r] - phi[l - 1] + MOD) * val) % MOD; } return res; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; t; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; preprocess(min(n, m)); while (t--) { cin \u0026gt;\u0026gt; i1 \u0026gt;\u0026gt; j1 \u0026gt;\u0026gt; i2 \u0026gt;\u0026gt; j2; long long ans = calc(i2, j2); ans -= calc(i1 - 1, j2); ans -= calc(i2, j1 - 1); ans += calc(i1 - 1, j1 - 1); cout \u0026lt;\u0026lt; (ans % MOD + MOD) % MOD \u0026lt;\u0026lt; endl; } return 0; }  Luogu P6156 ç®€å•é¢˜  ç»™å‡º $n, k$ï¼Œæ±‚ï¼š $$ \\sum_{i=1}^{n} \\sum_{j=1}^{n} (i+j)^k f(\\gcd(i,j)) \\gcd(i,j)\\\\ f(n) = \\begin{cases} 0 \u0026amp; \\exists\\ p^2 \\mid n \\wedge p\u0026gt;1\\\\ 1 \u0026amp; \\text{otherwise} \\end{cases} $$\n$1\\le n\\le 5\\times 10^6$ï¼Œ$1\\le k\\le 10^{18}$ã€‚\n é¦–å…ˆå®¹æ˜“å‘ç° $f(n)=\\mu^2(n)$ã€‚è®¾ç­”æ¡ˆä¸º $\\text{ans}$ï¼Œå…ˆæšä¸¾ $d=\\gcd(i,j)$ï¼š\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} \\text{ans} \u0026amp; = \\sum_{i=1}^{n} \\sum_{j=1}^{n} (i+j)^k \\mu^2(\\gcd(i,j)) \\gcd(i,j)\\\\ \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d \\sum_{i=1}^{n} \\sum_{j=1}^{n} (i+j)^k [\\gcd(i,j)=d]\\\\ \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d^{k+1} \\sum_{i=1}^{n} \\sum_{j=1}^{n} (\\frac{i}{d}+\\frac{j}{d})^k [\\gcd(\\frac{i}{d},\\frac{j}{d})=1]\\\\ \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d^{k+1} \\sum_{i=1}^{\\floor{\\frac{n}{d}}} \\sum_{j=1}^{\\floor{\\frac{n}{d}}} (i+j)^k [\\gcd(i,j)=1]\\\\ \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d^{k+1} \\sum_{t=1}^{\\floor{\\frac{n}{d}}}\\mu(t) \\sum_{i=1}^{\\floor{\\frac{n}{d}}} \\sum_{j=1}^{\\floor{\\frac{n}{d}}} (i+j)^k [t\\mid i][t\\mid j]\\\\ \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d^{k+1} \\sum_{t=1}^{\\floor{\\frac{n}{d}}}\\mu(t) t^k \\sum_{i=1}^{\\floor{\\frac{n}{d}}} \\sum_{j=1}^{\\floor{\\frac{n}{d}}} (\\frac{i}{t}+\\frac{j}{t})^k [t\\mid i][t\\mid j]\\\\ \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d^{k+1} \\sum_{t=1}^{\\floor{\\frac{n}{d}}}\\mu(t) t^k \\sum_{i=1}^{\\floor{\\frac{n}{dt}}} \\sum_{j=1}^{\\floor{\\frac{n}{dt}}} (i+j)^k\\\\ \\end{aligned} $$\nè®¾ $f(n) = \\sum_{i=1}^{n} \\sum_{j=1}^{n} (i+j)^k$ï¼Œ$p=dt$ï¼š\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} \\text{ans} \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d^{k+1} \\sum_{t=1}^{\\floor{\\frac{n}{d}}}\\mu(t) t^k \\sum_{i=1}^{\\floor{\\frac{n}{dt}}} \\sum_{j=1}^{\\floor{\\frac{n}{dt}}} (i+j)^k\\\\ \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d^{k+1} \\sum_{t=1}^{\\floor{\\frac{n}{d}}}\\mu(t) t^k f\\left(\\floor{\\frac{n}{dt}}\\right)\\\\ \u0026amp; = \\sum_{p=1}^{n} f\\left(\\floor{\\frac{n}{p}}\\right) \\sum_{d\\mid p} \\mu^2(d) \\mu\\left(\\frac{p}{d}\\right) d^{k+1} \\left(\\frac{p}{d}\\right)^k\\\\ \u0026amp; = \\sum_{p=1}^{n} f\\left(\\floor{\\frac{n}{p}}\\right) p^k \\sum_{d\\mid p} \\mu^2(d) \\mu\\left(\\frac{p}{d}\\right) d \\end{aligned} $$\nè®¾ $g(n)=\\sum_{d\\mid n} \\mu^2(d) \\mu\\left(\\frac{n}{d}\\right) d$ï¼š\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} \\text{ans} \u0026amp; = \\sum_{p=1}^{n} f\\left(\\floor{\\frac{n}{p}}\\right) g(p) p^k\\\\ \u0026amp; = \\sum_{p=1}^{n} f\\left(\\floor{\\frac{n}{p}}\\right) g(p) id_k(p) \\end{aligned} $$\nè¿™ä¸ªå¼å­å½“ä¸­ï¼Œå‡ºç°äº†ä¸‰ä¸ªå‡½æ•°ï¼Œä¾æ¬¡è€ƒè™‘æ€ä¹ˆæ±‚å®ƒä»¬ã€‚\næ±‚ $f(n)$ å¯¹äº $f(n) = \\sum_{i=1}^{n} \\sum_{j=1}^{n} (i+j)^k$ï¼Œæœ‰ä¸¤ç§æ–¹æ³•ï¼š\næ–¹æ³• 1\nè€ƒè™‘ä½œä¸ºåº•æ•°çš„ $i+j$ çš„æ¯ä¸ªå€¼å‡ºç°äº†å¤šå°‘æ¬¡ï¼Œ$i+j\\in [2,2n]$ï¼Œä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬æŠŠ $1$ ä¹Ÿç®—è¿›å»ï¼Œæ‰“è¡¨å‘ç°æ¯ä¸ªå€¼çš„å‡ºç°æ¬¡æ•°æ»¡è¶³å¦‚ä¸‹å‡½æ•°å…³ç³»ï¼š\n$$ cnt(i)= \\begin{cases} i-1 \u0026amp; i \\le n+1\\\\ 2n-i+1 \u0026amp; i \u0026gt; n+1 \\end{cases} $$\näºæ˜¯è®¾ $pre[i]=\\sum_{j=1}^{i} (j-1)j^k$ï¼Œ$suf[i]=\\sum_{j=i}^{2n} (2n-j+1)j^k$ï¼Œ$sum[i]=\\sum_{j=1}^{i} j^k$ï¼Œåˆ™ï¼š\n$$ f(i)=pre[i+1]+(suf[i+2]-suf[2i+1])-(2n-2i)(sum[2i]-sum[i+1]) $$\nå¯ä»¥çœ‹æˆä»¥ $i+1$ ä¸ºåˆ†ç•Œï¼Œå‰é¢çš„ç”¨ $pre[i+1]$ï¼Œåé¢å…ˆç”¨ $suf[i+2]-suf[2i+1]$ ç®—å‡ºåœ¨ $[i+2,2i]$ ä¸­çš„å’Œï¼Œå› ä¸º $suf[i]$ ä»¥ $2n$ ä¸ºå‚è€ƒï¼Œè¿˜åŒ…å« $[i+1,2n]$ ä¸­çš„å€¼ï¼Œç°åœ¨ä»¥ $2i$ ä¸ºå‚è€ƒï¼Œæ‰€ä»¥ä¼šå¤šç®— $(2n-2i)(sum[2i]-sum[i+1])$ã€‚\næ–¹æ³• 2\nä¸Šè¿°å¼å­æœ‰æ›´ç®€å•çš„è¡¨ç¤ºæ–¹æ³•ï¼Œè®¾ $s_1(n)=\\sum_{i=1}^{n} i^k$ï¼Œ$s_2(n)=\\sum_{i=1}^{n}s_1(i)$ï¼Œåˆ™ $f(n)=s_2(2n)-2s_2(n)$ï¼Œè¯æ˜çœç•¥ï¼Œäº‹å®è¯æ˜æ–¹æ³• 1 æ›´å®¹æ˜“å‘ç°ã€‚\nä¸¤ç§æ–¹æ³•é¢„å¤„ç†çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ $\\Theta(n)$ã€‚\næ±‚ $g(n)$ æ ¹æ®ç§¯æ€§å‡½æ•°çš„åˆ¤æ–­æ€§è´¨ï¼šè‹¥ $f(n),g(n)$ å‡ä¸ºç§¯æ€§å‡½æ•°ï¼Œåˆ™ä¸‹åˆ—å‡½æ•°ä¹Ÿä¸ºç§¯æ€§å‡½æ•°ï¼š\n$$ h_1(n)=f(n)g(n)\\\\ h_2(n)=\\sum_{d\\mid n} f(\\frac{n}{d}) g(d) $$\nåˆ†æ $g(n)=\\sum_{d\\mid n} \\mu^2(d) \\mu\\left(\\frac{n}{d}\\right) d$ çš„è¡¨è¾¾å¼ï¼š$g(n)$ æ˜¯ $\\mu^2(n)n$ å’Œ $\\mu(n)$ çš„ Dirchlet å·ç§¯ï¼Œ$\\mu^2(n)n$ ç”±ä¸‰ä¸ªå‡½æ•° $\\mu(n),\\mu(n),n$ ä¸‰ä¸ªå‡½æ•°ç›¸ä¹˜å¾—åˆ°ï¼Œæ•… $g(n)$ ä¸ºç§¯æ€§å‡½æ•°ã€‚\nåˆ†æ $g(n)$ çš„æ€§è´¨ï¼Œå¯ä»¥å…ˆä» $g(p^k)$ çš„å€¼å…¥æ‰‹ï¼Œå…¶ä¸­ $p$ ä¸ºè´¨æ•°ï¼š\n $k=0$ï¼Œåˆ™ $g(p^k)=g(1)=\\mu^3(1)=1$ $k=1$ï¼Œåˆ™ $g(p^k)=g(p)=\\mu^2(1)\\mu(p)+\\mu^2(p)\\mu(1)p=p-1$ $k=2$ï¼Œåˆ™ $g(p^k)=g(p^2)=\\mu^2(1)\\mu(p^2)+\\mu^2(p)\\mu(p)p+\\mu^2(p^2)\\mu(1)=-p$ $k\\ge 3$ï¼Œæ ¹æ®æŠ½å±‰åŸç†ï¼Œ$d$ å’Œ $\\frac{p^k}{d}$ ä¸­è‡³å°‘æœ‰ä¸€ä¸ªçš„ $p$ çš„æŒ‡æ•°å¤§äº $1$ï¼Œæ•… $\\mu^2(d)$ å’Œ $\\mu\\left(\\frac{p^k}{d}\\right)$ è‡³å°‘æœ‰ä¸€ä¸ªä¸º $0$ï¼Œç›¸ä¹˜å $g(p^k)=0$  æ‰€ä»¥åœ¨æ¬§æ‹‰ç­›æ—¶æ ¹æ® $i\\cdot prime[j]$ ä¸ $prime[j]$ çš„å…³ç³»è¿›è¡Œè®¡ç®—å³å¯ã€‚æ—¶é—´å¤æ‚åº¦ $\\Theta(n)$ã€‚\næ±‚ $id_k(n)$ å†è€ƒè™‘æ±‚ $id_k(n)$ï¼Œè¿™æ˜¯ä¸ªå®Œå…¨ç§¯æ€§å‡½æ•°ï¼Œæ‰€ä»¥éšä¾¿ç­›ä¸€ä¸‹å°±å¯ä»¥äº†ï¼Œæ¯”å¦‚åœ¨é‡åˆ°è´¨æ•° $p$ æ—¶ç”¨å¿«é€Ÿå¹‚æ±‚ä¸€ä¸‹ $id_k(p)$ï¼Œå…¶ä»–æ—¶å€™å°±ä»¤ $id_k(i\\cdot prime[j])=id_k(i)id_k(prime[j])$ å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ $\\Theta(n+\\pi(n)\\log_2 k)\\approx \\Theta(n)$ã€‚\nç„¶åé¢„å¤„ç†ä¸€ä¸‹ $g(n)id_k(n)$ çš„å‰ç¼€å’Œï¼Œæ•°è®ºåˆ†å—æ±‚è§£å³å¯ï¼Œæ€»æ—¶é—´å¤æ‚åº¦ $O(n+\\sqrt{n})$ã€‚è¿™ç§æ–¹æ³•ä¹Ÿå¯ä»¥é€šè¿‡ $1\\le n\\le 10^7$ + å¤šç»„è¯¢é—®çš„åŠ å¼ºç‰ˆã€‚\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAX_N = 5e6 + 10; constexpr int MAX_SIZE = 1e7 + 10; constexpr int MOD = 998244353; int n; long long k; int prime[MAX_SIZE], tot; bool notPrime[MAX_SIZE]; int prod[MAX_SIZE], f[MAX_N], g[MAX_SIZE], sum[MAX_N]; int fPre[MAX_SIZE], fSuf[MAX_SIZE], fSum[MAX_SIZE]; int ans; int power(int x, long long y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % MOD; x = 1ll * x * x % MOD; } return res; } void sieve(int n) { n *= 2; prod[1] = 1; g[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; prod[i] = power(i, k); g[i] = i - 1; } for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; 1ll * i * prime[j] \u0026lt;= n; ++j) { const int next = i * prime[j]; notPrime[next] = true; prod[next] = 1ll * prod[i] * prod[prime[j]] % MOD; if (i % prime[j]) { g[next] = g[i] * (prime[j] - 1); } else if ((i / prime[j]) % prime[j]) { g[next] = -g[i / prime[j]] * prime[j]; break; } else { g[next] = 0; break; } } } n /= 2; for (int i = 1; i \u0026lt;= n; ++i) { sum[i] = (sum[i - 1] + 1ll * prod[i] * g[i]) % MOD; sum[i] = (sum[i] + MOD) % MOD; } } void preprocess(int n) { for (int i = 1; i \u0026lt;= 2 * n; ++i) { fPre[i] = (fPre[i - 1] + 1ll * prod[i] * (i - 1)) % MOD; fSum[i] = (fSum[i - 1] + prod[i]) % MOD; } for (int i = 2 * n; i \u0026gt;= 1; --i) fSuf[i] = (fSuf[i + 1] + 1ll * prod[i] * (2 * n - i + 1)) % MOD; for (int i = 1; i \u0026lt;= n; ++i) { int mid = i + 1, res = 0; res = ((fPre[mid] + fSuf[mid + 1]) % MOD - fSuf[2 * i + 1]) % MOD; res = (res - 1ll * (2 * n - 2 * i) * (fSum[2 * i] - fSum[mid])) % MOD; res = (res + MOD) % MOD; f[i] = res; } } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; sieve(n); preprocess(n); for (int l = 1, r; l \u0026lt;= n; l = r + 1) { r = n / (n / l); ans = (ans + 1ll * (sum[r] - sum[l - 1] + MOD) * f[n / l]) % MOD; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  ","id":4,"section":"posts","summary":"è«æ¯”ä¹Œæ–¯åæ¼”å¯ä»¥ç”¨äºä¼˜åŒ–ä¸€ç±»å¼å­çš„è®¡ç®—ã€‚ è«æ¯”ä¹Œæ–¯å‡½æ•° å®šä¹‰ è«æ¯”ä¹Œæ–¯å‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ï¼š $$ \\mu(n)= \\begin{cases} 0 \u0026amp; \\exists\\ p^2 \\mid n \\wedge p\u0026gt;1\\\\ (-1)^k \u0026amp; n=\\prod_{i=1}^{k} p_i \\end{cases} $$ ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœ $n$ å«æœ‰å¹³æ–¹çº¦","tags":["OI","æ•°å­¦","æ•°è®º","è«æ¯”ä¹Œæ–¯åæ¼”","è«æ¯”ä¹Œæ–¯å‡½æ•°","æ•°è®ºåˆ†å—","ç§¯æ€§å‡½æ•°","ç­›æ³•","C++"],"title":"è«æ¯”ä¹Œæ–¯åæ¼”å­¦ä¹ ç¬”è®°","uri":"https://ctj12461.vercel.app/contents/20220220-mobius-inversion-note/","year":"2022"},{"content":"è§£å„ç§åŒä½™æ–¹ç¨‹æ˜¯åŒä½™é—®é¢˜çš„ä¸€ä¸ªé‡è¦éƒ¨åˆ†ï¼Œæœ¬æ–‡ä»‹ç»å„ç§åŒä½™æ–¹ç¨‹çš„æ±‚è§£æ–¹æ³•ã€‚\näºŒå…ƒçº¿æ€§ä¸å®šæ–¹ç¨‹ å½¢å¼ ä¸å®šæ–¹ç¨‹çš„èŒƒå›´å¾ˆå¹¿æ³›ï¼Œåªè¦æ²¡æœ‰ç¡®å®šçš„è§£çš„æ–¹ç¨‹éƒ½å¯ä»¥å«ä¸å®šæ–¹ç¨‹ã€‚æœ¬æ–‡ä¸»è¦è®¨è®ºæ•°è®ºä¸­çš„ä¸å®šæ–¹ç¨‹ã€‚\n$$ ax+by=c\\ (a,b,c,x,y\\in \\mathrm{Z}) $$\nå½¢å¦‚ä¸Šé¢è¿™ç§å½¢å¼ï¼Œæ»¡è¶³å„é¡¹çš„ç³»æ•°å’Œè§£å‡ä¸ºæ•´æ•°çš„æ–¹ç¨‹å°±æ˜¯æ•°è®ºä¸­çš„ä¸å®šæ–¹ç¨‹ã€‚\næ±‚è§£ Theorem 1ï¼š$\\forall a, b \\in \\mathrm{Z}$ï¼Œä¸€å®šå­˜åœ¨ $x,y\\in \\mathrm{Z}$ï¼Œä½¿å¾— $ax+by=\\gcd(a,b)$ã€‚\nè¿™ä¸ªå®šç†åˆå«åšè£´èœ€å®šç†ï¼Œæ ¹æ®è¿™ä¸ªå®šç†ï¼Œå¯ä»¥å¾—å‡ºä¸å®šæ–¹ç¨‹ $ax+by=c$ æœ‰è§£çš„å……è¦æ¡ä»¶å°±æ˜¯ $\\gcd(a,b)\\mid c$ã€‚è®° $d=\\gcd(a,b)$ï¼Œåˆ™æˆ‘ä»¬å¯ä»¥å…ˆæ±‚å‡º $ax\u0026rsquo;+by\u0026rsquo;=d$ çš„è§£ï¼Œå†ä»¤ $x=\\frac{c}{d}x\u0026rsquo;,y=\\frac{c}{d}y\u0026rsquo;$ï¼Œå°±å¾—å‡ºåŸæ–¹ç¨‹çš„ä¸€ç»„è§£ã€‚\næ±‚ $x\u0026rsquo;,y\u0026rsquo;$ çš„è¿‡ç¨‹å¯ä»¥ç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼Œå³ exgcd è§£å†³ã€‚\nTheorem 2ï¼šè‹¥ $\\gcd(a,b)=1$ï¼Œä¸” $x_0,y_0$ æ˜¯æ–¹ç¨‹ $ax+by=c$ çš„ä¸€ç»„è§£ï¼Œåˆ™è¯¥æ–¹ç¨‹çš„é€šè§£ä¸º $x=x_0+kb,y=y_0-ka$ï¼Œå…¶ä¸­ $k\\in \\mathrm{Z}$ã€‚\næ¢å¥è¯è¯´ï¼Œ$x,y$ è¿™ä¸¤ä¸ªè§£æ˜¯å…·æœ‰å‘¨æœŸæ€§çš„ã€‚æ ¹æ®è¿™ä¸ªå®šç†ï¼Œæˆ‘ä»¬çŸ¥é“ä¸€å®šæœ‰ä¸€ä¸ª $x\\in [0,b)$ï¼Œè€Œå¯¹äºæ–¹ç¨‹ $ax+by=c$ï¼Œåˆ™ä¸€å®šæœ‰ä¸€ä¸ª $x\\in [0,\\frac{b}{\\gcd(a,b)})$ï¼Œç”±æ­¤å¯ä»¥æ±‚ä¸€ä¸ªä¸å®šæ–¹ç¨‹çš„ä¸€ä¸ªå…ƒçš„æœ€å°éè´Ÿæ•´æ•°è§£ï¼Œå…·ä½“åœ°ï¼Œå‡è®¾çŸ¥é“äº†ä¸€ä¸ªè§£ $x_0$ï¼Œåˆ™æœ€å°éè´Ÿæ•´æ•° $x=(x_0 \\bmod m + m) \\bmod m$ï¼Œå…¶ä¸­ $m=\\frac{b}{\\gcd(a,b)}$ã€‚\næ€»ç»“ä¸€ä¸‹ï¼Œæ±‚è§£äºŒå…ƒçº¿æ€§ä¸å®šæ–¹ç¨‹ $ax+by=c$ çš„æµç¨‹å¦‚ä¸‹ï¼š\n æ±‚å‡º $ax+by=\\gcd(a,b)$ çš„ä¸€ç»„è§£ $x\u0026rsquo;,y\u0026rsquo;$ï¼Œå¹¶æ ¹æ® $\\gcd(a,b)\\mid c$ åˆ¤æ–­æ–¹ç¨‹æœ‰æ— è§£ ä»¤ $x=\\frac{c}{\\gcd(a,b)}x\u0026rsquo;,y=\\frac{c}{\\gcd(a,b)}y\u0026rsquo;$ï¼Œ$x,y$ ä¸º $ax+by=c$ çš„ä¸€ç»„è§£ è‹¥éœ€è¦æ±‚ $x$ çš„æœ€å°éè´Ÿæ•´æ•°è§£ï¼Œåˆ™å°† $x=(x_0 \\bmod m + m) \\bmod m$ ä½œä¸ºæœ€ç»ˆçš„ç­”æ¡ˆï¼Œå…¶ä¸­ $m=\\frac{b}{\\gcd(a,b)}$  çº¿æ€§åŒä½™æ–¹ç¨‹ å½¢å¼ $$ ax \\equiv c \\pmod{p} $$\nå½¢å¦‚è¿™æ ·çš„æ–¹ç¨‹ï¼Œå°±è¢«ç§°çº¿æ€§åŒä½™æ–¹ç¨‹ã€‚\næ±‚è§£ ä»»æ„çš„çº¿æ€§åŒä½™æ–¹ç¨‹éƒ½å¯ä»¥ä¸ä¸€ä¸ªäºŒå…ƒçº¿æ€§ä¸å®šæ–¹ç¨‹äº’ç›¸è½¬åŒ–ï¼Œæ¯”å¦‚ä¸Šé¢çš„æ–¹ç¨‹å°±ä¸äºŒå…ƒçº¿æ€§ä¸å®šæ–¹ç¨‹æœ‰å¦‚ä¸‹å…³ç³»ï¼š\n$$ ax \\equiv c \\pmod{p} \\iff ax+py=c $$\næ‰€ä»¥å¯ä»¥æŠŠçº¿æ€§åŒä½™æ–¹ç¨‹è½¬åŒ–ä¸ºä¸€ä¸ªäºŒå…ƒçº¿æ€§ä¸å®šæ–¹ç¨‹ï¼Œæ±‚å‡º $x$ å³å¯ï¼ŒåŒ…æ‹¬æœ‰æ— è§£çš„åˆ¤å®šæ¡ä»¶éƒ½æ˜¯ä¸€æ ·çš„ã€‚\nä»£ç  template \u0026lt;typename T\u0026gt; T exgcd(T a, T b, T \u0026amp; x, T \u0026amp; y) { if (b == 0) { x = 1; y = 0; return a; } else { T d = exgcd(b, a % b, x, y); T t = x; x = y; y = t - a / b * y; return d; } } template \u0026lt;typename T\u0026gt; optional\u0026lt;T\u0026gt; solveEquation(T a, T c, T p) { a = (a % p + p) % p; c = (c % p + p) % p; T x, y; T d = exgcd(a, p, x, y); if (c % d != 0) return nullopt; x = (1ll * (c / d) * x % (p / d) + (p / d)) % (p / d); return x; }  ä¸­å›½å‰©ä½™å®šç† å½¢å¼ $$ \\begin{cases} x \\equiv a_1 \\pmod{m_1}\\\\ x \\equiv a_2 \\pmod{m_2}\\\\ \\cdots\\\\ x \\equiv a_n \\pmod{m_n}\\\\ \\end{cases} \\\\ \\forall i\\ne j,\\gcd(m_i,m_j)=1 $$\nå½¢å¦‚ä¸Šé¢è¿™æ ·çš„çº¿æ€§åŒä½™æ–¹ç¨‹ç»„ä¸”æ»¡è¶³æ¯ä¸ªæ–¹ç¨‹çš„æ¨¡æ•°ä¸¤ä¸¤äº’è´¨ï¼Œå°±å¯ä»¥ç”¨ä¸­å›½å‰©ä½™å®šç†è§£å†³ã€‚ä¸­å›½å‰©ä½™å®šç†ä¹Ÿå«åš CRT (Chinese Remainder Theorem)ã€‚\næ±‚è§£  ä»¤ $M=\\prod_{i=1}^{n} m_i$ï¼Œ$M$ ä¸å¯¹ä»»ä½•æ•°å–æ¨¡ å¯¹äº $m_i$ï¼Œä»¤ $M_i=\\prod_{i\\ne j}m_j=\\frac{M}{m_i}$ï¼Œ$M_i^{-1}$ ä¸º $M_i$ å¯¹ $m_i$ çš„é€†å…ƒï¼Œ$c_i=M_iM_i^{-1}$ï¼Œ$c_i$ ä¸èƒ½å¯¹ $m_i$ å–æ¨¡ ä»¤ $x=\\sum_{i=1}^{n}a_ic_i \\bmod M$ï¼Œåˆ™ $x$ ä¸ºæ¨¡ $M$ æ„ä¹‰ä¸‹çš„å”¯ä¸€è§£  ç®—æ³•æ­£ç¡®æ€§è¯æ˜ å¯¹äº $\\forall i\\ne j$ï¼Œ$m_i\\mid M_j$ï¼Œæ•… $m_i\\mid a_jc_j$ï¼Œæ‰€ä»¥åœ¨æ¨¡ $m_i$ æƒ…å†µä¸‹ï¼Œ$x \\equiv a_ic_i \\pmod{m_i}$ã€‚\nå› ä¸º $M_i^{-1}$ ä¸º $M_i$ å¯¹ $m_i$ çš„é€†å…ƒï¼Œæ•…åœ¨æ¨¡ $m_i$ çš„åŒä½™å¼ä¸­ $c_i\\equiv 1 \\pmod{m_i}$ï¼Œ$a_ic_i\\equiv a_i \\pmod{m_i}$ï¼Œå³ $x \\equiv a_i \\pmod{m_i}$ï¼Œæ»¡è¶³ç¬¬ $i$ ä¸ªæ–¹ç¨‹ã€‚\nè§£åœ¨æ¨¡ $M$ æ„ä¹‰ä¸‹çš„å”¯ä¸€æ€§è¯æ˜ è®¾ $x,y$ ä¸ç›¸ç­‰ï¼Œ$x,y\u0026lt;M$ï¼Œä½†éƒ½æ»¡è¶³æ–¹ç¨‹ç»„ï¼Œåˆ™å¯ä»¥æœ‰ä¸‹é¢çš„æ–¹ç¨‹ç»„ï¼š\n$$ \\begin{cases} x - y\\equiv 0 \\pmod{m_1}\\\\ x - y\\equiv 0 \\pmod{m_2}\\\\ \\cdots\\\\ x - y\\equiv 0 \\pmod{m_n}\\\\ \\end{cases} $$\nåˆ™ $\\forall i,m_i\\mid |x-y|$ï¼Œæ‰€ä»¥ $M \\mid |x-y|$ï¼Œå³ $|x-y|=kM$ï¼Œå› ä¸º $|x-y|\u0026lt;M$ï¼Œæ•… $k=0$ï¼Œæ¨å‡º $x=y$ï¼Œä¸å‡è®¾çŸ›ç›¾ã€‚\nä»£ç  int exgcd(int a, int b, int \u0026amp; x, int \u0026amp; y) { if (b == 0) { x = 1; y = 0; return a; } else { int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - (a / b) * y; return d; } } int solveEquation(int a, int c, int p) { int x, y; exgcd(a, p, x, y); x = (1ll * x * c % p + p) % p; return x; } inline int inv(int x, int p) { return solveEquation(x, 1, p); } int chineseRemainderTheorem(int n, int a[], int m[]) { int mod = 1, ans = 0; for (int i = 1; i \u0026lt;= n; ++i) mod *= m[i]; for (int i = 1; i \u0026lt;= n; ++i) { int modi = mod / m[i]; ans = (ans + 1ll * a[i] * modi * inv(modi)) % mod; // ç”¨ exgcd æ±‚é€†å…ƒ } return ans; }  æ‰©å±•ä¸­å›½å‰©ä½™å®šç† å½¢å¼ $$ \\begin{cases} a_1 x \\equiv c_1 \\pmod{m_1}\\\\ a_2 x \\equiv c_2 \\pmod{m_2}\\\\ \\cdots\\\\ a_n x \\equiv c_n \\pmod{m_n}\\\\ \\end{cases} $$\nç›¸æ¯”æ™®é€šä¸­å›½å‰©ä½™å®šç†æ±‚è§£çš„æ–¹ç¨‹ç»„ï¼Œå°‘äº†æ¨¡æ•°äº’è´¨çš„é™åˆ¶ã€‚\næ±‚è§£ è€ƒè™‘åˆå¹¶æ–¹ç¨‹ã€‚è®¾å½“å‰è¦åˆå¹¶å‰ $i$ ä¸ªæ–¹ç¨‹ï¼Œæ˜¾ç„¶å¯ä»¥è½¬åŒ–ä¸ºåˆå¹¶å‰ $i-1$ ä¸ªæ–¹ç¨‹ä¸ç¬¬ $i$ ä¸ªæ–¹ç¨‹ã€‚\nè®¾ $x_i$ ä¸ºåˆå¹¶å‰ $i$ ä¸ªæ–¹ç¨‹çš„è§£ï¼Œ$d_i=\\operatorname{lcm}(m_1,m_2,\\dots,m_i)$ã€‚æ„é€  $x_i=sx_{i-1}+t$ï¼Œæˆ‘ä»¬è¦ä½¿ $x_i$ èƒ½å¤Ÿæ»¡è¶³å‰ $i-1$ ä¸ªæ–¹ç¨‹ï¼Œå°±è¦æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š\n $\\forall j \u0026lt; i$ï¼Œ$a_j(sx_{i-1}+t)\\equiv a_j x_{i-1} \\pmod{m_j}$ $a_i(sx_{i-1}+t) \\equiv c_i \\pmod{m_i}$  æœ€ç®€å•çš„åŠæ³•å°±æ˜¯ä»¤ $s=1,t=d_{i-1}y_i$ï¼Œå¹¶æ±‚ä¸€ä¸ªåˆé€‚çš„ $y_i$ï¼Œä¹Ÿå°±æ˜¯è¦æ±‚å‡ºä»¥ä¸‹æ–¹ç¨‹çš„è§£ $y_i$ï¼š $$ a_i d_{i-1}y_i \\equiv c_i - a_i x_{i-1} \\pmod{m_i} $$\nç”¨ exgcd è§£å†³ï¼Œè‹¥è¯¥çº¿æ€§åŒä½™æ–¹ç¨‹æ— è§£ï¼Œåˆ™æ–¹ç¨‹ç»„æ— è§£ï¼Œå¦åˆ™æ±‚å‡ºå‰ $i$ ä¸ªæ–¹ç¨‹çš„è§£ $x_i$ï¼Œè¿›è¡Œä¸‹ä¸€æ¬¡åˆå¹¶ã€‚\nå‡è®¾å„ä¸ª $m_i$ åŒé˜¶ï¼Œæ—¶é—´å¤æ‚åº¦ $O(n \\log_2 m_i)$ã€‚\nä»£ç  int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } int exgcd(int a, int b, int \u0026amp; x, int \u0026amp; y) { if (b == 0) { x = 1; y = 0; return a; } else { int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - (a / b) * y; return d; } } optional\u0026lt;int\u0026gt; solveEquation(int a, int c, int p) { a = (a % p + p) % p; c = (c % p + p) % p; int x, y, d = exgcd(a, p, x, y); if (c % d) return nullopt; x *= (c / d); int m = p / d; x = (x % m + m) % m; return x; } optional\u0026lt;int\u0026gt; exChineseRemainderTheorem(int n, int a[], int c[], int m[]) { int x = 0, d = 1; for (int i = 1; i \u0026lt;= n; ++i) { auto oy = solveEquation(a[i] * d, c[i] - a[i] * x, m[i]); if (!oy.has_value()) return nullopt; int y = oy.value(); int g = gcd(d, m[i]); d = d / g * m[i]; x = (x + 1ll * (d / m[i] * g) * y) % d; } return x; }  BSGS ç¦»æ•£å¯¹æ•° ä¸ç¦»æ•£å¯¹æ•°ç›¸å¯¹çš„æ˜¯æˆ‘ä»¬ç†Ÿæ‚‰çš„è¿ç»­å¯¹æ•°ï¼Œä¹Ÿå°±æ˜¯æœ€ç»å¸¸æ¥è§¦çš„å¯¹æ•°ã€‚è€Œç¦»æ•£å¯¹æ•°æ˜¯åœ¨åŒä½™ä¸­çš„ä¸€ä¸ªæ¦‚å¿µã€‚\nè‹¥åœ¨æ¨¡ $m$ æ„ä¹‰ä¸‹ï¼Œ$x$ æ»¡è¶³ä»¥ä¸‹ç­‰å¼ï¼š\n$$ a^x \\equiv b \\pmod{m} $$\nåˆ™ $x$ ä¸ºä»¥ $a$ ä¸ºåº•çš„ $b$ çš„ç¦»æ•£å¯¹æ•°ã€‚æ³¨æ„ç¦»æ•£å¯¹æ•°ä¸åŒäºè¿ç»­å¯¹æ•°ï¼Œä¸€ä¸ªæ•°çš„ç¦»æ•£å¯¹æ•°æœ‰å¾ˆå¤šä¸ªï¼Œå¹¶ä¸æ˜¯å”¯ä¸€çš„ã€‚\nå¦‚æœ $\\gcd(a,m)=1$ï¼Œåˆ™æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ BSGS ç®—æ³•æ±‚è§£ä¸€ä¸ªæ•°çš„æœ€å°çš„ç¦»æ•£å¯¹æ•°ã€‚\næ±‚è§£ å› ä¸º $\\gcd(a,m)=1$ï¼Œåˆ™ $a^k$ å¯¹ $m$ çš„é€†å…ƒä¸€å®šå­˜åœ¨ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠ $a^x$ å†™æˆ $a^{ps-q}$ å¹¶ç›´æ¥å°† $a^{-q}$ æå–å‡ºæ¥ï¼Œå³ï¼š\n$$ a^{ps} \\equiv ba^q \\pmod{m} $$\nè€ƒè™‘æš´åŠ›çš„æ€è·¯ï¼Œå¯ä»¥æšä¸¾ä¸¤è¾¹çš„ $p,q$ï¼Œå¦‚æœæœ‰åŒä½™çš„ä¸¤ä¸ª $a^{ps},ba^q$ï¼Œå°±æ›´æ–°ç­”æ¡ˆã€‚\nè€ƒè™‘åˆ°æšä¸¾ä¼šè®¡ç®—è®¸å¤šé‡å¤çš„ä¸œè¥¿ï¼Œå¯ä»¥ç”¨æŸç§æ•°æ®ç»“æ„ç»´æŠ¤æ˜ å°„è¡¨ï¼Œå­˜ä¸‹æ¯ä¸ª $(ba^q,q)$ï¼Œå†æšä¸¾å·¦è¾¹æ‰¾ç›¸åº”çš„åŒä½™çš„é¡¹ã€‚æˆ‘ä»¬å…ˆå‡è®¾ $x=ps-q \\in [0,m)$ï¼Œåˆ™å½“ $s=\\lceil\\sqrt{m}\\rceil$ æ—¶ï¼Œæ—¶é—´å¤æ‚åº¦æœ€ä¼˜ï¼Œä¸º $\\Theta(\\sqrt{m})$ æˆ– $\\Theta(\\sqrt{m}\\log_2 \\sqrt{m})$ï¼Œå…·ä½“ä¸ºå“ªç§å¤æ‚åº¦ï¼Œå–å†³äºæ˜¯ç”¨å“ˆå¸Œè¡¨è¿˜æ˜¯å¹³è¡¡æ ‘å®ç°ã€‚\nå¯è§£æ€§è¯æ˜ è‡³äºä¸ºä»€ä¹ˆä¸€å®šæœ‰ $x\\in [0,m)$ï¼Œä½¿ç”¨æŠ½å±‰åŸç†è¯æ˜ï¼š\nå¯¹äºä»»æ„çš„ $x$ï¼Œ$a^x \\bmod m$ æœ€å¤šåªæœ‰ $m$ ç§å–å€¼ï¼Œè€Œåœ¨ $x\\in [0,m]$ æ—¶ï¼Œä¸€å…±æœ‰ $m+1$ ç§æŒ‡æ•°ï¼Œåˆ™æ ¹æ®æŠ½å±‰åŸç†å¾—å‡ºå¿…å®šå­˜åœ¨ä¸€å¯¹ $x,y$ æ»¡è¶³ $a^x \\equiv a^y \\pmod{m}$ã€‚è®¾ $t=|x-y|$ï¼Œåˆ™ $a^x a^k=a^{x+t}a^k$ï¼Œå› ä¸ºå·²ç»ä¿è¯ $\\gcd(a,m)=1$ï¼Œåˆ™é€†å…ƒä¸€å®šå­˜åœ¨ï¼Œæ‰€ä»¥å¯ä»¥è§„å®š $t\\in\\mathrm{Z}$ï¼Œæ‰€ä»¥æŒ‡æ•°å…·æœ‰å‘¨æœŸæ€§ï¼Œä¸€å®šå¯ä»¥å¾—åˆ° $x\\in [0,m)$ã€‚\nä»£ç  int power(int x, int y, int m) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % m; x = 1ll * x * x % m; } return res; } optional\u0026lt;int\u0026gt; bsgs(int a, int b, int m) { a %= m; b %= m; unordered_map\u0026lt;int, int\u0026gt; buc; int s = ceil(sqrt(m)), prod = b, base = power(a, s, m); buc[b] = 0; for (int i = 0; i \u0026lt; s; ++i) { prod = 1ll * prod * a % m; buc[prod] = i; } prod = 1; for (int i = 0; i \u0026lt;= s; ++i) { auto it = buc.find(prod); if (it != buc.end() \u0026amp;\u0026amp; i * s - it-\u0026gt;second \u0026gt;= 0) return i * s - it-\u0026gt;second; prod = 1ll * prod * base % m; } return nullopt; }  æ‰©å±• BSGS å½¢å¼ $$ a^x \\equiv b \\pmod{m} $$\nå…¶ä¸­ $a,m$ ä¸ä¸€å®šäº’è´¨ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œé€†å…ƒä¸ä¸€å®šå­˜åœ¨ï¼Œä¹Ÿå°±ä¸å¯ä»¥æŠŠæŒ‡æ•°æ‹†æˆä¸¤ä¸ªéƒ¨åˆ†æ¥ä¼˜åŒ–ã€‚\nè€ƒè™‘å…ˆæŠŠå¼å­åŒ–ä¸º $\\gcd(a,m)=1$ çš„å½¢å¼ã€‚æ–¹æ³•æ˜¯ä¸æ–­æå–å‡º $a$ ä¸ $m$ äº’è´¨çš„éƒ¨åˆ†ï¼Œä»»ä½•æ•´ä¸ªå¼å­åŒé™¤ä»¥è¿™ä¸ªæ•°ã€‚\n$$ a \\equiv c \\pmod{m} \\iff \\frac{a}{d} \\equiv \\frac{c}{d} \\pmod{\\frac{m}{d}}\\ (d\\mid a \\wedge d\\mid c \\wedge d\\mid m) $$\nè¿™ä¸ªå¼å­æ˜¯åŒä½™å¼çš„åŸºæœ¬æ€§è´¨ã€‚æ‰€ä»¥æŒ‰ç…§è¿™æ ·çš„æ–¹æ³•æå–ï¼š\n$$ a^x \\equiv b \\pmod{m}\\\\ \\Downarrow\\\\ \\frac{a}{d_1}a^{x-1} \\equiv \\frac{b}{d_1} \\pmod{\\frac{m}{d_1}}\\\\ \\Downarrow\\\\ \\frac{a^2}{d_1 d_2}a^{x-2} \\equiv \\frac{b}{d_1 d_2} \\pmod{\\frac{m}{d_1 d_2}}\\\\ \\Downarrow\\\\ \\vdots\\\\ \\Downarrow\\\\ \\frac{a^k}{d_1 d_2\\cdots d_k}a^{x-k} \\equiv \\frac{b}{d_1 d_2\\cdots d_k} \\pmod{\\frac{m}{d_1 d_2\\cdots d_k}}\\\\ $$\nå‡è®¾ç°åœ¨ $a$ ä¸ $\\frac{m}{d_1 d_2\\cdots d_k}$ äº’è´¨ï¼Œå°±å¯ä»¥ç”¨ BSGS æ±‚å‡ºæœ€åä¸€ä¸ªæ–¹ç¨‹çš„è§£ $x-k$ï¼Œå†åŠ ä¸Š $k$ å°±æ˜¯ $x$ äº†ã€‚\néœ€è¦æ³¨æ„ä¸¤ç‚¹ï¼š\n è‹¥åœ¨æå–è¿‡ç¨‹ä¸­ï¼Œå‡ºç° $d_1 d_2 \\cdots d_i \\nmid b$ï¼Œåˆ™æ–¹ç¨‹æ— æ³•å†ç»§ç»­æå–ï¼Œæ–¹ç¨‹æ— è§£ æœ‰å¯èƒ½ç­”æ¡ˆåœ¨ $[0,k)$ å†…ï¼Œåªè¦ $O(k)$ æšä¸¾æ£€éªŒå³å¯ã€‚  int gcd(int a, int b) { int t; while (b) { t = a; a = b; b = a % b; } return a; } int power(int x, int y, int m) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % m; x = 1ll * x * x % m; } return res; } int exgcd(int a, int b, int \u0026amp; x, int \u0026amp; y) { if (b == 0) { x = 1; y = 0; return a; } else { int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - a / b * y; return d; } } int inverse(int a, int p) { int x, y; exgcd(a, p, x, y); x = (x % p + p) % p; return x; } optional\u0026lt;int\u0026gt; bsgs(int a, int b, int m) { a %= m; b %= m; unordered_map\u0026lt;int, int\u0026gt; buc; int s = ceil(sqrt(m)), prod = b, base = power(a, s, m); buc[b] = 0; for (int i = 0; i \u0026lt; s; ++i) { prod = 1ll * prod * a % m; buc[prod] = i; } prod = 1; for (int i = 0; i \u0026lt;= s; ++i) { auto it = buc.find(prod); if (it != buc.end() \u0026amp;\u0026amp; i * s - it-\u0026gt;second \u0026gt;= 0) return i * s - it-\u0026gt;second; prod = 1ll * prod * base % m; } return nullopt; } optional\u0026lt;int\u0026gt; exBsgs(int a, int b, int m) { a = (a % m + m) % m; b = (b % m + m) % m; if (m == 1 || b == 1) return 0; int prod = 1, d, k = 0; while (true) { d = gcd(a, m); if (d == 1) break; if (b % d) return nullopt; b /= d; m /= d; ++k; prod = prod * (a / d) % m; if (prod == b) return k; } auto res = bsgs(a, 1ll * b * inverse(prod, m) % p, m); if (!res.has_value()) return nullopt; return res.value() + k; }  é˜¶ä¸åŸæ ¹ é˜¶ å¯¹äºä¸€å¯¹äº’è´¨çš„æ•´æ•° $a,m$ï¼Œè‹¥ $r$ æ»¡è¶³ $r \\ne 0$ ä¸” $a^r \\equiv 1 \\pmod{m}$ ä¸”ä¸å­˜åœ¨ä»»ä½•å°äº $r$ çš„æ­£æ•´æ•°æ»¡è¶³è¯¥åŒä½™å¼ï¼Œåˆ™ç§° $r$ ä¸º $a$ å¯¹ $m$ çš„é˜¶ï¼Œè®°ä½œ $r = \\delta_m(a)$ã€‚\nTheorem 1ï¼š$0 \u0026lt; \\delta_m(a) \\le \\varphi(m)$ã€‚\nè‹¥ $\\gcd(a,m)=1$ï¼Œåˆ™æ¬§æ‹‰å®šç†ä¸€å®šæˆç«‹ï¼Œå³ $a^{\\varphi(m)} \\equiv 1 \\pmod{m}$ï¼Œæ˜¾ç„¶ $0 \u0026lt; \\delta_m(a) \\le \\varphi(m)$ã€‚\nTheorem 2ï¼šè‹¥ $a^k \\equiv 1 \\pmod{m}$ï¼Œåˆ™ $\\delta_m(a) \\mid k$ã€‚\nå‡è®¾æ»¡è¶³ $\\delta_m(a) \\nmid k$ ä½† $a^k \\equiv 1 \\pmod{m}$ï¼Œåˆ™ $k=s\\delta_m(a)+t$ï¼Œå…¶ä¸­ $t \\in (0,\\delta_m(a))$ï¼Œæ‰€ä»¥ï¼š\n$$ a^k \\equiv (a^{\\delta_m(a)})^sa^t \\equiv a^t \\pmod{m} $$\næ ¹æ®é˜¶çš„å®šä¹‰ï¼Œ$a^t \\not\\equiv 1 \\pmod{m}$ï¼Œæ‰€ä»¥çŸ›ç›¾ï¼Œæ•… $\\delta_m(a) \\mid k$ã€‚\nåŸæ ¹ è‹¥ $a$ æ»¡è¶³ $\\delta_m(a)=\\varphi(m)$ï¼Œåˆ™ $a$ ä¸º $m$ çš„åŸæ ¹ã€‚\nTheorem 1ï¼š$a$ ä¸º $m$ çš„åŸæ ¹çš„å……è¦æ¡ä»¶ä¸º $\\gcd(a,m)=1$ ä¸”å¯¹äº $\\varphi(m)$ çš„æ¯ä¸€ä¸ªè´¨å› æ•°ï¼Œ$a^{\\frac{\\varphi(m)}{p}} \\not\\equiv 1 \\pmod{m}$ã€‚\næ ¹æ®è¿™ä¸ªå®šç†ï¼Œå¯ä»¥è½»æ¾åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦æ˜¯å¦ä¸€ä¸ªæ•°çš„åŸæ ¹ã€‚\nint gcd(int a, int b) { int t; while (b) { t = a; a = b; b = t % b; } return a; } int phi(int x) { int res = x; for (int i = 2; i * i \u0026lt;= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } int power(int x, int y, int m) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % m; x = 1ll * x * x % m; } return res; } bool isPrimitiveRoot(int a, int m) { if (gcd(a, m) != 1) return false; int pm = phi(m), tmp = pm; a %= m; for (int i = 2; i * i \u0026lt;= tmp; ++i) { if (tmp % i) continue; if (power(a, pm / i, m) == 1) return false; while (tmp % i == 0) tmp /= i; } if (tmp \u0026gt; 1) if (power(a, pm / tmp, m) == 1) return false; return true; }  Theorem 2ï¼šä¸€ä¸ªæ•° $m$ æœ‰åŸæ ¹ï¼Œå½“ä¸”ä»…å½“ $m$ ä¸º $2,4,p^k,2p^k$ï¼Œå…¶ä¸­ $k\\in \\mathrm{N^*}$ï¼Œ$p$ ä¸ºå¥‡è´¨æ•°ã€‚\nTheorem 3ï¼šè‹¥ä¸€ä¸ªæ•° $m$ æœ‰åŸæ ¹ï¼Œåˆ™å…¶åŸæ ¹ä¸ªæ•°ä¸º $\\varphi(\\varphi(m))$ã€‚\nTheorem 4ï¼šè‹¥ä¸€ä¸ªæ•° $m$ æœ‰åŸæ ¹ï¼Œåˆ™å…¶æœ€å°åŸæ ¹çš„æ•°é‡çº§ä¸º $m^{\\frac{1}{4}}$ã€‚\næ ¹æ®è¿™ä¸ªæ€§è´¨ï¼Œåªéœ€è¦æš´åŠ›æšä¸¾æ¯ä¸ªæ•°ï¼Œæ±‚ä¸€ä¸ªæ•°çš„æœ€å°åŸæ ¹çš„æ—¶é—´å¤æ‚åº¦æ˜¯å¯ä»¥æ¥å—çš„ã€‚\nint gcd(int a, int b) { int t; while (b) { t = a; a = b; b = t % b; } return a; } int phi(int x) { int res = x; for (int i = 2; i * i \u0026lt;= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } int power(int x, int y, int m) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % m; x = 1ll * x * x % m; } return res; } int primitiveRoot(int m) { int pm = phi(m), tmp = pm; vector\u0026lt;int\u0026gt; factor; for (int i = 2; i * i \u0026lt;= tmp; ++i) { if (tmp % i) continue; factor.push_back(i); while (tmp % i == 0) tmp /= i; } if (tmp \u0026gt; 1) factor.push_back(tmp); for (int i = 2; i \u0026lt;= m; ++i) { if (gcd(i, m) != 1) continue; bool found = true; for (int p : factor) { if (power(i, pm / p, m) == 1) { found = false; break; } } if (found) return i; } return -1; }  Theorem 5ï¼šè‹¥ $a$ ä¸º $m$ çš„åŸæ ¹ï¼Œåˆ™ $a,a^2,a^3,\\dots,a^{\\varphi(m)}$ ä¸¤ä¸¤æ¨¡ $m$ ä¸åŒä½™ã€‚\nTheorem 6ï¼šè‹¥ $a$ ä¸º $m$ çš„åŸæ ¹ï¼Œåˆ™å¯¹äºä»»æ„çš„ $x \\in [1,\\varphi(m)]$ï¼Œä¸€å®šæœ‰ä¸€ä¸ª $k$ ä¸å…¶ä¸€ä¸€å¯¹åº”ï¼Œæ»¡è¶³ $x \\equiv a^k \\pmod{m}$ ä¸” $k\\in [1,\\varphi(m)]$ï¼Œ$k$ è¢«ç§°ä¸º $x$ çš„æŒ‡æ ‡ï¼Œè®°ä½œ $I(x)$ã€‚\næ¯”å¦‚ $m=13$ï¼Œå…¶æœ€å°åŸæ ¹ $a=2$ï¼Œåˆ™æŠŠ $x$ ä¸ $I(x)$ å†™æˆè¡¨æ ¼ï¼š\n   $x$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $9$ $10$ $11$ $12$     $I(x)$ $12$ $1$ $4$ $2$ $9$ $5$ $11$ $3$ $8$ $10$ $7$ $6$    è¿™ä¸ªå®šç†å¯ä»¥ç”¨äºæŠŠåº•æ•°è½¬æ¢ä¸ºåŸæ ¹çš„å¹‚ï¼Œå¯ä»¥åˆ©ç”¨è¿™ä¸ªæ€§è´¨è§£æ¨¡æ•°ä¸ºè´¨æ•°çš„ $N$ æ¬¡å‰©ä½™é—®é¢˜ã€‚\nN æ¬¡å‰©ä½™ å½¢å¼ $$ x^n \\equiv a \\pmod{m} $$\nå…¶ä¸­ $m$ ä¸ºå¥‡è´¨æ•°ï¼Œæ±‚ $x\\in [0,m)$ã€‚ç”±äº $m$ ä¸æ˜¯å¥‡è´¨æ•°çš„æ–¹æ³•è¾ƒå¤æ‚ï¼Œè¿™é‡Œä¸è€ƒè™‘ã€‚\næ±‚è§£ è®¾ $g$ ä¸ºå…¶åŸæ ¹ï¼Œåˆ™å¯ä»¥åˆ©ç”¨åŸæ ¹å’ŒæŒ‡æ ‡çš„æ€§è´¨å°† $x$ è½¬åŒ–ä¸º $g^y$ï¼Œå³ï¼š\n$$ (g^y)^n \\equiv (g^n)^y \\equiv a \\pmod{m} $$\nè¿™æ ·å°±å¯ä»¥ç”¨ BSGS æ±‚å‡º $y$ï¼Œå†ç”¨å¿«é€Ÿå¹‚æ±‚å¾— $x$ å³å¯ã€‚\nä¹Ÿå¯ä»¥å†å°† $a$ åŒ–ä¸º $g^z$ï¼Œç„¶åæ–¹ç¨‹åŒ–ä¸ºï¼š\n$$ g^{ny} \\equiv g^z \\pmod{m} $$\näºæ˜¯å°±å¯ä»¥è§£å‡ºçº¿æ€§åŒä½™æ–¹ç¨‹çš„è§£ $y$ï¼š\n$$ ny \\equiv z \\pmod{m} $$\nä»£ç å°±ä¸å†™äº†ï¼Œä¸Šé¢ç»„åˆä¸€ä¸‹å°±å¯ä»¥äº†ã€‚\n","id":5,"section":"posts","summary":"è§£å„ç§åŒä½™æ–¹ç¨‹æ˜¯åŒä½™é—®é¢˜çš„ä¸€ä¸ªé‡è¦éƒ¨åˆ†ï¼Œæœ¬æ–‡ä»‹ç»å„ç§åŒä½™æ–¹ç¨‹çš„æ±‚è§£æ–¹æ³•ã€‚ äºŒå…ƒçº¿æ€§ä¸å®šæ–¹ç¨‹ å½¢å¼ ä¸å®šæ–¹ç¨‹çš„èŒƒå›´å¾ˆå¹¿æ³›ï¼Œåªè¦æ²¡æœ‰ç¡®å®šçš„è§£çš„æ–¹ç¨‹éƒ½å¯","tags":["OI","æ•°å­¦","æ•°è®º","åŒä½™","ä¸­å›½å‰©ä½™å®šç†","BSGS","åŸæ ¹","N æ¬¡å‰©ä½™","C++"],"title":"åŒä½™æ–¹ç¨‹å­¦ä¹ ç¬”è®°","uri":"https://ctj12461.vercel.app/contents/20220213-congruence-equation-note/","year":"2022"},{"content":"Burnside å¼•ç†å’Œ PÃ³lya å®šç†ä¸»è¦ç”¨äºè§£å†³è®¡ç®—æœ¬è´¨ä¸åŒæ–¹æ¡ˆæ•°çš„è®¡æ•°é—®é¢˜ã€‚\nç¾¤è®º åŸºæœ¬å®šä¹‰ ç¾¤å¯ä»¥çœ‹æˆæ˜¯ä¸€ä¸ªç”±é›†åˆå’ŒæŸä¸ªäºŒå…ƒè¿ç®—ç»„æˆçš„äºŒå…ƒç»„ $(S,\\cdot)$ï¼Œè¿™é‡Œçš„ $\\cdot$ å°±ä»£è¡¨ä¸€ä¸ªäºŒå…ƒè¿ç®—ï¼Œè¿™ä¸ªäºŒå…ƒè¿ç®—éœ€è¦æ»¡è¶³ç»“åˆå¾‹ã€å­˜åœ¨å•ä½å…ƒå’Œé€†å…ƒã€‚ç¾¤æœ‰å¾ˆå¤šçš„ç§ç±»ï¼Œæ¯”å¦‚ç½®æ¢ç¾¤ã€å¾ªç¯ç¾¤ã€çŸ©é˜µç¾¤ç­‰ï¼Œå…¶ä¸­ç½®æ¢ç¾¤å°±æ˜¯æˆ‘ä»¬æ¥ä¸‹æ¥è¦ä»‹ç»çš„ã€‚\næ€§è´¨ è‹¥ä¸€ä¸ªäºŒå…ƒç»„ $(S,\\cdot)$ æ˜¯ç¾¤ï¼Œåˆ™å®ƒæ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š\n å°é—­æ€§ï¼š$\\forall x,y\\in S$ï¼Œè‹¥ $z=x\\cdot y$ï¼Œåˆ™ $z\\in S$ ç»“åˆå¾‹ï¼š$\\forall x,y,z\\in S$ï¼Œ$(x\\cdot y)\\cdot z=x\\cdot (y \\cdot z)$ å•ä½å…ƒï¼šå­˜åœ¨å”¯ä¸€ä¸€ä¸ªå…ƒç´  $e \\in S$ æ»¡è¶³ $\\forall x \\in S$ï¼Œ$e\\cdot x=x$ é€†å…ƒï¼š$\\forall x \\in S$ï¼Œéƒ½å¯ä»¥æ‰¾åˆ°å”¯ä¸€ä¸€ä¸ªå…ƒç´  $x^{-1}$ æ»¡è¶³ $x \\cdot x^{-1} = e$ï¼Œè¿™ä¸ªå…ƒç´ ç§°ä¸º $x$ çš„é€†å…ƒ  ä¸¾ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œ$(\\mathrm{Z},+)$ å°±æ˜¯ä¸€ä¸ªç¾¤ï¼Œæ— è®ºå–å“ªä¸¤ä¸ªå…ƒç´ è¿›è¡ŒåŠ æ³•è¿ç®—ï¼Œç»“æœä»ç„¶æ˜¯æ•´æ•°ï¼›åŠ æ³•æ»¡è¶³ç»“åˆå¾‹ï¼›å•ä½å…ƒ $e = 0$ï¼›ä»»æ„ä¸€ä¸ªå…ƒç´  $x$ çš„é€†å…ƒ $x^{-1} = -x$ã€‚\nç½®æ¢ä¸ç½®æ¢ç¾¤ ç½®æ¢çš„åŸºæœ¬å®šä¹‰ é¡¾åæ€ä¹‰ï¼Œç½®æ¢ç¾¤å°±æ˜¯ç½®æ¢ç»„æˆçš„ç¾¤ã€‚ç½®æ¢å¯ä»¥çœ‹æˆä¸€ä¸ªæœ‰é™é›†åˆåˆ°è‡ªèº«çš„åŒå°„ï¼Œå…·ä½“ä¸€ç‚¹ï¼Œå‡è®¾æœ‰ä¸¤ä¸ªé•¿åº¦ç›¸åŒçš„é›†åˆ $p,q$ï¼ˆè¿™é‡Œå‡è®¾é›†åˆå¯ä»¥æœ‰åºï¼‰ï¼Œåˆ™ç½®æ¢ $f$ ä½œç”¨äº $p$ å°±æ˜¯ç”Ÿæˆä¸€ä¸ªæ–°çš„é›†åˆ $p\u0026rsquo;$ï¼Œæ»¡è¶³ $p\u0026rsquo;_i=p_{q_i}$ã€‚\nç½®æ¢è¡¨ç¤ºæˆä¸‹é¢è¿™æ ·ï¼š\n$$ f= \\begin{pmatrix} p_1, p_2, p_3, \\dots, p_n\\\\ p_{q_1}, p_{q_2}, p_{q_3}, \\dots p_{q_n} \\end{pmatrix} $$\næœ‰æ—¶æˆ‘ä»¬ä¼šçœ‹åˆ°è¿™æ ·çš„ç½®æ¢ï¼š\n$$ f= \\begin{pmatrix} 1, 2, 3, \\dots, n\\\\ p_1, p_2, p_3, \\dots, p_n \\end{pmatrix} $$\nè¿™ç§ç½®æ¢ä¹Ÿç»å¸¸è¢«ç®€å†™ä¸ºï¼š\n$$ f= \\begin{pmatrix} p_1, p_2, p_3, \\dots, p_n \\end{pmatrix} $$\nç½®æ¢çš„ä¹˜æ³• å‡è®¾æœ‰ä¸¤ä¸ªç½®æ¢ $f,g$ï¼Œå®šä¹‰å®ƒä»¬çš„ä¹˜æ³•ä¸º $f \\cdot g$ï¼š $$ f= \\begin{pmatrix} 1, 2, 3, \\dots, n\\\\ p_1, p_2, p_3, \\dots, p_n \\end{pmatrix} , g= \\begin{pmatrix} p_1, p_2, p_3, \\dots, p_n\\\\ q_1, q_2, q_3, \\dots, q_n \\end{pmatrix} \\\\ f \\cdot g = \\begin{pmatrix} 1, 2, 3, \\dots, n\\\\ q_1, q_2, q_3, \\dots, q_n \\end{pmatrix} $$\nå¾ªç¯ç½®æ¢ å¾ªç¯ç½®æ¢æ˜¯ç‰¹æ®Šçš„ç½®æ¢ï¼Œå®ƒè¡¨ç¤ºä¸ºä¸‹é¢è¿™æ ·ï¼š\n$$ f= \\begin{pmatrix} 1, 2, 3, \\dots n - 1, n\\\\ 2, 3, 4, \\dots, n, 1 \\end{pmatrix} $$\nè‹¥ä¸¤ä¸ªç½®æ¢ä¸å«ç›¸åŒçš„å…ƒç´ ï¼Œåˆ™ç§°è¿™ä¸¤ä¸ªç½®æ¢ä¸ç›¸äº¤ã€‚ä»»ä½•çš„ç½®æ¢éƒ½å¯ä»¥æ‹†åˆ†ä¸ºè‹¥å¹²ä¸ç›¸äº¤çš„å¾ªç¯ç½®æ¢çš„ä¹˜ç§¯ã€‚æ¯”å¦‚ä¸‹é¢çš„ä¾‹å­ï¼š\n$$ \\begin{pmatrix} a_1, a_2, a_3, a_4, a_5, a_6\\\\ a_2, a_1, a_5, a_4, a_6, a_3 \\end{pmatrix}= \\begin{pmatrix} a_1, a_2\\\\ a_2, a_1 \\end{pmatrix} \\cdot \\begin{pmatrix} a_3, a_5, a_6\\\\ a_5, a_6, a_3 \\end{pmatrix} \\cdot \\begin{pmatrix} a_4\\\\ a_4 \\end{pmatrix} $$\nè¦è¯æ˜è¿™ä¸ªå®šç†ï¼Œå¯ä»æŠŠæ¯ä¸ªå…ƒç´ çœ‹æˆç»“ç‚¹ï¼Œä¸Šå¾€ä¸‹è¿æœ‰å‘è¾¹ï¼Œå› ä¸ºä¸Šä¸‹ä¸¤è¡Œçš„ä¸‹æ ‡éƒ½æ˜¯æ’åˆ—ï¼Œåˆ™æ¯ä¸ªå…ƒç´ éƒ½åœ¨æ¯ä¸€è¡Œæœ‰ä¸”ä»…å‡ºç°ä¸€æ¬¡ï¼Œä¹Ÿå°±æ˜¯å…¥åº¦å’Œå‡ºåº¦å‡ä¸º $1$ï¼Œæ˜¾ç„¶åªå¯èƒ½æ„æˆè‹¥å¹²ä¸ªç®€å•ç¯ï¼Œæ¯ä¸ªç®€å•ç¯å°±ä»£è¡¨ä¸€ä¸ªå¾ªç¯ç½®æ¢ã€‚\nç½®æ¢ç¾¤ ç”±ç½®æ¢å’Œç½®æ¢çš„ä¹˜æ³•ç»„æˆçš„ç¾¤å°±æ˜¯ç½®æ¢ç¾¤ï¼Œç½®æ¢ç»è¿‡ä¹˜æ³•è¿ç®—åæ˜¾ç„¶è¿˜æ˜¯ç½®æ¢ï¼Œå¤šä¸ªç½®æ¢çš„ç»“åˆé¡ºåºå…ˆåä¸å½±å“ç­”æ¡ˆï¼Œå•ä½å…ƒæ˜¯æ’ç­‰ç½®æ¢ï¼Œå³ä¸Šä¸‹ä¸¤è¡Œçš„å…ƒç´ æ’åˆ—ç›¸åŒï¼Œæ¯ä¸ªç½®æ¢çš„é€†å…ƒæ˜¯äº¤æ¢ä¸Šä¸‹ä¸¤è¡Œçš„ç½®æ¢ã€‚\næœ¬è´¨ä¸åŒè®¡æ•°é—®é¢˜ä¸ç½®æ¢ è¿™ä¸€ç±»çš„é—®é¢˜é€šå¸¸ä¼šç»™å‡ºä¸€äº›è§„å®šï¼Œå®šä¹‰äº†å“ªäº›çŠ¶æ€æ˜¯æœ¬è´¨ç›¸åŒçš„ã€‚æ¯”å¦‚è¦æ±‚ç»™ä¸€ä¸ª $2 \\times 2$ çš„æ­£æ–¹å½¢æŸ“è‰²ï¼Œå¯é€‰é¢œè‰²æœ‰ä¸¤ç§ï¼Œå¦‚æœä¸€ç§æ–¹æ¡ˆå¯ä»¥é€šè¿‡æ—‹è½¬æ­£æ–¹å½¢å¾—åˆ°å¦å¤–ä¸€ç§ï¼Œåˆ™è¿™ä¸¤ç§æ–¹æ¡ˆç­‰ä»·ã€‚\nå¦‚æœæˆ‘ä»¬æŠŠæ­£æ–¹å½¢çš„æ¯ä¸ªæ ¼å­çœ‹æˆé›†åˆçš„ä¸€ä¸ªå…ƒç´ ï¼Œåˆ™å¯ä»¥é€šè¿‡å®šä¹‰ç½®æ¢æ¥è¡¨ç¤ºæ—‹è½¬ï¼Œå¦‚æœä¸€ä¸ªçŠ¶æ€ç»è¿‡æŸä¸ªç½®æ¢çš„ä½œç”¨åå¾—åˆ°äº†å¦å¤–ä¸€ä¸ªçŠ¶æ€ï¼Œåˆ™å®ƒä»¬ç­‰ä»·ã€‚\nBurnside å¼•ç† ä¸åŠ¨ç‚¹ å¯¹äºä¸€ä¸ªç½®æ¢ $f$ï¼Œè‹¥ $s$ æ»¡è¶³ $f(s) = s$ï¼Œåˆ™ç§° $s$ ä¸º $f$ çš„ä¸åŠ¨ç‚¹ã€‚è®¾æœ‰ä¸€ä¸ªé›†åˆ $X$ è¡¨ç¤ºæ‰€æœ‰çš„çŠ¶æ€ï¼Œåˆ™è®° $X^f$ ä¸º $f$ ä½œç”¨äº $X$ ä¸­çš„å…ƒç´ å¾—åˆ°çš„ä¸åŠ¨ç‚¹å­é›†ï¼Œè®° $c_1(f) = |X^f|$ã€‚\nç­‰ä»·ç±» è‹¥ä¸¤ä¸ªé›†åˆç»è¿‡ç½®æ¢ä½œç”¨åç›¸ç­‰ï¼Œåˆ™å®ƒä»¬å±äºåŒä¸€ä¸ªç­‰ä»·ç±»ã€‚\nå¼•ç†å†…å®¹ è®¾ $A$ï¼Œ$B$ ä¸ºæœ‰é™é›†åˆï¼Œ$X$ ä¸º $A$ åˆ° $B$ çš„æ˜ å°„ç»„æˆçš„é›†åˆï¼Œ$G$ ä¸º $A$ ä¸Šçš„ç½®æ¢ç¾¤ï¼Œ$X/G$ ä¸º $X$ ä¸­çš„æ˜ å°„ç»è¿‡ $G$ ä¸­æ‰€æœ‰çš„ç½®æ¢ä½œç”¨åçš„ç­‰ä»·ç±»é›†åˆï¼Œåˆ™æœ‰ï¼š\n$$ |X/G|=\\frac{1}{|G|}\\sum_{f\\in G}|X^f|=\\frac{1}{|G|}\\sum_{f\\in G}c_1(f) $$\nå³ $G$ ä¸­æ‰€æœ‰çš„ç½®æ¢ä½œç”¨äº $X$ çš„ä¸åŠ¨ç‚¹ä¸ªæ•°çš„å‡å€¼ã€‚\nç›´æ¥ç†è§£è¿™ä¸ªå…¬å¼æ¯”è¾ƒéš¾ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸Šé¢çš„æŸ“è‰²é—®é¢˜æ¥è§£é‡Šã€‚è¿™é‡Œçš„ $A$ å°±æ˜¯è¡¨ç¤º $2 \\times 2$ æ­£æ–¹å½¢ä¸­çš„æ¯ä¸ªæ ¼å­ï¼Œ$B$ ä»£è¡¨ä¸¤ç§é¢œè‰²ï¼Œ$X$ å°±æ˜¯ä»£è¡¨æŸ“è‰²æ–¹æ¡ˆï¼Œå³ä¸€ç§æŸ“è‰²æ–¹æ¡ˆå°±æ˜¯æ ¼å­å¯¹äºä¸Šä¸€ç§é¢œè‰²çš„æ˜ å°„ï¼Œ$X$ å°±æ˜¯æ‰€æœ‰è¿™äº›æ˜ å°„çš„é›†åˆã€‚$G$ ä½œä¸º $A$ ä¸Šçš„ç½®æ¢ç¾¤ï¼Œä»£è¡¨æ—‹è½¬æ­£æ–¹å½¢çš„å„ç§æ“ä½œï¼Œ$X/G$ æ˜¯ç­‰ä»·ç±»é›†åˆï¼Œå³æœ¬è´¨ä¸åŒçš„æŸ“è‰²æ–¹æ¡ˆã€‚\nè¿™ä¸ªå¼•ç†çš„è¯æ˜æ¯”è¾ƒå¤æ‚ï¼Œéœ€è¦è¾ƒå¥½çš„ç¾¤è®ºåŸºç¡€ï¼Œè¿˜è¦äº†è§£è½¨é“-ç¨³å®šå­å®šç†ï¼Œè¿™é‡Œå°±ä¸å±•å¼€äº†ï¼Œåæ­£ä¹Ÿä¸è€ƒè¯æ˜ã€‚\nå¯¹æ­£æ–¹å½¢æŸ“è‰²é—®é¢˜çš„è§£å†³ ç°åœ¨å…·ä½“åˆ†æä¸€ä¸‹è¿™ä¸ªé—®é¢˜ã€‚æ—‹è½¬æ–¹æ³•æœ‰ $4$ ç§ï¼Œåˆ†åˆ«æ˜¯ï¼š\n é¡ºæ—¶é’ˆæ—‹è½¬ $0$ï¼Œæ­¤æ—¶ä¸ºæ’ç­‰ç½®æ¢ï¼Œéšæ„æŸ“è‰²ï¼Œå…± $2^4=16$ ç§ é¡ºæ—¶é’ˆæ—‹è½¬ $\\frac{\\pi}{2}$ï¼Œæ­¤æ—¶ä»…æœ‰å…¨éƒ¨é¢œè‰²ç›¸åŒçš„æ–¹æ¡ˆä¸ºä¸åŠ¨ç‚¹ï¼Œå…± $2$ ç§ é¡ºæ—¶é’ˆæ—‹è½¬ $\\pi$ï¼Œæ­¤æ—¶åªè¦å¯¹è§’çš„é¢œè‰²ç›¸åŒå³å¯ï¼Œå…± $2$ å¯¹å¯¹è§’ï¼Œæ¯å¯¹ $2$ ç§æ–¹æ¡ˆï¼Œå…± $2^2 = 4$ ç§ é¡ºæ—¶é’ˆæ—‹è½¬ $\\frac{3\\pi}{2}$ï¼Œè¿™ç§æƒ…å†µåŒç¬¬äºŒç§ï¼Œå…± $2$ ç§  å¸¦å…¥å…¬å¼å¾—ï¼š\n$$ |X/G|=\\frac{1}{4}\\times (16+2+4+2)=6 $$\nå¯ä»¥è‡ªå·±æšä¸¾éªŒè¯ä¸€ä¸‹ã€‚\nPÃ³lya å®šç† å®šç†å†…å®¹ PÃ³lya å®šç†æ˜¯ Burnside å¼•ç†çš„å…·ä½“åŒ–ï¼ŒåŒæ—¶ä¹Ÿæœ‰ä¸€å®šçš„é™åˆ¶æ¡ä»¶ã€‚åœ¨å‰ç½®æ¡ä»¶äº Burnside å¼•ç†ç›¸åŒçš„æƒ…å†µä¸‹ï¼Œç»™å‡º PÃ³lya å®šç†çš„å…¬å¼ï¼š\n$$ |X/G|=\\frac{1}{|G|}\\sum_{f\\in G} |B|^{\\tau(f)} $$\nå…¶ä¸­ $\\tau(f)$ è¡¨ç¤º $f$ çš„å¾ªç¯ç½®æ¢ä¸ªæ•°ã€‚æ ¹æ®ä¸Šæ–‡ä»»ä½•ç½®æ¢éƒ½å¯ä»¥æ‹†åˆ†ä¸ºè‹¥å¹²ä¸ç›¸äº¤å¾ªç¯ç½®æ¢çš„ä¹˜ç§¯ï¼Œå¾ªç¯ç½®æ¢ä¹‹é—´äº’ä¸å½±å“ï¼Œæ•…å¾ªç¯ç½®æ¢ä¹‹å†…çš„å…ƒç´ æŸ“è‰²æ–¹æ¡ˆå¿…é¡»ç›¸åŒï¼Œè¿™æ ·æ‰èƒ½æ»¡è¶³ç»è¿‡ç½®æ¢ä½œç”¨åä»ç„¶ä¿æŒä¸å˜ï¼Œå³ä¸åŠ¨ç‚¹ï¼Œè€Œå¾ªç¯ç½®æ¢ä¹‹é—´å¯ä»¥ä¸åŒï¼Œæ¯ä¸ªå¾ªç¯ç½®æ¢å¯ä»¥æœ‰ $|B|$ ç§é€‰æ‹©ï¼ˆæŒ‰ç…§ä¸Šæ–‡çš„ä¾‹å­å°±æ˜¯é¢œè‰²æ•°ï¼‰ï¼Œé€šè¿‡ä¹˜æ³•å¾—å‡ºä¸åŠ¨ç‚¹æ€»æ•°ä¸º $|B|^{\\tau(f)}$ã€‚\nä¸€ä¸ªç†è§£å¾ªç¯ç½®æ¢çš„æ–¹æ³•å°±æ˜¯æŠŠå®ƒçœ‹æˆè¿›è¡Œæœ‰å‘å›¾è¿è¾¹åçš„ç¯ï¼Œå¯ä»¥é€šè¿‡æ‰¾ç¯æ¥å¾—å‡ºå¾ªç¯ç½®æ¢ä¸ªæ•°ã€‚\nç”¨ PÃ³lya å®šç†è§£å†³æ­£æ–¹å½¢æŸ“è‰²é—®é¢˜ åŒæ ·åˆ† $4$ ç±»è®¨è®ºï¼š\n é¡ºæ—¶é’ˆæ—‹è½¬ $0$ï¼Œ$\\tau(f)=4$ï¼Œå…± $2^4=16$ ç§ é¡ºæ—¶é’ˆæ—‹è½¬ $\\frac{\\pi}{2}$ï¼Œ$\\tau(f)=1$ï¼Œå…± $2$ ç§ é¡ºæ—¶é’ˆæ—‹è½¬ $\\pi$ï¼Œ$\\tau(f)=2$ï¼Œå…± $2^2 = 4$ ç§ é¡ºæ—¶é’ˆæ—‹è½¬ $\\frac{3\\pi}{2}$ï¼Œ$\\tau(f)=1$ï¼Œå…± $2$ ç§  $$ |X/G|=\\frac{1}{4}\\times (16+2+4+2)=6 $$\nPÃ³lya å®šç†çš„é™åˆ¶ æœ‰æ—¶é¢˜ç›®ä¼šåœ¨æŸ“è‰²æ–¹é¢åšé™åˆ¶ï¼Œä¾‹å¦‚æŸç§é¢œè‰²çš„ä½¿ç”¨æ¬¡æ•°ï¼Œæˆ–é¢œè‰²ä¹‹é—´çš„äº’ç›¸åˆ¶çº¦ç­‰ç­‰ï¼Œæ­¤æ—¶ PÃ³lya å®šç†çš„ç®€å•è®¡æ•°å°±ä¸ç®¡ç”¨äº†ï¼Œéœ€è¦é€šè¿‡ DP æˆ–ç»„åˆæ•°å­¦çš„æ–¹æ³•æ±‚å‡ºä¸åŠ¨ç‚¹ä¸ªæ•°ï¼Œå¸¦å…¥ Burnside å¼•ç†å…¬å¼è®¡ç®—ã€‚\nä¾‹é¢˜ Luogu P4980 ã€æ¨¡æ¿ã€‘PÃ³lya å®šç†  ç»™å®šä¸€ä¸ª $n$ä¸ªç‚¹ï¼Œ$n$ æ¡è¾¹çš„ç¯ï¼Œæœ‰ $n$ ç§é¢œè‰²ï¼Œç»™æ¯ä¸ªé¡¶ç‚¹æŸ“è‰²ï¼Œé—®æœ‰å¤šå°‘ç§æœ¬è´¨ä¸åŒçš„æŸ“è‰²æ–¹æ¡ˆï¼Œç­”æ¡ˆå¯¹ $10^9+7$ å–æ¨¡ã€‚\næ³¨æ„æœ¬é¢˜çš„æœ¬è´¨ä¸åŒï¼Œå®šä¹‰ä¸ºï¼šåªéœ€è¦ä¸èƒ½é€šè¿‡æ—‹è½¬ä¸åˆ«çš„æŸ“è‰²æ–¹æ¡ˆç›¸åŒã€‚\n$1\\le n \\le 10^9$ï¼Œ$1\\le t \\le 10^3$ã€‚\n å®¹æ˜“æƒ³åˆ°æ—‹è½¬æ“ä½œå¯ä»¥è¡¨ç¤ºæˆ $n$ ç§ç½®æ¢ï¼Œç¬¬ $i$ ç§ä»£è¡¨æ—‹è½¬é¡ºæ—¶é’ˆ $\\frac{2\\pi i}{n}$ï¼Œå³å°†æ¯ä¸ªç‚¹å‘å‰ç§»åŠ¨ $i$ æ ¼ã€‚è€ƒè™‘ç¬¬ $i$ ä¸ªç½®æ¢æ‹†åˆ†çš„å¾ªç¯ç½®æ¢ä¸ªæ•°ï¼Œåˆ—å‡ºç½®æ¢è¡¨è¾¾å¼ï¼š\n$$ f_i= \\begin{pmatrix} 1,2,3,\\dots,n-1,n\\\\ n-i+1,n-i+1,n-i+3,\\dots n-i-1,n-i \\end{pmatrix} $$\nè€ƒè™‘åœ¨ç¯ä¸Šè·³çš„æ¨¡å‹ï¼Œè®¾èµ·ç‚¹ä¸º $S$ï¼Œç»ˆç‚¹ä¸º $T$ï¼Œä¸€æ¬¡è·³ $i$ æ ¼ï¼Œè·³äº† $x$ æ¬¡ï¼Œåˆ™å¯ä»¥åˆ—å‡ºå®ƒä»¬çš„å…³ç³»ï¼š\n$$ S + ix \\equiv T \\pmod{n} $$\næ ¹æ®çº¿æ€§åŒä½™æ–¹ç¨‹çš„çŸ¥è¯†ï¼Œå¯ä»¥å¾—å‡ºæ–¹ç¨‹æœ‰è§£ï¼Œæ»¡è¶³ï¼š\n$$ ix+ny=\\gcd(i,n),\\ \\gcd(i,n) \\mid (T-S) $$\nä¹Ÿå°±æ˜¯ï¼Œ$T$ ä¸ $S$ ä¹‹é—´çš„è·ç¦»æ˜¯ $\\gcd(i,n)$ çš„å€æ•°ï¼Œè‹¥ $S$ å›ºå®šï¼Œåˆ™æœ‰ $\\frac{n}{gcd(i,n)}$ ä¸ªå¯¹åº”çš„ $T$ æ„æˆäº†å¾ªç¯ï¼Œå…±æœ‰ $\\frac{n}{\\frac{n}{\\gcd(i,n)}}=\\gcd(i,n)$ ä¸ªå¾ªç¯ï¼Œå³ $\\tau(f_i)=\\gcd(i,n)$ã€‚\nä½¿ç”¨ PÃ³lya å®šç†ï¼Œå¸¦å…¥å…¬å¼ï¼Œæœ€ç»ˆç­”æ¡ˆä¸ºï¼š\n$$ \\begin{aligned} \\frac{1}{n}\\sum_{i=1}^{n} n^{\\gcd(i,n)} \u0026amp; = \\frac{1}{n} \\sum_{d\\mid n}n^d \\sum_{i=1}^{n} [\\gcd(i,n)=d]\\\\ \u0026amp;= \\sum_{d\\mid n} n^{d-1} \\sum_{i=1}^{\\frac{n}{d}} [\\gcd(i,\\frac{n}{d})=1]\\\\ \u0026amp;= \\sum_{d\\mid n} n^{d-1} \\varphi(\\frac{n}{d}) \\end{aligned} $$\nå•æ¬¡è¯¢é—®æ—¶é—´å¤æ‚åº¦ $\\Theta(d(n)(\\log_2 n+\\sqrt{n}))$ã€‚\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MOD = 1e9 + 7; int t, n; int phi(int x) { int res = x; for (int i = 2; i * i \u0026lt;= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } int power(int x, int y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % MOD; x = 1ll * x * x % MOD; } return res; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n; int ans = 0; for (int i = 1; i * i \u0026lt;= n; ++i) { if (n % i) continue; if (i * i == n) { ans = (ans + 1ll * power(n, i - 1) * phi(n / i)) % MOD; } else { ans = (ans + 1ll * power(n, i - 1) * phi(n / i)) % MOD; ans = (ans + 1ll * power(n, n / i - 1) * phi(i)) % MOD; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; }  Luogu P2561 é»‘ç™½ç“·ç –  ç»™å‡ºä¸€ä¸ªè¾¹é•¿ä¸º $n$ çš„ç­‰è¾¹ä¸‰è§’å½¢ï¼Œä¸‰è§’å½¢æ˜¯æœ‰ $\\frac{n(n+1)}{2}$ ä¸ªå…­è¾¹å½¢ç»„æˆçš„ï¼Œå¯¹æ¯ä¸ªå…­è¾¹å½¢é»‘ç™½æŸ“è‰²ï¼Œè‹¥æŸä¸€æ–¹æ¡ˆé€šè¿‡æ—‹è½¬ã€å¯¹ç§°æˆ–æ—‹è½¬å’Œå¯¹ç§°åŒæ—¶è¿›è¡Œå¯ä»¥å¾—åˆ°å¦ä¸€ä¸ªæ–¹æ¡ˆï¼Œåˆ™å®ƒä»¬æœ¬è´¨ç›¸åŒã€‚æ±‚æœ¬è´¨ä¸åŒçš„æ–¹æ¡ˆæ•°ã€‚\n$1\\le n\\le 20$ã€‚\n æ ¹æ®å›¾è§‚å¯Ÿå¾—å‡ºæœ‰ $6$ ç§ç½®æ¢æ–¹æ¡ˆï¼Œåˆ†åˆ«ä¸ºï¼š\n ä¸åšä»»ä½•æ“ä½œï¼Œ$\\tau(f_1)=\\frac{n(n+1)}{2}$ é¡ºæ—¶é’ˆæ—‹è½¬ $\\frac{2\\pi}{3}$ï¼Œ$\\tau(f_2) = \\lceil \\frac{n(n+1)}{6} \\rceil$ï¼Œä¸‰æ¡è¾¹ä¸Šå…³äºä¸­å¿ƒæ—‹è½¬ç­‰è§’åº¦æ—‹è½¬å¾—åˆ°çš„ä¸‰ä¸ªç‚¹ é¡ºæ—¶é’ˆæ—‹è½¬ $\\frac{4\\pi}{3}$ï¼Œ$\\tau(f_3) = \\lceil \\frac{n(n+1)}{6} \\rceil$ï¼ŒåŒä¸Š å¯¹ç§°ï¼Œ$\\tau(f_4) = \\sum_{i=1}^{n} \\lceil \\frac{i}{2} \\rceil$ï¼Œæ¯è¡Œçš„å·¦å³ä¸¤è¾¹å¯¹ç§°çš„ä¸€å¯¹ä¸ºä¸€ä¸ªå¾ªç¯ç½®æ¢ å…ˆé¡ºæ—¶é’ˆæ—‹è½¬ $\\frac{2\\pi}{3}$ å†å¯¹ç§°ï¼Œç­‰ä»·äºæ¢ä¸€æ¡è¾¹åšå¯¹ç§°ï¼ŒåŒä¸Š å…ˆé¡ºæ—¶é’ˆæ—‹è½¬ $\\frac{4\\pi}{3}$ å†å¯¹ç§°ï¼Œç­‰ä»·äºå†æ¢ä¸€æ¡è¾¹åšå¯¹ç§°ï¼ŒåŒä¸Š  åŒæ—¶è¿›è¡Œçš„æƒ…å†µä¸ç®¡æ˜¯å…ˆæ—‹è½¬è¿˜æ˜¯å…ˆå¯¹ç§°ï¼Œéƒ½æ˜¯ä¸€æ ·çš„ï¼Œå¤šæ¬¡æ—‹è½¬æˆ–å¤šæ¬¡å¯¹ç§°çš„æƒ…å†µç­‰ä»·äºä»¥ä¸Š $6$ ç§ä¸­çš„æŸäº›æƒ…å†µã€‚\néœ€è¦é«˜ç²¾åº¦è®¡ç®—ï¼Œç»™å‡º Python 3 ä»£ç ï¼š\nfrom math import ceil n = int(input()) ex = int(ceil(n * (n + 1) / 6)) ans = 2 ** (n * (n + 1) // 2) ans += 2 ** (ex + 1) # 2, 3 ex = 0 for i in range(1, n + 1): ex += int(ceil(i / 2)) ans += 3 * (2 ** ex) # 4, 5, 6 ans //= 6 print(ans)  Luogu P1446 Cards  ç»™å‡º $n$ å¼ ç‰Œï¼Œç»™æ¯å¼ ç‰ŒæŸ“ä¸Šçº¢ã€ç»¿ã€è“ä¸‰ç§é¢œè‰²ï¼Œè¦æ±‚è¿™ä¸‰ç§ç‰Œæ°å¥½æœ‰ $Sr,Sg,Sb$ å¼ ï¼Œä»¥åŠç»™å‡º $m$ ç§æ´—ç‰Œæ–¹æ³•ï¼Œæ¯ç§æ´—ç‰Œæ–¹æ³•ç”¨ä¸€ä¸ªæ’åˆ— $X$ è¡¨ç¤ºï¼Œç¬¬ $i$ å¼ ç‰Œå˜ä¸ºåŸæ¥çš„ç¬¬ $X_i$ å¼ ç‰Œã€‚æ±‚æœ¬è´¨ä¸åŒçš„æŸ“è‰²æ–¹æ¡ˆæ•°ã€‚\n$1\\le n,m \\le 60$ï¼Œ$m+1\u0026lt;p\u0026lt;100$ï¼Œ$Sr,Sg,Sb\\le 20$ï¼Œ$n = Sr + Sg + Sb$ã€‚\n ç”±äºå¯¹æŸ“è‰²åŠ ä¸Šäº†é™åˆ¶ï¼ŒPolya å®šç†ä¸èƒ½ç”¨äº†ï¼Œè€ƒè™‘ Burnside å¼•ç†ï¼Œå¹¶é€šè¿‡ DP æ±‚å‡ºæ¯ç»„ç½®æ¢çš„ä¸åŠ¨ç‚¹ä¸ªæ•°ã€‚æ˜¾ç„¶æ¯ç»„ç½®æ¢ä¸ºé¢˜ç›®ä¸­çš„æ¯ç§æ´—ç‰Œæ–¹å¼ï¼Œå¦å¤–è¦åŠ ä¸Šæ’ç­‰ç½®æ¢ã€‚\nå¯¹äºä¸€ç§ç½®æ¢ï¼Œæ±‚å‡ºå…¶å¾ªç¯ç½®æ¢ä¸ªæ•° $e$ï¼ŒåŠå¾ªç¯ç½®æ¢çš„ä½œç”¨çš„é›†åˆçš„å…ƒç´ ä¸ªæ•° $c[i]$ã€‚æ˜¾ç„¶ä¸ºäº†æ»¡è¶³ä¸åŠ¨ç‚¹çš„è¦æ±‚ï¼Œæ¯ä¸ªå¾ªç¯ç½®æ¢å†…çš„é¢œè‰²åº”è¯¥ç›¸åŒã€‚\nè®¾ $f[i][r][g][b]$ ä¸ºé€‰åˆ°äº†ç¬¬ $i$ ä¸ªå¾ªç¯ç½®æ¢ä¸”ä¸‰ç§é¢œè‰²åˆ†åˆ«ç”¨äº† $r,g,b$ ä¸ªçš„æ–¹æ¡ˆæ•°ï¼Œæœ‰å¦‚ä¸‹çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š\n$$ f[0][0][0][0] = 1\\\\ f[i][r][g][b]\\longleftarrow f[i-1][r-c[i]][g][b]\\ (r\\ge c[i])\\\\ f[i][r][g][b]\\longleftarrow f[i-1][r][g-c[i]][b]\\ (g\\ge c[i])\\\\ f[i][r][g][b]\\longleftarrow f[i-1][r]][g][b-c[i]]\\ (b\\ge c[i]) $$\nåˆ™ä¸åŠ¨ç‚¹ä¸ªæ•°ä¸º $f[e][Sr][Sg][Sb]$ã€‚æœ€ç»ˆç­”æ¡ˆä¸ºï¼š\n$$ \\frac{1}{m} \\sum_{x\\in \\mathrm{perm}} f[e[x]][Sr][Sg][Sb] $$\næ—¶é—´å¤æ‚åº¦ $\\Theta(nmSrSgSb)$ã€‚\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; constexpr int MAX_M = 60 + 5; constexpr int MAX_S = 20 + 5; int n, m, sr, sg, sb, p; vector\u0026lt;int\u0026gt; perm[MAX_M]; bool vis[MAX_M]; int f[2][MAX_S][MAX_S][MAX_S], ans; int power(int x, int y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % p; x = 1ll * x * x % p; } return res; } int dfs(int now, const vector\u0026lt;int\u0026gt; \u0026amp; perm) { if (vis[now]) return 0; vis[now] = true; return dfs(perm[now], perm) + 1; } vector\u0026lt;int\u0026gt; findLoop(const vector\u0026lt;int\u0026gt; \u0026amp; perm) { vector\u0026lt;int\u0026gt; res = { 0 }; for (int i = 1; i \u0026lt;= n; ++i) vis[i] = false; for (int i = 1; i \u0026lt;= n; ++i) if (!vis[i]) res.push_back(dfs(i, perm)); return res; } int dp(const vector\u0026lt;int\u0026gt; \u0026amp; loop) { int e = loop.size() - 1; int res = 0; for (int r = 0; r \u0026lt;= sr; ++r) for (int g = 0; g \u0026lt;= sg; ++g) for (int b = 0; b \u0026lt;= sb; ++b) f[0][r][g][b] = 0; f[0][0][0][0] = 1; for (int i = 1; i \u0026lt;= e; ++i) { int now = (i \u0026amp; 1), pre = (now ^ 1); for (int r = 0; r \u0026lt;= sr; ++r) { for (int g = 0; g \u0026lt;= sg; ++g) { for (int b = 0; b \u0026lt;= sb; ++b) { int \u0026amp; val = f[now][r][g][b] = 0; if (r - loop[i] \u0026gt;= 0) val = (val + f[pre][r - loop[i]][g][b]) % p; if (g - loop[i] \u0026gt;= 0) val = (val + f[pre][r][g - loop[i]][b]) % p; if (b - loop[i] \u0026gt;= 0) val = (val + f[pre][r][g][b - loop[i]]) % p; if (i == e) res = (res + val) % p; } } } } return res; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; sr \u0026gt;\u0026gt; sg \u0026gt;\u0026gt; sb \u0026gt;\u0026gt; m \u0026gt;\u0026gt; p; n = sr + sg + sb; for (int i = 1; i \u0026lt;= m; ++i) { perm[i].push_back(0); for (int j = 1; j \u0026lt;= n; ++j) { int x; cin \u0026gt;\u0026gt; x; perm[i].push_back(x); } } // åˆ¤æ–­æ˜¯å¦å·²ç»å­˜åœ¨å¾ªç¯ç½®æ¢ bool found = false; for (int i = 1; i \u0026lt;= m; ++i) { bool found2 = true; for (int j = 1; j \u0026lt;= n; ++j) { if (perm[i][j] != j) { found2 = false; break; } } if (found2) { found = true; break; } } if (!found) { ++m; for (int i = 0; i \u0026lt;= n; ++i) perm[m].push_back(i); } for (int i = 1; i \u0026lt;= m; ++i) ans = (ans + dp(findLoop(perm[i]))) % p; ans = 1ll * ans * power(m, p - 2) % p; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  BZOJ 1547 å‘¨æœ«æ™šä¼š  å®‰æ’ $n$ ä¸ªäººå›´ç»•ç€åœ†æ¡Œåç€ï¼Œå…¶ä¸­ä¸€äº›æ˜¯ç”·å­©ï¼Œå¦ä¸€äº›æ˜¯å¥³å­©ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰¾å‡ºæ‰€æœ‰åˆæ³•çš„æ–¹æ¡ˆæ•°å¹¶å¯¹ $10^8+7$ å–æ¨¡ï¼Œä½¿å¾—ä¸è¶…è¿‡ $k$ ä¸ªå¥³å­©åº§ä½æ˜¯è¿ç»­çš„ã€‚å¾ªç¯åŒæ„ä¼šè¢«è®¤ä¸ºæ˜¯åŒä¸€ç§æ–¹æ¡ˆã€‚\n$T$ ç»„æ•°æ®ï¼Œ $1\\le T\\le 50$ï¼Œ$1\\le n,k\\le 2000$ã€‚\n ä¸€ä¸ªå·²æ­» OJ ä¸Šçš„é¢˜ç›®ã€‚\nè®¾ç”·å­©ä¸º Bï¼Œå¥³å­©ä¸º Gï¼Œä¸€å…± $n$ ç§ç½®æ¢ï¼Œ$f_i$ è¡¨ç¤ºé¡ºæ—¶é’ˆ $i$ æ ¼ã€‚å¯ä»¥ç”¨ DP è®¡ç®—ä¸åŠ¨ç‚¹ä¸ªæ•°ã€‚\nå¯¹äº $f_i$ï¼Œå¦‚æœæ²¡æœ‰ $k$ çš„é™åˆ¶ï¼Œåœ¨ç¯ä¸Šæ ‡è®°å‡ºæ¯ä¸ªç‚¹å±äºå“ªä¸ªå¾ªç¯ç½®æ¢ï¼Œå¯ä»¥å‘ç°å¾ªç¯ç½®æ¢çš„ç§ç±»æ˜¯äº¤é”™åˆ†å¸ƒçš„ï¼Œå¹¶ä»¥ $\\gcd(i,n)$ ä¸ºå‘¨æœŸï¼Œæ‰€ä»¥æˆ‘ä»¬å¯¹ $[1, \\gcd(i,n)]$ æ€ä¹ˆæŸ“è‰²ï¼Œ$[\\gcd(i,n)+1,2\\gcd(i,n)]\\dots [n-\\gcd(i,n)+1, n]$ ä¹Ÿæ˜¯æ€ä¹ˆæŸ“è‰²ã€‚é—®é¢˜è½¬åŒ–ä¸ºæ±‚å¯¹ $[1,\\gcd(i,n)]$ æŸ“è‰²ä¸”å°†è¿™ä¸ªåŒºé—´å¤´å°¾ç›¸æ¥åä»ç„¶åˆæ³•çš„æ–¹æ¡ˆæ•°ã€‚\nç¯ä¸Šçš„é—®é¢˜è€ƒè™‘æ–­ç¯ä¸ºé“¾ï¼Œå…ˆæšä¸¾å¼€å¤´çš„ G çš„ä¸ªæ•°ï¼Œå†è®¡ç®—åç»­çš„æ–¹æ¡ˆæ•°ï¼Œæœ€åå†åŠ èµ·æ¥ã€‚è®¾ $f[t][i][0/1]$ ä¸ºä¸è€ƒè™‘å¤´å°¾ç›¸æ¥æƒ…å†µä¸‹ï¼Œå¼ºåˆ¶å¼€å¤´æœ‰ $t$ ä¸ª Gï¼Œç¬¬ $i$ ä½ä¸º B æˆ– G çš„æ–¹æ¡ˆæ•°ï¼Œ$g[i]$ ä¸ºå°† $[1,i]$ å¤´å°¾ç›¸æ¥å¯ä»¥å¾—åˆ°çš„åˆæ³•æ–¹æ¡ˆæ•°ï¼š\n$$ f[t][t][1]=1\\\\ f[t][i][0]=f[t][i-1][0]+f[t][i-1][1]\\\\ f[t][i][1]=\\sum_{j=i-k}^{i-1} f[t][j][0]\\\\ g[i]=\\sum_{t=0}^{k}(f[t][i][0]+\\sum_{j=i-(k-t)}^{i-1} f[t][j][0]) $$\n$f[t][i][1]$ å¯ä»¥å‰ç¼€å’Œä¼˜åŒ–ï¼Œè½¬ç§»éƒ½æ˜¯ $O(1)$ çš„ã€‚å› ä¸º $g[i]$ è¦è€ƒè™‘å¤´å°¾ç›¸æ¥ï¼Œæ‰€ä»¥æœ«å°¾ä¸å¼€å¤´çš„ G çš„ä¸ªæ•°ä¸èƒ½è¶…è¿‡ $k$ã€‚å¯ä»¥å‘ç°å¯¹äºæ¯ä¸€ç»„æ•°æ®ï¼Œæˆ‘ä»¬åªè¦é¢„å¤„ç†ä¸€é $g$ å°±å¯ä»¥è¿›è¡Œè®¡ç®—äº†ï¼Œæœ€ç»ˆç­”æ¡ˆä¸ºï¼š\n$$ \\begin{aligned} \\frac{1}{n} \\sum_{i=1}^{n}g[\\gcd(i,n)] \u0026amp; = \\frac{1}{n} \\sum_{d\\mid n}g[d]\\sum_{i=1}^{n}[\\gcd(i,n)=d]\\\\ \u0026amp; = \\frac{1}{n} \\sum_{d\\mid n}g[d] \\varphi(\\frac{n}{d}) \\end{aligned} $$\nå•ç»„æ•°æ®çš„æ—¶é—´å¤æ‚åº¦ä¸º $\\Theta(nk+d(n)\\sqrt{n})$ã€‚\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAX_N = 2000 + 10; constexpr int MAX_K = 2000 + 10; constexpr int MOD = 1e8 + 7; int t, n, k; int f[MAX_N][2], sum[MAX_N], g[MAX_N]; int power(int x, int y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % MOD; x = 1ll * x * x % MOD; } return res; } int phi(int x) { int res = x; for (int i = 2; i * i \u0026lt;= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } void dp() { for (int i = 1; i \u0026lt;= n; ++i) g[i] = 0; for (int t = 0; t \u0026lt;= k; ++t) { for (int i = 0; i \u0026lt;= n; ++i) { f[i][0] = f[i][1] = 0; sum[i] = 0; } f[t][1] = 1; if (k \u0026gt;= n) g[t] = (g[t] + f[t][1]) % MOD; for (int i = t + 1; i \u0026lt;= n; ++i) { f[i][0] = (f[i - 1][0] + f[i - 1][1]) % MOD; f[i][1] = (sum[i - 1] - sum[max(i - k - 1, 0)] + MOD) % MOD; sum[i] = (sum[i - 1] + f[i][0]) % MOD; g[i] = ((g[i] + f[i][0]) % MOD + (sum[i - 1] - sum[max(i - (k - t) - 1, 0)] + MOD)) % MOD; } } } int solve() { int ans = 0; dp(); for (int i = 1; i * i \u0026lt;= n; ++i) { if (n % i) continue; if (i * i == n) { ans = (ans + 1ll * g[i] * phi(n / i)) % MOD; } else { ans = (ans + 1ll * g[i] * phi(n / i)) % MOD; ans = (ans + 1ll * g[n / i] * phi(i)) % MOD; } } ans = 1ll * ans * power(n, MOD - 2) % MOD; return ans; } int main() { cin \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= t; ++i) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; cout \u0026lt;\u0026lt; solve() \u0026lt;\u0026lt; endl; } return 0; }  POJ 2888 Magic Bracelet  æœ‰ä¸€ä¸ª $n$ é¢—é­”æ³•ç å­ç»„æˆçš„é­”æ³•æ‰‹é•¯ã€‚æœ‰ $m$ ç§ä¸åŒçš„é­”æ³•ç ã€‚æ¯ä¸€ç§ç å­éƒ½æ˜¯æ— é™çš„ã€‚å°†è®¸å¤šç å­ä¸²åœ¨ä¸€èµ·ï¼Œå°±å¯ä»¥åˆ¶æˆä¸€ä¸ªç¾ä¸½çš„åœ†å½¢é­”æ³•æ‰‹é•¯ã€‚æŸäº›ç§ç±»çš„ç å­ä¼šç›¸äº’ä½œç”¨å¹¶çˆ†ç‚¸ï¼Œä½ å¿…é¡»éå¸¸å°å¿ƒä»¥ç¡®ä¿è¿™äº›ç å­ä¸ä¼šä¸²åœ¨ä¸€èµ·ã€‚\nå¦‚æœå¿½ç•¥å›´ç»•æ‰‹é•¯ä¸­å¿ƒæ—‹è½¬äº§ç”Ÿçš„é‡å¤ï¼Œä½ å¯ä»¥åˆ¶ä½œå¤šå°‘ä¸ªä¸åŒçš„æ‰‹é•¯ï¼Ÿç­”æ¡ˆå¯¹ $9973$ å–æ¨¡ã€‚\n$1\\le n\\le 10^9$ï¼Œ$\\gcd(n, 9973)=1$ï¼Œ$1\\le m\\le 10$ï¼Œ$1\\le k\\le \\frac{m(m-1)}{2}$ã€‚\n ä¸ä¸Šä¸€é¢˜çš„åˆ†ææ€è·¯ç±»ä¼¼ï¼Œä¸åŒçš„æ˜¯å¯¹äºæ¯ä¸ªç½®æ¢ $f_i$ï¼Œéœ€è¦æ±‚ $[1,\\gcd(i,n)]$ å¤´å°¾ç›¸æ¥ä¸”æ»¡è¶³åˆ¶çº¦æ¡ä»¶çš„æ–¹æ¡ˆæ•°ã€‚\næšä¸¾å¼€å¤´çš„ç å­ï¼Œè®¾ $f[t][i][j]$ ä¸ºå¼ºåˆ¶ $t$ å¼€å¤´ï¼Œåˆ°ç¬¬ $i$ ä½æ—¶é€‰æ‹©ç¬¬ $j$ ç§ç å­ï¼Œ$valid[i][j]$ è¡¨ç¤º $i,j$ ä¸¤ç§ç å­ç›¸é‚»æ˜¯å¦åˆæ³•ï¼Œ$g[i]$ ä¸ºå°† $[1,i]$ å¤´å°¾ç›¸è¿çš„åˆæ³•æ–¹æ¡ˆæ•°ã€‚\n$$ f[t][1][i]=[t=i]\\\\ f[t][i][j]=\\sum_{valid(j,k)}f[t][i-1][k]\\\\ g[i]=\\sum_{valid(t,j)} f[t][i][j] $$\nå®é™…è½¬ç§»æ˜¯å¯ä»¥å»æ‰ $t$ è¿™ä¸€ç»´ã€‚$n$ ç‰¹åˆ«å¤§ï¼Œå»æ‰ $t$ åå‘ç°æ˜¯ä¸€ä¸ªçŸ©é˜µä¹˜æ³•çš„å½¢å¼ï¼Œäºæ˜¯æ„é€ åˆå§‹çŸ©é˜µ $F_t$ å’Œè½¬ç§»çŸ©é˜µ $T$ï¼š\n$$ F_t= \\begin{bmatrix} f[t][1][1] \u0026amp; f[t][1][2] \u0026amp; \\cdots \u0026amp; f[t][1][m] \\end{bmatrix} $$ $$ T= \\begin{bmatrix} valid[1][1] \u0026amp; valid[2][1] \u0026amp; \\cdots \u0026amp; valid[m][1]\\\\ valid[1][2] \u0026amp; valid[2][2] \u0026amp; \\cdots \u0026amp; valid[m][2]\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots\\\\ valid[1][m] \u0026amp; valid[2][m] \u0026amp; \\cdots \u0026amp; valid[m][m] \\end{bmatrix} $$\næ±‚ $g[x]$ï¼Œåˆ™ç”¨çŸ©é˜µå¿«é€Ÿå¹‚ç®—å‡º $F_t\\times T^{x-1}$ ä¼˜åŒ– DPï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $\\Theta(m^3\\log_2x)$ã€‚\næœ€ç»ˆç­”æ¡ˆä¸º\n$$ \\begin{aligned} \\frac{1}{n} \\sum_{i=1}^{n}g[\\gcd(i,n)] \u0026amp; = \\frac{1}{n} \\sum_{d\\mid n}g[d]\\sum_{i=1}^{n}[\\gcd(i,n)=d]\\\\ \u0026amp; = \\frac{1}{n} \\sum_{d\\mid n}g[d] \\varphi(\\frac{n}{d}) \\end{aligned} $$\nå•ç»„æ•°æ®æ—¶é—´å¤æ‚åº¦ä¸º $\\Theta(d(n)(m^3\\log_2x+\\sqrt{n}))$ã€‚\nå€¼å¾—ä¸€æçš„æ˜¯ï¼ŒPOJ çš„è¯„æµ‹ç¯å¢ƒå·²ç»å¾ˆä¹…æ²¡æœ‰å‡çº§è¿‡äº†ï¼Œè¯„æµ‹é€Ÿåº¦å·¨æ…¢ï¼Œè€Œä¸”ç°åœ¨è¿˜åœ¨ä½¿ç”¨ C++ 98ï¼Œå®˜æ–¹ç»™å‡ºçš„è§£é‡Šæ˜¯ï¼š\n Currently there is no plan to enable the experimental C++0x features before the new C++ standard is officially published and relatively well-supported.\n æ‰€ä»¥æ¥ä¸‹æ¥çš„ä»£ç åœ¨ POJ æ— æ³•é€šè¿‡ï¼Œä½†å·²ç»åœ¨å­¦æ ¡çš„è‡ªå»º OJ é€šè¿‡äº†ï¼ŒCPU ä¸º Intel(R) Core(TM) i5-8265Uï¼Œæ¯ä¸ªæµ‹è¯•ç‚¹å¹³å‡æ—¶é—´ä¸è¶…è¿‡ $80\\ \\text{ms}$ï¼Œæ‰€ä»¥å…¶å®æ˜¯å¾ˆä¼˜ç§€çš„ã€‚æ ¹æ®å®é™…æƒ…å†µï¼ŒPOJ çš„è¯„æµ‹è®°å½•å·²ä¸å…·æœ‰å‚è€ƒæ€§ï¼Œæ‰€ä»¥å°±ç›´æ¥ç»™å‡ºæ— æ³•é€šè¿‡çš„ä»£ç ã€‚\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAX_M = 10 + 1; constexpr int MOD = 9973; class Matrix { public: Matrix(int row = 0, int column = 0) { this-\u0026gt;row = row; this-\u0026gt;column = column; for (int i = 1; i \u0026lt;= row; ++i) for (int j = 1; j \u0026lt;= column; ++j) data[i][j] = 0; } void unit() { for (int i = 1; i \u0026lt;= row; ++i) for (int j = 1; j \u0026lt;= column; ++j) data[i][j] = (i == j); } int * operator[](int x) { return data[x]; } const int * operator[](int x) const { return data[x]; } Matrix operator*(const Matrix \u0026amp; rhs) const { Matrix res(row, rhs.column); for (int i = 1; i \u0026lt;= row; ++i) for (int j = 1; j \u0026lt;= rhs.column; ++j) for (int k = 1; k \u0026lt;= column; ++k) res[i][j] = (res[i][j] + data[i][k] * rhs[k][j]) % MOD; return res; } Matrix operator^(int exp) const { Matrix res(row, row), base(*this); res.unit(); for (; exp; exp /= 2) { if (exp % 2) res = res * base; base = base * base; } return res; } private: int row, column; int data[MAX_M][MAX_M]; }; int t, n, m, k; bool valid[MAX_M][MAX_M]; int power(int x, int y) { x %= MOD; int res = 1; for (; y; y /= 2) { if (y % 2) res = res * x % MOD; x = x * x % MOD; } return res; } int phi(int x) { int res = x; for (int i = 2; i * i \u0026lt;= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } int dp(int t, int k) { Matrix f(1, m), trans(m, m); int res = 0; f[1][t] = 1; for (int i = 1; i \u0026lt;= m; ++i) for (int j = 1; j \u0026lt;= m; ++j) trans[j][i] = valid[i][j]; f = f * (trans ^ (k - 1)); for (int i = 1; i \u0026lt;= m; ++i) if (valid[t][i]) res += f[1][i]; return res % MOD; } int calc(int k) { int res = 0; for (int i = 1; i \u0026lt;= m; ++i) res += dp(i, k); return res % MOD; } int solve() { int ans = 0; for (int i = 1; i * i \u0026lt;= n; ++i) { if (n % i) continue; if (i * i == n) { ans = (ans + 1ll * calc(i) * phi(n / i)) % MOD; } else { ans = (ans + 1ll * calc(i) * phi(n / i)) % MOD; ans = (ans + 1ll * calc(n / i) * phi(i)) % MOD; } } return ans * power(n, MOD - 2) % MOD; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= m; ++i) for (int j = 1; j \u0026lt;= m; ++j) valid[i][j] = true; for (int i = 1; i \u0026lt;= k; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; valid[x][y] = valid[y][x] = false; } cout \u0026lt;\u0026lt; solve() \u0026lt;\u0026lt; endl; } return 0; }  ","id":6,"section":"posts","summary":"Burnside å¼•ç†å’Œ PÃ³lya å®šç†ä¸»è¦ç”¨äºè§£å†³è®¡ç®—æœ¬è´¨ä¸åŒæ–¹æ¡ˆæ•°çš„è®¡æ•°é—®é¢˜ã€‚ ç¾¤è®º åŸºæœ¬å®šä¹‰ ç¾¤å¯ä»¥çœ‹æˆæ˜¯ä¸€ä¸ªç”±é›†åˆå’ŒæŸä¸ªäºŒå…ƒè¿ç®—ç»„æˆçš„äºŒå…ƒç»„ $(S,\\cdo","tags":["OI","æ•°å­¦","ç¾¤è®º","ç½®æ¢ç¾¤","Burnside å¼•ç†","PÃ³lya å®šç†","C++"],"title":"Burnside å¼•ç† \u0026 PÃ³lya å®šç†å­¦ä¹ ç¬”è®°","uri":"https://ctj12461.vercel.app/contents/20220212-burnside-lemma-and-polya-theorem-note/","year":"2022"},{"content":"æ¬§æ‹‰å‡½æ•° $\\varphi(n)$ æ˜¯ä¸€ä¸ªé‡è¦çš„æ•°è®ºå‡½æ•°ï¼Œå®ƒè¡¨ç¤º $[1, n]$ ä¸­ä¸ $n$ äº’è´¨çš„æ•°çš„ä¸ªæ•°ã€‚\næ¬§æ‹‰å‡½æ•°æ€§è´¨ ç§¯æ€§å‡½æ•° ç§¯æ€§å‡½æ•°çš„å®šä¹‰æ˜¯ï¼šå¦‚æœä¸€ä¸ªå‡½æ•° $f(n)$ æ»¡è¶³ $\\gcd(a,b)=1$ æ—¶ $f(ab)=f(a)f(b)$ï¼Œåˆ™ $f(n)$ ä¸ºç§¯æ€§å‡½æ•°ã€‚ è‹¥æ— éœ€ $\\gcd(a,b)=1$ å°±æœ‰ $f(ab)=f(a)f(b)$ï¼Œåˆ™å®ƒä¸ºå®Œå…¨ç§¯æ€§å‡½æ•°ã€‚\n$$ n = \\prod p_i^{c_i}\\\\ f(n) = \\prod f(p_i^{c_i}) $$\nä¸€èˆ¬æ¥è¯´ï¼Œå„ç§ç§¯æ€§å‡½æ•°éƒ½æ˜¯å¯ä»¥ä½¿ç”¨æ¬§æ‹‰ç­›è®¡ç®—å‡ºæ¥çš„ï¼Œå°½ç®¡æ–¹æ³•å„ä¸ç›¸åŒã€‚\n$\\varphi(n)$ ä¹Ÿæ˜¯ç§¯æ€§å‡½æ•°ï¼Œè¯æ˜å°±çœç•¥äº†ã€‚\nè®¡ç®—å…¬å¼ å› ä¸º $\\varphi(n)$ æ˜¯ç§¯æ€§å‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å…ˆç ”ç©¶ $\\varphi(p^k)$ æ€ä¹ˆè®¡ç®—ã€‚$p^k$ çš„çº¦æ•°æœ‰ $1, p, p^2, \\dots, p^k$ï¼Œè€Œ $p^2, \\dots, p^k$ éƒ½å«æœ‰ $p$ è¿™ä¸ªçº¦æ•°ï¼Œå¦‚æœä¸€ä¸ªæ•°ä¸ä¸ $p^k$ äº’è´¨ï¼Œåˆ™ä¸€ç‚¹æœ‰ $p$ è¿™ä¸ªçº¦æ•°ï¼Œæˆ‘ä»¬åªæœ‰çŸ¥é“å°äºç­‰äº $p^k$ çš„æ•°ä¸­ $p$ çš„å€æ•°æœ‰å¤šå°‘å³å¯ã€‚ç”±æ­¤å¾—å‡º $\\varphi(n) = p^k - \\frac{p^k}{p} = p^k - p^{k-1}=p^k\\frac{p-1}{p}$ã€‚\næ ¹æ® $\\varphi(n)$ çš„ç§¯æ€§å‡½æ•°æ€§è´¨ï¼Œå¾—å‡ºå¯¹äºä»»æ„çš„ $n$ï¼š\n$$ \\begin{aligned} \\varphi(n) \u0026amp; = \\prod p_i^{c_i} \\frac{p_i - 1}{p_i} \\\\ \u0026amp; = n \\prod \\frac{p_i-1}{p_i} \\\\ \u0026amp; = n \\prod (1 - \\frac{1}{p_i}) \\end{aligned} $$\næ±‚å’Œå¼ Formula 1 $$ n = \\sum_{d \\mid n} \\varphi(d) $$\nè€ƒè™‘è®¾å‡½æ•° $f(x, n)=\\sum_{i=1}^{n}[\\gcd(i,n)=x]$ï¼Œåˆ™ï¼š\n$$ n=\\sum_{d \\mid n} f(d,n) $$\nåˆå› ä¸ºè‹¥ $\\gcd(i,n)=x$ï¼Œåˆ™ $\\gcd(\\frac{i}{x},{\\frac{n}{x}})=1$ï¼Œæ‰€ä»¥ $f(x,n)=\\varphi(\\frac{n}{x})$ã€‚å¸¦å›åŸå¼ï¼š\n$$ n=\\sum_{d \\mid n}\\varphi(\\frac{n}{d}) $$\nå› ä¸º $d$ ä¸ $\\frac{n}{d}$ æ˜¯ä¸€èµ·å‡ºç°çš„ï¼Œæ‰€ä»¥ä¸Šå¼ç­‰ä»·äºåŸå¼ã€‚\nFormula 2 $$ \\sum_{i=1}^{n} \\sum_{j=1}^{n} [\\gcd(i,j)=1]=\\sum_{i=1}^{n}2\\varphi(i)-1 $$\nè‹¥æˆ‘ä»¬ä»…è€ƒè™‘ $j\\le i$ï¼Œåˆ™å¯ä»¥å›ºå®šæ¯ä¸ª $i$ è€ƒè™‘ï¼Œå¯¹äºæ¯ä¸ª $i$ï¼Œä¸å…¶äº’è´¨çš„ $j$ æœ‰ $\\varphi(i)$ ä¸ªï¼Œå…¨éƒ¨çš„å’Œæ˜¾ç„¶ä¸º $\\sum_{i=1}^{n} \\varphi(i)$ã€‚å¯¹äº $j \\ge i$ çš„æƒ…å†µï¼Œå¯ä»¥å‘ç° $j,i$ ç›¸å½“äºå‰ä¸€ç§æƒ…å†µçš„ $i,j$ï¼Œå˜æ¢æ±‚å’Œé¡ºåºåå…¶å®æ˜¯ç­‰ä»·çš„ï¼Œå³ï¼š\n$$ \\sum_{i=1}^{n} \\sum_{j=i}^{n} [\\gcd(i,j)=1]=\\sum_{j=1}^{n} \\sum_{i=1}^{j} [\\gcd(i,j)=1] $$\nå·¦å³èƒ½å¤Ÿæšä¸¾åˆ°çš„ $(i,j)$ æ˜¯ä¸€æ ·çš„ï¼Œåˆå› ä¸ºåªæœ‰ $1$ ä¸æœ¬èº«äº’è´¨ï¼Œåˆ™åŸå¼ç­‰ä»·äºä¸¤ç§æƒ…å†µç›¸åŠ å†æ‰£é™¤ä¸€ä¸ª $1$ çš„é‡å¤ã€‚\nFormula 3 $$ \\sum_{i=1}^{n}i[\\gcd(i,n)=1]=\\frac{n\\varphi(n)}{2} $$\næ ¹æ®æ›´ç›¸å‡æŸæœ¯ $\\gcd(a,b)=\\gcd(b,a-b)$ï¼Œå¯ä»¥çŸ¥é“è‹¥ $\\gcd(i,n)=1$ï¼Œåˆ™ $\\gcd(n-i,n)=1$ï¼Œä¹Ÿå°±æ˜¯ä¸ $n$ äº’è´¨çš„æ•°æ˜¯æˆå¯¹å‡ºç°çš„ï¼Œä¸”æ¯ä¸€å¯¹çš„å’Œéƒ½ä¸º $n$ï¼Œè€ƒè™‘å¤´å°¾ç›¸åŠ ï¼Œä»¿ç…§ç­‰å·®æ•°åˆ—çš„æ±‚å’Œå…¬å¼ï¼š\n$$ \\begin{aligned} \u0026amp; \\sum_{i=1}^{n}i[\\gcd(i,n)=1] + \\sum_{i=1}^{n}(n-i)[\\gcd(n-i,n)=1]\\\\ = \u0026amp;\\sum_{i=1}^{n} n[\\gcd(i,n)=1]\\\\ = \u0026amp;n\\varphi(n) \\end{aligned}\\\\ $$\næ‰€ä»¥ä¸¤è¾¹é™¤ä»¥ $2$ å¾—å‡ºï¼š\n$$ \\sum_{i=1}^{n}i[\\gcd(i,n)=1]=\\frac{n\\varphi(n)}{2} $$\nç­›æ³• ä½¿ç”¨æ¬§æ‹‰ç­›æ—¶éšä¾¿æ±‚å‡ºå³å¯ã€‚å‡è®¾å¾ªç¯åˆ° $i$ï¼š\n è‹¥ $i$ ä¸ºè´¨æ•°ï¼Œåˆ™ $\\varphi(i)=i-1$ è‹¥ $p_j \\nmid i$ï¼Œåˆ™ $\\gcd(p_j,i)=1$ï¼Œæ ¹æ®ç§¯æ€§å‡½æ•°æ€§è´¨ï¼Œ$\\varphi(ip_j)=\\varphi(i)\\varphi(p_j)=(p_j-1)\\varphi(i)$ è‹¥ $p_j \\mid i$ï¼Œåˆ™ $\\gcd(p_j,i)\\ne 1$ï¼Œ$i$ ä¸­å·²æœ‰ $p_j$ è¿™ä¸ªçº¦æ•°ï¼Œæ ¹æ®è®¡ç®—å…¬å¼ï¼Œåªè¦ä¹˜ä¸€æ¬¡$\\frac{p_j-1}{p_j}$ï¼Œåˆ™ $\\varphi(ip_j)=p_j\\varphi(i)$  ä»£ç å®ç° å•æ¬¡æ±‚è§£ int phi(int x) { int res = x; for (int i = 2; i * i \u0026lt;= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; }  æ¬§æ‹‰ç­› void sieve(int n) { notPrime[1] = true; for (int i = 2; i \u0026lt;= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; phi[i] = i - 1; } for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * prime[j] \u0026lt;= n; ++j) { notPrime[i * prime[j]] = true; if (i % prime[j]) { phi[i * prime[j]] = phi[i] * (prime[j] - 1); } else { phi[i * prime[j]] = phi[i] * prime[j]; break; } } } }  æ¬§æ‹‰å®šç† å®šç†å†…å®¹ æ™®é€š $$ a^{\\varphi(m)} \\equiv 1 \\pmod{m}\\ (\\gcd(a,m)=1) $$\næ‰©å±• $$ a^b \\equiv \\begin{cases} a^{b \\bmod \\varphi(m)} \u0026amp; \\gcd(a,m)=1\\\\ a^{b} \u0026amp; \\gcd(a,m)\\ne 1 \\wedge b \u0026lt; \\varphi(m)\\\\ a^{b \\bmod \\varphi(m) + \\varphi(m)} \u0026amp; \\gcd(a,m)\\ne 1 \\wedge b \\ge \\varphi(m) \\end{cases} \\pmod{m} $$\nåº”ç”¨ é€†å…ƒ $$ a^{\\varphi(m)}\\equiv a\\cdot a^{\\varphi(m)-1}\\equiv 1 \\pmod{m}\\ (\\gcd(a,m)=1) $$\nå½“ $\\gcd(a,m)=1$ æ—¶ï¼Œ$a^{\\varphi(m)-1}$ å°±æ˜¯ $a$ çš„é€†å…ƒã€‚è´¹é©¬å°å®šç†å°±æ˜¯å…¶ç‰¹æ®Šæƒ…å†µã€‚\né™å¹‚ æœ‰æ—¶å¹‚çš„æŒ‡æ•°æ’å¤§ï¼Œå¿«é€Ÿå¹‚çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿæ— æ³•æ¥å—ï¼Œè¿™æ—¶å¯ä»¥ä½¿ç”¨æ‰©å±•æ¬§æ‹‰å®šç†å¯¹æŒ‡æ•°è¿›è¡Œå–æ¨¡å‡å°ï¼Œä¼˜åŒ–ç®—æ³•ã€‚\nå¹‚æ¬¡å¹‚ æœ‰æ—¶é¢˜ç›®è¦æ±‚ç±»ä¼¼ $a^{b_1^{b_2^{\\cdots}}}$ çš„å¼å­ï¼Œä¸€èˆ¬ç›´æ¥å¤„ç†æŒ‡æ•°ä¸åº•æ•°çš„å…³ç³»æ˜¯ä¸å¯åšçš„ï¼Œè¿™æ—¶å°±å¯ä»¥ä½¿ç”¨æ‰©å±•æ¬§æ‹‰å®šç†ï¼ŒåŒæ—¶ç”±äºå¤åˆæ¬§æ‹‰å‡½æ•° $\\varphi(\\varphi(\\dots\\varphi(n)\\dots))$ çš„å€¼å˜ä¸º $1$ çš„æ¬¡æ•°æ˜¯ $O(\\log_2 n)$ çš„ï¼Œæ‰€ä»¥ä¹Ÿåªéœ€è¦ç”¨ $O(\\log_2 n)$ æ‰©å±•æ¬§æ‹‰å®šç†ï¼ŒæŸä¸€å±‚çš„æŒ‡æ•°å°±ä¼šå˜ä¸º $0$ï¼Œé…åˆå¿«é€Ÿå¹‚ï¼Œæ€»ä½“çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\\log_2^2 n)$ã€‚\nä¾‹é¢˜ Luogu P2158 ä»ªä»—é˜Ÿ  ç»™å‡ºä¸€ä¸ª $n \\times n$ çš„ç‚¹é˜µï¼Œä»å·¦ä¸‹è§’è§‚å¯Ÿï¼Œä¸€ä¸ªç‚¹èƒ½å¤Ÿè¢«è§‚å¯Ÿåˆ°å½“ä¸”ä»…å½“å…¶ä¸å·¦ä¸‹è§’çš„ç‚¹çš„è¿çº¿ä¸Šæ²¡æœ‰å…¶ä»–çš„ç‚¹ï¼Œå°±èƒ½å¤Ÿè¢«è§‚å¯Ÿåˆ°çš„ç‚¹çš„ä¸ªæ•°ï¼ˆå·¦ä¸‹è§’çš„ç‚¹ä¸ç®—ï¼‰ã€‚\n\n$1\\le n \\le 40000$ã€‚\n å®¹æ˜“çœ‹å‡ºå·¦ä¸Šéƒ¨åˆ†å’Œå³ä¸‹éƒ¨åˆ†çš„ç­”æ¡ˆç›¸åŒï¼Œå…ˆè€ƒè™‘å³ä¸‹ï¼Œå¯¹ç‚¹é˜µå»ºåæ ‡ç³»ï¼Œå·¦ä¸‹è§’ä¸º $(0,1)$ï¼Œåˆ™åŠå¹³é¢ $x-y \\ge 0$ ä¸­çš„ç‚¹ $(x, y)$ è‹¥æ»¡è¶³ $\\gcd(x,y)=1$ï¼Œåˆ™å¯ä»¥è¢«è§‚å¯Ÿåˆ°ã€‚è¿™éƒ¨åˆ†ç­”æ¡ˆä¸º $\\sum_{i=1}^{n-1}\\varphi(i)$ï¼Œå·¦ä¸Šéƒ¨åˆ†ç­”æ¡ˆä¹Ÿæ˜¯è¿™ä¸ªï¼Œå›¾ä¸­è¿˜æœ‰ä¸€ä¸ªä½äº $(1,2)$ çš„ç‚¹æœªè¢«ç®—åˆ°ï¼Œå†åŠ  $1$ å³å¯ï¼Œæ€»ç­”æ¡ˆä¸ºï¼š\n$$ \\sum_{x=1}^{n-1} 2\\varphi(x)+1 $$\næ¬§æ‹‰ç­›æ±‚å‡ºæ¬§æ‹‰å‡½æ•°åç›´æ¥åŠ å³å¯ã€‚\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAXN = 40000 + 10; int n, ans = 1; bool notPrime[MAXN]; int tot, prime[MAXN], phi[MAXN]; void sieve(int n) { notPrime[1] = true; for (int i = 2; i \u0026lt;= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; phi[i] = i - 1; } for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * prime[j] \u0026lt;= n; ++j) { notPrime[i * prime[j]] = true; if (i % prime[j]) { phi[i * prime[j]] = phi[i] * (prime[j] - 1); } else { phi[i * prime[j]] = phi[i] * prime[j]; break; } } } } int main() { cin \u0026gt;\u0026gt; n; if (n == 1) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } sieve(n - 1); for (int i = 1; i \u0026lt;= n - 1; ++i) ans += 2 * phi[i]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  Luogu P2303 Longge çš„é—®é¢˜  ç»™å®šä¸€ä¸ªæ•´æ•° $n$ï¼Œä½ éœ€è¦æ±‚å‡º $\\sum_{i=1}^{n} \\gcd(i,n)$ã€‚\n$1\\le n\u0026lt; 2^{32}$\n æ¨å¼å­ï¼Œè€ƒè™‘æšä¸¾ $d$ ä½œä¸º $\\gcd(i,n)$ï¼š\n$$ \\begin{aligned} \\sum_{i=1}^{n} \\gcd(i,n)\u0026amp;=\\sum_{d \\mid n}d\\sum_{i=1}^{n}[\\gcd(i,n)=d]\\\\ \u0026amp;=\\sum_{d \\mid n}d\\sum_{i=1}^{n}[\\gcd(\\frac{i}{d},\\frac{n}{d})=1]\\\\ \u0026amp;=\\sum_{d \\mid n}d\\sum_{i=1}^{\\frac{n}{d}}[\\gcd(i,\\frac{n}{d})=1]\\\\ \u0026amp;=\\sum_{d \\mid n}d\\varphi(\\frac{n}{d}) \\end{aligned} $$\næšä¸¾çº¦æ•° $d$ï¼Œå†è®¡ç®— $\\varphi$ å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ $O(d(n)\\varphi(n))$ï¼Œ$d(n)$ è¡¨ç¤º $n$ çš„çº¦æ•°ä¸ªæ•°ï¼Œå®é™…ä¸Šè·‘å¾—å¾ˆå¿«ã€‚\n#include \u0026lt;iostream\u0026gt; using namespace std; long long n, ans; long long phi(long long x) { long long res = x; for (long long i = 2; i * i \u0026lt;= n; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } int main() { long long i; for (i = 1; i * i \u0026lt; n; ++i) if (n % i == 0) ans += i * phi(n / i) + (n / i) * phi(i); if (i * i == n) ans += i * phi(i); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  Luogu P2350 å¤–æ˜Ÿäºº  è®¾ $\\varphi^x(n)$ ä¸ºå¯¹ $n$ æ±‚ $x$ æ¬¡æ¬§æ‹‰å‡½æ•°ï¼Œå³ï¼š $$ \\varphi^x(n)= \\begin{cases} \\varphi(n) \u0026amp; x=1\\\\ \\varphi^{x-1}(\\varphi(n)) \u0026amp; x\u0026gt;1 \\end{cases} $$ ç°åœ¨ç»™å‡º $n$ çš„å”¯ä¸€åˆ†è§£ $\\prod_{i=1}^{m}p_i^{q_i}$ï¼Œæ±‚å‡ºä¸€ä¸ªæœ€å°çš„ $x$ ä½¿å¾— $\\varphi^x(n)=1$ã€‚\n$test$ ç»„æ•°æ®ï¼Œ$1\\le test\\le 50$ï¼Œ$1\\le p_i\\le 10^5$ï¼Œ$1\\le q_i\\le 10^9$ï¼Œ$1\\le m\\le 2000$ã€‚\n é¦–å…ˆå¯ä»¥æ‰¾ä¸€äº›è§„å¾‹ï¼Œå¯¹äº $2^k$ è¿™ä¸€ç±»æ•°ï¼Œæ˜¾ç„¶æœ€å°çš„ $x=k$ï¼Œå› ä¸ºæ¯å¥—ä¸€å±‚æ¬§æ‹‰å‡½æ•°å°±ä¼šä½¿ $k$ å‡å° $1$ã€‚\nå¯¹äºå…¶ä»–ä¸ç­‰äº $2$ çš„è´¨æ•° $p$ï¼Œ$\\varphi(p)=p-1=2^{k\u0026rsquo;}\\prod p_i\u0026rsquo;^{c_i\u0026rsquo;}$ï¼Œ$\\varphi^2(p)=2^{k\u0026rsquo;+k\u0026rsquo;-1}\\prod p_i\u0026rsquo;\u0026rsquo;^{c_i\u0026rsquo;\u0026rsquo;}$ï¼Œ$\\varphi^3(p)=2^{k\u0026rsquo;+k\u0026rsquo;\u0026rsquo;+k\u0026rsquo;\u0026rsquo;\u0026rsquo;-2}\\prod p_i\u0026rsquo;\u0026rsquo;\u0026rsquo;^{c_i\u0026rsquo;\u0026rsquo;\u0026rsquo;}$ï¼Œä¾æ­¤ç±»æ¨ï¼Œå‘ç°å‡ ä¸ªæ€§è´¨ï¼š\n æ¯ä¸ªäº’è´¨çš„ $p_i^{c_i}$ åŒæ—¶å‡å° $c_i$ï¼Œæ ¹æ®æ¬§æ‹‰å‡½æ•°çš„å…¬å¼å¯ä»¥å¾—å‡º æ¯æ¬¡æ¯ä¸ª $p_i^{c_i}\\ (p_i\\ne 2)$ éƒ½ä¼šä½¿å‰é¢çš„æŸäº› $p_j^{c_j}$ çš„ $c_j$ å¢åŠ ï¼Œä¸” $p_j\u0026lt;p_i$ï¼Œä¸”ä¸€å®šæœ‰ä¸€ä¸ª $p_j=2$ã€‚ å¯¹äº $2^k$ï¼Œä¸è€ƒè™‘åé¢çš„ $p_i^{c_i}$ï¼Œæ¯æ¬¡ $k$ ä¼šè¢«å‡å° $1$ æœ€åä¸€ä¸ªè¢«æ¶ˆå»çš„è´¨å› æ•°ä¸€å®šæ˜¯ $2$  å‰ $3$ ä¸ªéƒ½å¾ˆå¥½ç†è§£ï¼Œæœ€åä¸€ä¸ªä½¿ç”¨åè¯æ³•ï¼Œå‡è®¾å­˜åœ¨ä¸€ä¸ªè´¨å› æ•° $p$ å¤§äº $2$ï¼Œä¸”ç»è¿‡ $t$ æ¬¡æ“ä½œåï¼Œ$2$ çš„æ¬¡æ•°å˜ä¸º $0$ï¼Œè€Œ $p$ çš„æ¬¡æ•°å¤§äº $0$ï¼Œè¿™ç§æƒ…å†µä¸‹è‹¥è¦æ»¡è¶³æœ€åä¸€ä¸ªè¢«æ¶ˆå»çš„è´¨å› æ•°ä¸æ˜¯ $2$ï¼Œåˆ™ $\\varphi^{t+1}(p)$ ä¸èƒ½æœ‰ $2$ çš„çº¦æ•°ï¼Œä¸æ€§è´¨ $2$ çŸ›ç›¾ï¼Œæ•…å‡è®¾ä¸æˆç«‹ã€‚\næ‰€ä»¥ï¼Œæ€»å…±çš„æ¶ˆé™¤æ¬¡æ•°å°±æ˜¯ $2$ çš„æ¬¡æ•°ï¼Œè¿™å¯å‘æˆ‘ä»¬è®¡ç®—æ¯ä¸ªè´¨å› æ•° $p_i$ æœ€åèƒ½å¤Ÿäº§ç”Ÿå¤šå°‘ä¸ª $2$ã€‚è®¾ $f[i]$ è¡¨ç¤º $i$ èƒ½å¤Ÿäº§ç”Ÿçš„ $2$ çš„ä¸ªæ•°ï¼Œåˆ™ï¼š\n$$ f[2]=1\\\\ f[p]=f[p-1]\\\\ f[p^k]=kf[p]\\\\ f[ap]=f[a]+f[p]\\\\ $$\nå…¶ä¸­ $p$ ä¸ºè´¨æ•°ï¼Œè¿™ä¸ª DP åœ¨æ¬§æ‹‰ç­›æ—¶æ±‚å‡ºå³å¯ã€‚æœ€åç­”æ¡ˆä¸ºï¼š\n$$ \\sum_{i=1}^{m}qf[p]+[2\\notin\\{p_1,p_2,\\dots,p_m\\}] $$\næ³¨æ„ç‰¹åˆ¤æœ€å¼€å§‹çš„ $n$ æ²¡æœ‰ $2$ çš„çº¦æ•°çš„æƒ…å†µï¼Œè¿™ä¸ªæ—¶å€™è¦å…ˆæ±‚ä¸€æ¬¡æ¬§æ‹‰å‡½æ•°æ¥è·å¾— $2$ çš„çº¦æ•°ã€‚\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAXP = 1e5 + 10; int t, m; int f[MAXP], prime[MAXP], tot; bool notprime[MAXP]; void preprocess(int n) { notprime[0] = notprime[1] = true; f[1] = 1; // è™½ç„¶ 1 ä¸èƒ½äº§ç”Ÿ 2ï¼Œä½†æ˜¯ä¸ºäº†æ–¹ä¾¿å¯ä»¥è¿™ä¹ˆå†™ for (int i = 2; i \u0026lt;= n; ++i) { if (!notprime[i]) { prime[++tot] = i; f[i] = f[i - 1]; } for (int j = 1; j \u0026lt;= tot; ++j) { if (i * prime[j] \u0026gt; n) break; notprime[i * prime[j]] = true; f[i * prime[j]] = f[i] + f[prime[j]]; if (i % prime[j] == 0) break; } } } void solve() { m = read(); bool found = false; long long ans = 0; for (int i = 1; i \u0026lt;= m; ++i) { int p, q; cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q; found |= (p == 2); ans += 1ll * f[p] * q; } ans += !found; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(false); preprocess(MAXP - 10); cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; }  Luogu P4139 ä¸Šå¸ä¸é›†åˆçš„æ­£ç¡®ç”¨æ³•  ç»™å‡º $p$ï¼Œæ±‚ä»¥ä¸‹å¼å­ï¼š $$ 2^{2^{2^{\\cdots}}} \\bmod p $$ å¯ä»¥çœ‹ä½œ $\\infty$ ä¸ª $2$ï¼Œå°½ç®¡è¿™ç§å¼å­ä¸æ˜¯å¾ˆä¸¥è°¨ã€‚\n$T$ ç»„æ•°æ®ï¼Œ$1\\le T \\le 10^3$ï¼Œ$1\\le p\\le 10^7$ã€‚\n ä½¿ç”¨æ‰©å±•æ¬§æ‹‰å®šç†ï¼ŒåŸå¼å¯ä»¥å†™æˆï¼š\n$$ 2^{2^{2^{\\cdots}}} \\bmod p= \\begin{cases} 2^{2^{2^{\\cdots}} \\bmod \\varphi(p)} \\bmod p \u0026amp; \\gcd(2,p)=1\\\\ 2^{2^{2^{\\cdots}} \\bmod \\varphi(p) + \\varphi(p)} \\bmod p \u0026amp; \\gcd(2,p)\\ne 1 \\end{cases} $$\nè¿™é‡ŒæŠŠ $2^{2^{2^{\\cdots}}}$ è§†ä¸º $\\infty$ï¼Œæ‰€ä»¥ä¸å­˜åœ¨ $2^{2^{2^{\\cdots}}}\u0026lt;\\varphi(p)$ çš„æƒ…å†µã€‚è®¾ $f(p) = 2^{2^{2^{\\cdots}}} \\bmod p$ï¼Œå°±å¯ä»¥æŠŠä¸Šé¢çš„å¼å­å†™æˆè¿™æ ·ï¼š\n$$ f(p)= \\begin{cases} 2^{f(\\varphi(p))} \\bmod p \u0026amp; \\gcd(2,p)=1\\\\ 2^{f(\\varphi(p)) + \\varphi(p)} \\bmod p \u0026amp; \\gcd(2,p)\\ne 1 \\end{cases} $$\nå½“ $p=1$ æ—¶ï¼Œ$f(p)=0$ã€‚å…ˆç­›å‡º $\\varphi(p)$ï¼Œå†ç”¨é€’å½’å®ç° $f(p)$ï¼Œ$f(p)$ åªä¼šé€’å½’ $(\\log_2 p)$ å±‚ï¼Œå¯ä»¥å†åŠ ä¸Šè®°å¿†åŒ–æœç´¢ã€‚æ—¶é—´å¤æ‚åº¦ $O(p+T\\log_2^2 p)$ã€‚\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAXP = 1e7 + 10; int t, p; int buc[MAXP]; int prime[MAXP], phi[MAXP], tot; bool notPrime[MAXP]; int gcd(int x, int y) { int t; while (y) { t = x; x = y; y = t % y; } return x; } int power(int x, int y, int p) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % p; x = 1ll * x * x % p; } return res; } void preprocess(int n) { notPrime[1] = true; for (int i = 2; i \u0026lt;= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; phi[i] = i - 1; } for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * prime[j] \u0026lt;= n; ++j) { notPrime[i * prime[j]] = true; if (i % prime[j]) { phi[i * prime[j]] = phi[i] * (prime[j] - 1); } else { phi[i * prime[j]] = phi[i] * prime[j]; break; } } } } int calc(int p) { if (buc[p] != -1) return buc[p]; int res; if (gcd(2, p) == 1) res = power(2, calc(phi[p]), p); else res = power(2, calc(phi[p]) + phi[p], p); buc[p] = res; return res; } int main() { ios::sync_with_stdio(false); preprocess(MAXP - 1); for (int i = 0; i \u0026lt; MAXP; ++i) buc[i] = -1; buc[1] = buc[2] = 0; cin \u0026gt;\u0026gt; t; while (t--) { int x; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; calc(x) \u0026lt;\u0026lt; endl; } return 0; }  Luogu P3747 ç›¸é€¢æ˜¯é—®å€™  ç»´æŠ¤ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•°ç»„ï¼Œè¿™ä¸ªæ•°ç»„çš„ä¸‹æ ‡ä¸ºä» $1$ åˆ° $n$ çš„æ­£æ•´æ•°ã€‚\nä¸€å…±æœ‰ $m$ ä¸ªæ“ä½œï¼Œå¯ä»¥åˆ†ä¸ºä¸¤ç§ï¼š\n 0 l rï¼Œå¯¹åŒºé—´ $[l,r]$ ä¸­çš„æ¯ä¸€ä¸ªæ•°è¿›è¡Œèµ‹å€¼ï¼š$a_i\\longleftarrow c^{a_i}$ï¼Œ$c$ ä¸ºä¸€å¸¸æ•°ã€‚ 1 l rï¼ŒæŸ¥è¯¢åŒºé—´ $[l,r]$ ä¸­çš„ $a_i$ ä¹‹å’Œå¯¹ $p$ å–æ¨¡çš„å€¼ã€‚  $1\\le n,m\\le 5\\times 10^4$ï¼Œ$1\\le p\\le 10^8$ï¼Œ$0\u0026lt;c\u0026lt;p$ï¼Œ$0\\le a_i \u0026lt; p$ã€‚\n æ€è·¯ä¸ä¸Šä¸€é¢˜æœ‰å¼‚æ›²åŒå·¥ä¹‹å¤„ï¼Œæ¯ä¸ªæ•°æœ€å¤šè¢«èµ‹å€¼ $O(\\log_2 p)$ æ¬¡åå°±å›ºå®šä¸å˜äº†ï¼Œç”¨çº¿æ®µæ ‘ç»´æŠ¤åŒºé—´å’Œä»¥åŠåŒºé—´çš„æœ€å°æ“ä½œæ¬¡æ•°ï¼Œæ¯æ¬¡ä¿®æ”¹åªå¤„ç†ä»ç„¶éœ€è¦è®¡ç®—çš„éƒ¨åˆ†ï¼Œæ€»æ—¶é—´å¤æ‚åº¦ $O(n\\log_2^3 p)$ï¼Œå¸¸æ•°å°å°±å¯ä»¥è¿‡å»äº†ã€‚\nè€ƒè™‘å»æ‰ä¸€ä¸ª $O(\\log_2 p)$ã€‚ç”±äº $\\varphi(p)$ å‡å°å¾—å¾ˆå¿«ï¼Œä»…éœ€è¦ $O(\\log_2 p)$ æ¬¡ï¼Œæ„å‘³ç€å¿«é€Ÿå¹‚çš„æ¨¡æ•°ä¹Ÿå¾ˆå°‘ï¼Œè€ƒè™‘å¯¹æ¯ä¸ªæ¨¡æ•° $M$ é¢„å¤„ç†å‡º $p_1[i]=M^i$ï¼Œ$p_2[i]=M^{10000i}$ï¼Œç„¶åå°±å¯ä»¥ $O(1)$ æ±‚å¹‚äº†ã€‚æ—¶é—´å¤æ‚åº¦ $O(n\\log_2^2 p)$ã€‚\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAXN = 5e4 + 10; constexpr int INFINITY = 0x3f3f3f3f; struct Node { int left, right; int cnt, sum; }; int n, m, p, c; int a[MAXN]; int seq[MAXN], g[MAXN], tot; Node tree[MAXN * 4]; int p1[10001], p2[10001], p3[32][10001], p4[32][10001]; int gcd(int x, int y) { int t; while (y) { t = x; x = y; y = t % y; } return x; } int powerImpl(int x, int y) { if (y == INFINITY) return INFINITY; int res = 1; for (; y; y /= 2) { if (y % 2) { if (x == INFINITY || 1ll * res * x \u0026gt;= p) return INFINITY; res = res * x; } if (x == INFINITY || 1ll * x * x \u0026gt;= p) x = INFINITY; else x = x * x; } return res; } int power(int y) { int y1 = y % 10000, y2 = y / 10000; if (p1[y1] == INFINITY || p2[y2] == INFINITY || 1ll * p1[y1] * p2[y2] \u0026gt;= p) return INFINITY; return p1[y1] * p2[y2]; } int power(int y, int id) { int y1 = y % 10000, y2 = y / 10000; return 1ll * p3[id][y1] * p4[id][y2] % seq[id]; } int powerImpl(int x, int y, int p) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % p; x = 1ll * x * x % p; } return res; } int phi(int x) { int res = x; for (int i = 2; i * i \u0026lt;= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } void preprocess() { int x = p; while (seq[tot] != 1) { seq[++tot] = x; x = phi(x); } for (int i = 1; i \u0026lt;= tot; ++i) g[i] = gcd(seq[i], c); for (int i = 0; i \u0026lt;= 10000; ++i) { p1[i] = powerImpl(c, i); p2[i] = powerImpl(c, i * 10000); } for (int i = 1; i \u0026lt;= tot; ++i) { for (int j = 0; j \u0026lt;= 10000; ++j) { p3[i][j] = powerImpl(c, j, seq[i]); p4[i][j] = powerImpl(c, j * 10000, seq[i]); } } } // æ ¸å¿ƒéƒ¨åˆ†ï¼Œåˆ©ç”¨æ‰©å±•æ¬§æ‹‰å®šç†æ±‚å¹‚æ¬¡å¹‚ // è¿”å›å€¼ä¸€ä¸ªæ˜¯ç­”æ¡ˆï¼Œä¸€ä¸ªæ˜¯ç”¨äºå¤„ç†ä¸ phi(p) çš„å¤§å°å…³ç³» pair\u0026lt;int, int\u0026gt; calc(int dep, int lim, int a) { // phi çš„å€¼å·²ç»ä¸º 1 if (dep == tot) { int prod = a; for (int i = lim; i \u0026gt;= dep; --i) { prod = power(prod); // ç”¨æ— ç©·å¤§è¡¨ç¤ºè¶…è¿‡ p çš„æƒ…å†µ if (prod == INFINITY) return { 0, INFINITY }; } return { 0, prod }; } // å·²ç»åˆ° a_iï¼Œæ— æ³•ç»§ç»­é€’å½’ if (dep == lim + 1) return { a % seq[dep], a }; auto [res, prod] = calc(dep + 1, lim, a); // seq[i] è¡¨ç¤ºå¯¹ p æ±‚ i æ¬¡æ¬§æ‹‰å‡½æ•°çš„ç»“æœ // g[i] è¡¨ç¤º c ä¸ seq[i] çš„ gcd if (g[dep] == 1) res = power(res, dep); else if (prod \u0026gt;= seq[dep + 1]) res = power(res + seq[dep + 1], dep); else res = power(prod, dep); prod = power(prod); return { res, prod }; } inline void pushup(int x) { tree[x].sum = (tree[x * 2].sum + tree[x * 2 + 1].sum) % p; tree[x].cnt = min(tree[x * 2].cnt, tree[x * 2 + 1].cnt); } void build(int x, int l, int r) { tree[x].left = l; tree[x].right = r; if (l == r) { tree[x].sum = a[l]; return; } int mid = (l + r) / 2; build(x * 2, l, mid); build(x * 2 + 1, mid + 1, r); pushup(x); } void modify(int x, int l, int r) { if (tree[x].cnt \u0026gt;= tot || tree[x].right \u0026lt; l || r \u0026lt; tree[x].left) return; if (tree[x].left == tree[x].right) { ++tree[x].cnt; tree[x].sum = calc(1, tree[x].cnt, a[tree[x].left]).first; return; } int mid = (tree[x].left + tree[x].right) / 2; if (l \u0026lt;= mid) modify(x * 2, l, r); if (mid \u0026lt; r) modify(x * 2 + 1, l, r); pushup(x); } int query(int x, int l, int r) { if (l \u0026lt;= tree[x].left \u0026amp;\u0026amp; tree[x].right \u0026lt;= r) return tree[x].sum; int mid = (tree[x].left + tree[x].right) / 2, res = 0; if (l \u0026lt;= mid) res = (res + query(x * 2, l, r)) % p; if (mid \u0026lt; r) res = (res + query(x * 2 + 1, l, r)) % p; return res; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; p \u0026gt;\u0026gt; c; preprocess(); for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; build(1, 1, n); for (int i = 1; i \u0026lt;= m; ++i) { int op, l, r; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; if (op == 0) modify(1, l, r); else cout \u0026lt;\u0026lt; query(1, l, r) \u0026lt;\u0026lt; endl; } return 0; }  ","id":7,"section":"posts","summary":"æ¬§æ‹‰å‡½æ•° $\\varphi(n)$ æ˜¯ä¸€ä¸ªé‡è¦çš„æ•°è®ºå‡½æ•°ï¼Œå®ƒè¡¨ç¤º $[1, n]$ ä¸­ä¸ $n$ äº’è´¨çš„æ•°çš„ä¸ªæ•°ã€‚ æ¬§æ‹‰å‡½æ•°æ€§è´¨ ç§¯æ€§å‡½æ•° ç§¯æ€§å‡½æ•°çš„å®šä¹‰æ˜¯ï¼šå¦‚æœä¸€ä¸ªå‡½æ•° $f(n)$ æ»¡è¶³ $\\gcd(a,b)=1$ æ—¶ $f(ab)=f","tags":["OI","æ•°å­¦","æ•°è®º","æ¬§æ‹‰å‡½æ•°","æ¬§æ‹‰å®šç†","C++"],"title":"æ¬§æ‹‰å‡½æ•° \u0026 æ¬§æ‹‰å®šç†å­¦ä¹ ç¬”è®°","uri":"https://ctj12461.vercel.app/contents/20220210-euler-function-and-euler-theorem-note/","year":"2022"},{"content":"æ‹‰æ ¼æœ—æ—¥æ’å€¼æ˜¯ä¼—å¤šæ’å€¼ç®—æ³•ä¸­çš„ä¸€ç§ï¼Œæ’å€¼æ˜¯é€šè¿‡ä¸€äº›ç‚¹æ¥æ±‚å‡ºè¿‡è¿™äº›ç‚¹çš„å¤šé¡¹å¼å‡½æ•°çš„è¿‡ç¨‹ã€‚\nç®—æ³•æ€æƒ³ æ„é€ å‡½æ•° ç»™å‡º $n + 1$ ä¸ªç‚¹ $(x_1,y_1),(x_2,y_2),\\dots,(x_n,y_n),(x_{n+1},y_{n+1})$ï¼Œè¦æ±‚å‡ºè¿‡è¿™äº›ç‚¹çš„ $n$ æ¬¡å¤šé¡¹å¼å‡½æ•°ï¼ˆä¹Ÿç§°è¯¥å‡½æ•°çš„åº¦ä¸º $n$ï¼‰ï¼Œå…ˆè€ƒè™‘å¯¹æ¯ä¸ªç‚¹æ„é€ ä¸€ä¸ªå‡½æ•°ï¼Œç¬¬ $i$ ä¸ªç‚¹çš„å‡½æ•°ä¸º $f_i(x)$ï¼Œæ»¡è¶³ï¼š\n$$ f_i(x) = \\begin{cases} y_i \u0026amp; x = x_i\\\\ 0 \u0026amp; x \\ne x_i \\end{cases} \\ (x\\in \\{x_1,x_2,\\dots,x_n,x_{n+1}\\}) $$\næœ€åå°†è¿™äº›å‡½æ•°ç»„åˆä¸ºæœ€ç»ˆçš„å‡½æ•°ï¼š\n$$ f(x) = \\sum_{i=1}^{n+1}f_i(x) $$\næ¥ä¸‹æ¥å°±æ˜¯æ‰¾åˆ°ä¸€ç§åˆé€‚çš„å½¢å¼æ¥è¡¨ç¤º $f_i(x)$ çš„åˆ†æ®µè§„å®šï¼Œå¯ä»¥è®© $f_i(x)$ å«æœ‰ä¸€äº›å› å¼ï¼Œæ»¡è¶³ $x=x_j,j\\ne i$ æ—¶ï¼Œå…¶å€¼ä¸º $0$ï¼Œ$x=x_i$ æ—¶ï¼Œå…¶å€¼ä¸º $y_i$ã€‚æ˜¾ç„¶ä¸‹é¢è¿™ç§æ»¡è¶³æ¡ä»¶ï¼š\n$$ f_i(x) = y_i \\prod_{i\\ne j} \\frac{x-x_j}{x_i-x_j} $$\næ‰€ä»¥æœ€ç»ˆçš„ $f(x)$ çš„è§£æå¼ä¸ºï¼š\n$$ f(x) = \\sum_{i=1}^{n + 1} y_i \\prod_{i\\ne j} \\frac{x-x_j}{x_i-x_j} $$\næ±‚å•ä¸ªå‡½æ•°å€¼çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $\\Theta(n^2)$ã€‚\nå‰åç¼€ç§¯ä¼˜åŒ– åœ¨ä¸€äº›é¢˜ç›®ä¸­ï¼Œæ’å€¼æ‰€éœ€çš„ $x$ æ˜¯è¿ç»­çš„ï¼Œå½“ $x\\in \\mathrm{N^*}$ æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå…¬å¼å†™æˆè¿™æ ·ï¼š\n$$ f(x) = \\sum_{i=1}^{n + 1} y_i \\prod_{i\\ne j} \\frac{x-j}{i-j} = \\sum_{i=1}^{n + 1} y_i \\frac{pre[i - 1]suf[i+1]}{(i-1)!(n-i+1)!(-1)^{n-i+1}}\\\\ pre[i]=\\prod_{j=1}^{i} (k-j) = (k-i)pre[i-1]\\\\ suf[i]=\\prod_{j=i}^{n+1} (k-j)= (k-i)suf[i+1]\\\\ $$\nç‰¹æ®Šåœ°ï¼Œ$pre[0] = 1$ï¼Œ$suf[n+2] = 1$ã€‚\nè¿™æ ·å•æ¬¡æ’å€¼çš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯ $\\Theta(n)$ã€‚ å½“ç„¶ï¼Œå‰åç¼€ç§¯ä¼˜åŒ–è¿˜é€‚ç”¨äº $x_i-x_{i-1}=d\\ (d\\ne 0,x\u0026gt;1)$ çš„æƒ…å†µï¼Œå³ $x_i$ æ˜¯ä¸€ä¸ªå…¬å·®ä¸ä¸º $0$ çš„ç­‰å·®æ•°åˆ—ã€‚\né‡å¿ƒæ‹‰æ ¼æœ—æ—¥æ’å€¼ å¦‚æœé¢˜é¢è¦æ±‚åŠ¨æ€åœ°åŠ å…¥æ’å€¼ç‚¹å‡é«˜æ¬¡æ•°ï¼Œä¸Šè¿°æ–¹æ³•ä¸å¤Ÿä¼˜ç§€ï¼Œä»å…¬å¼ä¸­å¯ä»¥å‘ç°ï¼Œæˆ‘ä»¬é‡å¤è®¡ç®—äº†è®¸å¤šä¸œè¥¿ï¼Œè€ƒè™‘æŠŠå®ƒä»¬æå–å‡ºæ¥ï¼š\n$$ f(x) = \\sum_{i=1}^{n + 1} y_i \\prod_{i\\ne j} \\frac{x-x_j}{x_i-x_j} = \\sum_{i=1}^{n + 1} \\frac{y_i}{x-x_i} \\prod_{j=1}^{n+1}(x-x_j) \\prod_{i\\ne j}\\frac{1}{x_i-x_j} $$\nå®šä¹‰ä»¥ä¸‹å‡½æ•°ï¼š\n$$ w(i)=\\prod_{i\\ne j}\\frac{1}{x_i-x_j}\\\\ c(x)=\\prod_{j=1}^{n+1}(x-x_j) $$\nå…¶ä¸­ $w(i)$ ä¹Ÿè¢«ç§°ä¸ºé‡å¿ƒæƒã€‚\næœ€ç»ˆå…¬å¼ä¸ºï¼š\n$$ f(x)=c(x) \\sum_{i=1}^{n + 1} w(i) \\frac{y_i}{x-x_i} $$\næ˜¾ç„¶åªè¦ $\\Theta(1)$ æ›´æ–° $c(x)$ï¼Œ$\\Theta(nt)$ æ±‚å‡º $w(n+2)$ ä»¥åŠæ›´æ–° $w(1\\dots n+1)$ã€‚æœ€å $\\Theta(nt)$ æ±‚å‡ºæ–°çš„ $f(x)$ã€‚$\\Theta(t)$ ä¸ºæ±‚é€†å…ƒçš„å¤æ‚åº¦ï¼Œä¸€èˆ¬ä¸º $\\Theta(\\log_2 M)$ï¼Œ$M$ ä¸ºæ¨¡æ•°ã€‚\nå…·ä½“åœ°ï¼Œå¯¹äº $\\forall i\\in [1,n+1]$ï¼Œ$w(i)$ éƒ½é™¤ä»¥ $x_i-x_{n+2}$ï¼Œè€Œ $w(n+2)$ åªéœ€æ‰«ä¸€éå³å¯ã€‚\nä»£ç å®ç° æ™®é€šæ‹‰æ ¼æœ—æ—¥æ’å€¼ int interpolation(int deg, int k, int x[], int y[]) { int res = 0; for (int i = 1; i \u0026lt;= deg + 1; ++i) { int num = y[i], den = 1; for (int j = 1; j \u0026lt;= deg + 1; ++j) { if (i == j) continue; num = 1ll * num * (k - x[j] + MOD) % MOD; den = 1ll * den * (x[i] - x[j] + MOD) % MOD; } res = (res + 1ll * num * power(den, MOD - 2)) % MOD; } return res; }  å‰åç¼€ç§¯ä¼˜åŒ– inline int sgnInv(int n) { static int inv[2] = {power(1, MOD - 2), power(MOD - 1, MOD - 2)}; return inv[n % 2]; } void preprocess(int deg) { fac[0] = 1; for (int i = 1; i \u0026lt;= deg + 1; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; inv[deg + 1] = power(fac[deg + 1], MOD - 2); for (int i = deg; i \u0026gt;= 0; --i) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD; } int interpolation(int deg, int k, int y[]) { int res = 0; pre[0] = suf[deg + 2] = 1; for (int i = 1; i \u0026lt;= deg + 1; ++i) pre[i] = 1ll * pre[i - 1] * (k - i + MOD) % MOD; for (int i = deg + 1; i \u0026gt;= 1; --i) suf[i] = 1ll * suf[i + 1] * (k - i + MOD) % MOD; for (int i = 1; i \u0026lt;= deg + 1; ++i) { int num = 1ll * y[i] * pre[i - 1] % MOD * suf[i + 1] % MOD; int den = 1ll * inv[i - 1] * inv[deg - i + 1] % MOD * sgnInv(deg - i + 1) % MOD; res = (res + 1ll * num * den) % MOD; } return res; }  é‡å¿ƒæ‹‰æ ¼æœ—æ—¥æ’å€¼ int interpolationAdd(int nx, int ny) { ++deg; x[deg + 1] = nx; y[deg + 1] = ny; c = 1ll * c * (k - nx + MOD) % MOD; for (int i = 1; i \u0026lt;= deg; ++i) w[i] = 1ll * w[i] * power(x[i] - x[deg + 1] + MOD, MOD - 2) % MOD; for (int i = 1; i \u0026lt;= deg; ++i) w[deg + 1] = 1ll * w[deg + 1] * (x[deg + 1] - x[i] + MOD) % MOD; w[deg + 1] = power(w[deg + 1], MOD - 2); int res = 0; for (int i = 1; i \u0026lt;= deg + 1; ++i) res = 1ll * y[i] * w[i] % MOD * power(k - x[i]) % MOD; res = 1ll * res * c % MOD; return res; }  ä¾‹é¢˜ Luogu P4593 æ•™ç§‘ä¹¦èˆ¬çš„äºµæ¸  ç»™å‡ºä¸€ä¸ªå•è°ƒé€’å¢çš„é•¿åº¦ä¸º $n$ çš„æ•°åˆ—ï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥ä½¿æ•°åˆ—çš„å€¼å…¨éƒ¨å‡å°‘ $x$ï¼Œæ»¡è¶³ $x$ æ°å¥½æ˜¯æ“ä½œå¼€å§‹å‰æ•°åˆ—å¼€å¤´çš„å€¼åŸŸè¿ç»­æ®µå…¨éƒ¨è¢«å‡ä¸ºå°äºç­‰äº $0$ï¼Œæ“ä½œç»“æŸåï¼Œå°†è¯¥è¿ç»­æ®µåˆ é™¤ï¼Œå¹¶è·å¾— $1+2^k+\\cdots +x^k$ çš„åˆ†æ•°ã€‚é¢˜é¢ç»™å‡ºæ•°åˆ—ä¸­æ²¡æœ‰å‡ºç°çš„æ•°ï¼Œå…± $m$ ä¸ªã€‚\n$1\\le n \\le 10^{13}$ï¼Œ$1\\le m \\le 10$ã€‚\n æŠŠåŸé¢˜é¢è½¬åŒ–ä¸ºä¸Šè¿°æ¨¡å‹åï¼Œæˆ‘ä»¬éœ€è¦æ±‚ $f(x)=\\sum_{i=1}^{x}i^k$ã€‚\nè¿™é‡Œç»™å‡ºä¸€ä¸ªç»“è®ºï¼šä¸€ä¸ª $n$ æ¬¡å‡½æ•°çš„å‰ç¼€å’Œä¸º $n+1$ æ¬¡ã€‚\næ‰€ä»¥è€ƒè™‘å…ˆæ±‚å‡º $\\forall i\\in [1,k+2]$ çš„ $f(i)$ï¼Œæ’å€¼å¾—åˆ° $k+1$ æ¬¡çš„ $f(x)$ã€‚\nè‡³äºé¢˜ç›®ä¸­çš„å‡æ“ä½œï¼Œ$\\Theta(m^2)$ æ¨¡æ‹Ÿæ¯ä¸€æ®µå³å¯ã€‚è‹¥ä½¿ç”¨å‰åç¼€ç§¯ä¼˜åŒ–ï¼Œåˆ™æ—¶é—´å¤æ‚åº¦ä¸º $\\Theta(m^2k)$ã€‚\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; using ll = long long; constexpr int maxm = 50 + 10; constexpr int mod = 1e9 + 7; int t, m; ll n, a[maxm]; int x[maxm], y[maxm]; int fac[maxm], inv[maxm], pre[maxm], suf[maxm]; int power(int x, int y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % mod; x = 1ll * x * x % mod; } return res; } inline int sgnInv(int n) { static int inv[2] = {power(1, mod - 2), power(mod - 1, mod - 2)}; return inv[n % 2]; } void preprocess() { fac[0] = 1; for (int i = 1; i \u0026lt;= maxm - 1; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; inv[maxm - 1] = power(fac[maxm - 1], mod - 2); for (int i = maxm - 2; i \u0026gt;= 0; --i) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; } int interpolation(ll x0, int deg, int x[], int y[]) { int ans = 0; pre[0] = suf[deg + 2] = 1; for (int i = 1; i \u0026lt;= deg + 1; ++i) pre[i] = 1ll * pre[i - 1] * (x0 - i + mod) % mod; for (int i = deg + 1; i \u0026gt;= 1; --i) suf[i] = 1ll * suf[i + 1] * (x0 - i + mod) % mod; for (int i = 1; i \u0026lt;= deg + 1; ++i) { int num = 1ll * y[i] * pre[i - 1] % mod * suf[i + 1] % mod; int den = 1ll * inv[i - 1] * inv[deg - i + 1] % mod * sgnInv(deg - i + 1) % mod % mod; ans = (1ll * ans + 1ll * num * den % mod) % mod; } return (ans + mod) % mod; } int calc(ll x0) { if (x0 \u0026lt;= m + 3) return y[x0]; return interpolation(x0, m + 2, x, y); } int solve() { int ans = 0; for (int i = 1; i \u0026lt;= m + 3; ++i) { x[i] = i; y[i] = (y[i - 1] + power(i, m + 1)) % mod; } for (int i = 1; i \u0026lt;= m; ++i) { ans = (ans + calc(n)) % mod; for (int j = i; j \u0026lt;= m; ++j) ans = (ans - power(a[j], m + 1) + mod) % mod; for (int j = i + 1; j \u0026lt;= m; ++j) a[j] -= a[i]; n -= a[i]; } if (n != 0) ans = (ans + calc(n)) % mod; return ans; } int main() { ios::sync_with_stdio(false); preprocess(); cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) cin \u0026gt;\u0026gt; a[i]; sort(a + 1, a + 1 + m); cout \u0026lt;\u0026lt; solve() \u0026lt;\u0026lt; endl; } return 0; }  Luogu P3270 æˆç»©æ¯”è¾ƒ  G ç³»å…±æœ‰ $N$ ä½åŒå­¦ï¼Œ$M$ é—¨å¿…ä¿®è¯¾ã€‚è¿™ $N$ ä½åŒå­¦çš„ç¼–å·ä¸º $0$ åˆ° $N-1$ çš„æ•´æ•°ï¼Œå…¶ä¸­ B ç¥çš„ç¼–å·ä¸º $0$ å·ã€‚è¿™ $M$ é—¨å¿…ä¿®è¯¾ç¼–å·ä¸º $0$ åˆ° $M-1$ çš„æ•´æ•°ã€‚ä¸€ä½åŒå­¦åœ¨å¿…ä¿®è¯¾ä¸Šå¯ä»¥è·å¾—çš„åˆ†æ•°æ˜¯ $1$ åˆ° $U_i$ ä¸­çš„ä¸€ä¸ªæ•´æ•°ã€‚\nå¦‚æœåœ¨æ¯é—¨è¯¾ä¸Š A è·å¾—çš„æˆç»©å‡å°äºç­‰äº B è·å¾—çš„æˆç»©ï¼Œåˆ™ç§° A è¢« B ç¢¾å‹ã€‚åœ¨ B ç¥çš„è¯´æ³•ä¸­ï¼ŒG ç³»å…±æœ‰ $K$ ä½åŒå­¦è¢«ä»–ç¢¾å‹ï¼ˆä¸åŒ…æ‹¬ä»–è‡ªå·±ï¼‰ï¼Œè€Œå…¶ä»– $N-K-1$ ä½åŒå­¦åˆ™æ²¡æœ‰è¢«ä»–ç¢¾å‹ã€‚D ç¥æŸ¥åˆ°äº† B ç¥æ¯é—¨å¿…ä¿®è¯¾çš„æ’åã€‚\nè¿™é‡Œçš„æ’åæ˜¯æŒ‡ï¼šå¦‚æœ B ç¥æŸé—¨è¯¾çš„æ’åä¸º $R$ï¼Œåˆ™è¡¨ç¤ºæœ‰ä¸”ä»…æœ‰ $R-1$ ä½åŒå­¦è¿™é—¨è¯¾çš„åˆ†æ•°å¤§äº B ç¥çš„åˆ†æ•°ï¼Œæœ‰ä¸”ä»…æœ‰ $N-R$ ä½åŒå­¦è¿™é—¨è¯¾çš„åˆ†æ•°å°äºç­‰äº B ç¥ï¼ˆä¸åŒ…æ‹¬ä»–è‡ªå·±ï¼‰ã€‚\nè¯·ä½ æ±‚å‡ºæ‰€æœ‰å¯èƒ½çš„æˆç»©ç§ç±»æ•°ã€‚\n$1\\le N\\le 100$ï¼Œ$1\\le M\\le 100$ï¼Œ$1\\le U_i\\le 10^9$ï¼Œ$1\\le R_i\\le N$ã€‚\n è€ƒè™‘ DPã€‚å…ˆåªè€ƒè™‘æˆç»©çš„ç›¸å¯¹å…³ç³»ï¼Œå³å…ˆä¸ç®¡æ¯ä¸ªäººçš„æˆç»©å…·ä½“æ˜¯å¤šå°‘ã€‚è®¾ $f[i][j]$ è¡¨ç¤ºå‰ $i$ é—¨è¯¾ç¨‹ B ç¥èƒ½å¤Ÿç¢¾å‹ $j$ ä¸ªäººçš„æ–¹æ¡ˆæ•°ï¼š\n$$ f[i][j]=\\sum_{k=j}^{N-1} f[i-1][k] \\binom{k}{j} \\binom{n-k-1}{r[i]-1-k+j}\\\\ f[0][N-1] = 1 $$\nè¿™ä¸ªå¼å­æ„æ€æ˜¯å‰ $i-1$ é—¨è¯¾ä¸­ï¼ŒB ç¥å¯ä»¥ç¢¾å‹ $k$ äººï¼Œä½†ç°åœ¨å…¶ä¸­çš„ $k-j$ äººè¿™é—¨è¯¾æˆç»©æ¯” B ç¥é«˜ï¼Œæ— æ³•è¢«ç¢¾å‹ï¼Œæœ‰ $\\binom{k}{j}$ ç§æ–¹æ¡ˆï¼Œä¸ºäº†ä¿è¯ B ç¥æ’åä¸º $r[i]$ï¼Œé™¤äº†åˆšæ‰çš„ $k-j$ äººï¼Œè¿˜è¦æœ‰ $r[i]-1-k+j$ äººæ’åœ¨ B ç¥å‰é¢ï¼Œè¿™äº›äººæ¥è‡ªæœªè¢«ç¢¾å‹çš„ $n-k-1$ äººä¸­æœ‰ $\\binom{n-k-1}{r[i]-1-k+j}$ ç§æ–¹æ¡ˆã€‚\nç”±äºæ¯é—¨è¯¾çš„æ’åå›ºå®šäº’ç›¸ç‹¬ç«‹ï¼Œæ‰€ä»¥è®¾ $d(i)$ ä¸ºç¬¬ $i$ é—¨è¯¾çš„äººçš„æ’åå›ºå®šæ—¶æˆç»©æ–¹æ¡ˆæ•°ï¼Œåˆ™æœ‰ï¼š\n$$ d(i)=\\sum_{j=1} j^{N-R_i} (U_i-j)^{R_i-1} $$\nè¿™é‡Œçš„ç®—æ³•æ˜¯æšä¸¾ B ç¥çš„åˆ†æ•°ï¼Œç„¶åç»Ÿè®¡æ¯ä¸ªäººå¯èƒ½çš„åˆ†æ•°çš„æ–¹æ¡ˆæ•°ã€‚å¯ä»¥å‘ç° $j^{N-R_i} (U_i-j)^{R_i-1}$ æ˜¯ä¸€ä¸ª $N-1$ æ¬¡å¤šé¡¹å¼ï¼Œåˆ™ $d(i)$ æ˜¯ä¸€ä¸ª $n$ æ¬¡å¤šé¡¹å¼ï¼Œæ’å€¼è§£å†³ã€‚\næœ€åå®šä¹‰ $f[i][j]$ ä¸ºè€ƒè™‘æˆç»©çš„å…·ä½“å–å€¼çš„æ–¹æ¡ˆæ•°ï¼š\n$$ f[i][j]=d(i)\\sum_{k=j}^{n-1} f[i-1][k] \\binom{k}{j} \\binom{n-k-1}{r[i]-1-k+j}\\\\ f[0][N-1]=1 $$\næœ€åç­”æ¡ˆä¸º $f[M][K]$ã€‚æ—¶é—´å¤æ‚åº¦ $\\Theta(MN^2)$ã€‚\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAXN = 100 + 10; constexpr int MOD = 1e9 + 7; int n, m, k; int u[MAXN], r[MAXN]; int c[MAXN][MAXN], d[MAXN], f[MAXN][MAXN]; int power(int x, int y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % MOD; x = 1ll * x * x % MOD; } return res; } int interpolation(int deg, int k, int x[], int y[]) { int res = 0; for (int i = 1; i \u0026lt;= deg + 1; ++i) { int num = y[i], den = 1; for (int j = 1; j \u0026lt;= deg + 1; ++j) { if (i == j) continue; num = 1ll * num * (k - x[j] + MOD) % MOD; den = 1ll * den * (x[i] - x[j] + MOD) % MOD; } res = (res + 1ll * num * power(den, MOD - 2)) % MOD; } return res; } int calc(int i) { int x[MAXN] = { 0 }, y[MAXN] = { 0 }; for (int j = 1; j \u0026lt;= min(u[i], n + 1); ++j) { x[j] = j; y[j] = (y[j - 1] + 1ll * power(j, n - r[i]) * power(u[i] - j, r[i] - 1)) % MOD; } if (u[i] \u0026lt;= n + 1) return y[u[i]]; return interpolation(n, u[i], x, y); } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= m; ++i) cin \u0026gt;\u0026gt; u[i]; for (int i = 1; i \u0026lt;= m; ++i) cin \u0026gt;\u0026gt; r[i]; for (int i = 0; i \u0026lt;= n; ++i) c[i][0] = c[i][i] = 1; for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt; i; ++j) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD; for (int i = 1; i \u0026lt;= m; ++i) d[i] = calc(i); f[0][n - 1] = 1; for (int i = 1; i \u0026lt;= m; ++i) { for (int j = 1; j \u0026lt; n; ++j) { for (int k = j; k \u0026lt; n; ++k) { if (k - j \u0026gt; r[i] - 1) continue; int cnt = 1ll * c[k][j] * c[n - k - 1][r[i] - 1 - (k - j)] % MOD; int pre = 1ll * d[i] * f[i - 1][k] % MOD * cnt % MOD; f[i][j] = (f[i][j] + pre) % MOD; } } } cout \u0026lt;\u0026lt; f[m][k] \u0026lt;\u0026lt; endl; return 0; }  Luogu P4463 calc  å®šä¹‰ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ­£æ•´æ•°æ•°åˆ— $a_n$ çš„æƒå€¼ä¸º $\\prod_{i=1}a_i$ï¼Œç°åœ¨è¦æ±‚ä½ æ±‚å‡ºæ‰€æœ‰æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„æ•°åˆ—çš„æƒå€¼å¹¶å¯¹è´¨æ•° $p$ å–æ¨¡ï¼š\n $\\forall i,j \\in [1,n]\\wedge i\\ne j$ï¼Œ$a_i\\ne a_j$ã€‚ $\\forall i \\in [1,n]$ï¼Œ$a_i\\in [1,k]$ã€‚  $1\\le k\\le 10^9$ï¼Œ$1\\le n\\le 500$ï¼Œ$2 \\le p \\le 10^9$ï¼Œ$p\u0026gt;k\u0026gt;n+1$ã€‚\n è®¾ $f[i][j]$ ä¸ºä¸è€ƒè™‘æ•°çš„é¡ºåºæƒ…å†µä¸‹ï¼Œåœ¨æ•°åˆ—çš„å‰ $i$ ä¸ªæ•°éƒ½å±äº $[1,j]$ çš„æƒå€¼å’Œï¼Œè€ƒè™‘é€‰æˆ–ä¸é€‰ $j$ è¿™ä¸ªæ•°ï¼Œåˆ™æœ‰ï¼š\n$$ f[i][j]=f[i][j-1]+j\\cdot f[i-1][j-1]\\\\ f[0][j]=1 $$\næœ€åç­”æ¡ˆä¸º $f[n][k]$ã€‚å¯ä»¥æƒ³åˆ°éœ€è¦æ’å€¼ï¼Œç°åœ¨é‡ç‚¹æ˜¯è¦çŸ¥é“ $f[n][x]$ çš„æ¬¡æ•°ã€‚\nè®¾ $d[i][j]$ ä¸º $f[i][j]$ çš„æ¬¡æ•°.\n é¦–å…ˆå¯ä»¥çŸ¥é“ $d[0][j]=0$ã€‚ å¯¹äº $i=1$ï¼Œä»…è€ƒè™‘ $f[1][j]\\longleftarrow j\\cdot f[0][j-1]$ï¼Œåˆ™ $d[1][j] = 1$ï¼Œè€Œè€ƒè™‘ $f[1][j]\\longleftarrow f[1][j-1]$ï¼Œç›¸å½“äºåšå‰ç¼€å’Œï¼Œåˆ™ $d[1][j] = 2$ã€‚ å¯¹äº $i=2$ï¼Œä»…è€ƒè™‘ $f[2][j]\\longleftarrow j\\cdot f[1][j-1]$ï¼Œåˆ™ $d[2][j] = 3$ï¼Œè€Œè€ƒè™‘ $f[2][j]\\longleftarrow f[2][j-1]$ï¼Œç›¸å½“äºåšå‰ç¼€å’Œï¼Œåˆ™ $d[2][j] = 4$ã€‚ etc.  æœ€åå¾—åˆ° $d[n][x]=2n$ï¼Œåˆ™éœ€è¦å¤„ç†å‡º $2n+1$ ä¸ª $f[n][x_i]$ã€‚ æ³¨æ„è¿™è¿˜æ²¡è€ƒè™‘æ•°çš„é¡ºåºï¼Œå¯¹æ•°åˆ—è¿›è¡Œå…¨æ’åˆ—ï¼Œç­”æ¡ˆä¸º $n!f[n][k]$ã€‚\næ—¶é—´å¤æ‚åº¦ $\\Theta(2n^2+8n^3)$ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; constexpr int MAXN = 500 + 10; int n, k, p, f[MAXN][MAXN * 2]; int x[MAXN * 2], y[MAXN * 2]; void DP() { for (int i = 0; i \u0026lt;= 2 * n; ++i) f[0][i] = 1; for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= 2 * n; ++j) f[i][j] = (f[i][j - 1] + 1ll * j * f[i - 1][j - 1]) % p; } int power(int x, int y) { int res = 1; while (y) { if (y % 2) res = 1ll * res * x % p; x = 1ll * x * x % p; y /= 2; } return res % p; } int inv(int x) { return power(x, p - 2); } int interpolation(int deg, int k, int x[], int y[]) { int ans = 0; for (int i = 1; i \u0026lt;= deg + 1; ++i) { int num = y[i], den = 1; for (int j = 1; j \u0026lt;= deg + 1; ++j) { if (i == j) continue; num = 1ll * num * (k - x[j] + p) % p; den = 1ll * den * (x[i] - x[j] + p) % p; } ans = (ans + 1ll num * inv(den) % p) % p; } return ans; } int main() { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p; DP(); for (int i = 1; i \u0026lt;= 2 * n + 1; ++i) { x[i] = i; y[i] = f[n][i]; } int ans = interpolation(2 * n, k % p, x, y); for (int i = 1; i \u0026lt;= n; ++i) ans = 1ll * ans * i % p; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  ","id":8,"section":"posts","summary":"æ‹‰æ ¼æœ—æ—¥æ’å€¼æ˜¯ä¼—å¤šæ’å€¼ç®—æ³•ä¸­çš„ä¸€ç§ï¼Œæ’å€¼æ˜¯é€šè¿‡ä¸€äº›ç‚¹æ¥æ±‚å‡ºè¿‡è¿™äº›ç‚¹çš„å¤šé¡¹å¼å‡½æ•°çš„è¿‡ç¨‹ã€‚ ç®—æ³•æ€æƒ³ æ„é€ å‡½æ•° ç»™å‡º $n + 1$ ä¸ªç‚¹ $(x_1,y_1),(","tags":["OI","æ•°å­¦","å¤šé¡¹å¼","æ‹‰æ ¼æœ—æ—¥æ’å€¼","C++"],"title":"æ‹‰æ ¼æœ—æ—¥æ’å€¼å­¦ä¹ ç¬”è®°","uri":"https://ctj12461.vercel.app/contents/20220207-lagrange-interpolation-note/","year":"2022"},{"content":"é«˜æ–¯æ¶ˆå…ƒä¸»è¦ç”¨äºæ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„çš„è§£ï¼ŒåŒæ—¶å¯ä»¥è§£å†³æŸäº›æœ‰åæ•ˆæ€§çš„ DP é—®é¢˜ï¼Œ\nç®—æ³•æ€æƒ³ å¢å¹¿çŸ©é˜µ ä¸ºäº†æ›´æ–¹ä¾¿åœ°æ±‚è§£æ–¹ç¨‹ç»„ï¼Œå¯ä»¥å°†ç³»æ•°å’Œå¸¸æ•°é¡¹æ”¾å…¥çŸ©é˜µï¼Œæ¥ä¸‹æ¥å°±å¯ä»¥ç”¨ä¸€äº›çŸ©é˜µçš„æ“ä½œæ¥æ¶ˆå…ƒäº†ã€‚\næ¯”å¦‚æœ‰ä¸€ä¸ªæ–¹ç¨‹ç»„å¦‚ä¸‹ï¼š\n$$ \\begin{cases} 3x+2y+3z=10\\\\ 3x+y+4z=12\\\\ x+y+z=4 \\end{cases} $$\næˆ‘ä»¬å¯ä»¥è¿™ä¹ˆç”¨çŸ©é˜µè¡¨ç¤º:\n$$ \\begin{bmatrix} 2 \u0026amp; 2 \u0026amp; 3 \\\\ 3 \u0026amp; 1 \u0026amp; 4 \\\\ 1 \u0026amp; 1 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} 10 \\\\ 12 \\\\ 1 \\end{bmatrix} $$\nåœ¨ç†è®ºåˆ†æå’Œå®ç°ä»£ç æ—¶ï¼Œä¸ºäº†æ–¹ä¾¿ï¼Œé€šå¸¸æŠŠä¸¤ä¸ªçŸ©é˜µæ‹¼åœ¨ä¸€èµ·ï¼Œè¿™ä¸ªçŸ©é˜µå°±æ˜¯å¢å¹¿çŸ©é˜µï¼š\n$$ \\begin{bmatrix} 2 \u0026amp; 2 \u0026amp; 3 \u0026amp; 10 \\\\ 3 \u0026amp; 1 \u0026amp; 4 \u0026amp; 12 \\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \\end{bmatrix} $$\nå¢å¹¿çŸ©é˜µçš„ç¬¬ $i$ è¡Œä»£ç¬”ç¬¬ $i$ ä¸ªæ–¹ç¨‹ï¼Œç¬¬ $i$ åˆ—è¡¨ç¤ºç¬¬ $i$ ä¸ªæœªçŸ¥æ•°çš„ç³»æ•°æˆ–å¸¸æ•°é¡¹ï¼Œæ¥ä¸‹æ¥ç”¨ $x_i$ è¡¨ç¤ºç¬¬ $i$ ä¸ªæœªçŸ¥æ•°ã€‚\nåˆç­‰è¡Œå˜æ¢ åˆç­‰è¡Œå˜æ¢æ˜¯æŒ‡è¡Œä¹‹é—´çš„åŠ å‡ä¹˜ç­‰è¿ç®—ã€‚æ¶ˆå…ƒçš„æœ¬è´¨å°±æ˜¯åˆ©ç”¨åˆç­‰è¡Œå˜æ¢ï¼Œä½¿æœªçŸ¥æ•°çš„ç³»æ•°å˜ä¸º $0$ã€‚å…·ä½“åœ°ï¼Œåˆç­‰è¡Œå˜æ¢æ˜¯ä¸¤ä¸ªè¡Œä¸­çš„å…ƒç´ é€ä¸€è¿›è¡Œè¿ç®—ï¼Œä»¥ä¸Šé¢çš„çŸ©é˜µä¸ºä¾‹ï¼Œè®° $row_i$ è¡¨ç¤ºç¬¬ $i$ è¡Œï¼Œåˆ™ $row_2 \\longleftarrow row_2 - \\frac{2}{3}row_1$ çš„ç»“æœå°±æ˜¯ï¼š\n$$ \\begin{bmatrix} 0 \u0026amp; -2 \u0026amp; -\\frac{1}{2} \u0026amp; -3 \\end{bmatrix} $$\nè¿™ä¸ªæ“ä½œä½¿è¯¥è¡Œçš„ç¬¬ $1$ ä¸ªå…ƒç´ å˜ä¸ºäº† $0$ï¼Œä»æ–¹ç¨‹çš„æ„ä¹‰ä¸Šè€ƒè™‘ï¼Œå°±æ˜¯æ¶ˆå»äº†ä¸€ä¸ªå…ƒã€‚\nä¸‰è§’çŸ©é˜µå’Œå¯¹è§’çŸ©é˜µ ä¸‰è§’çŸ©é˜µæ˜¯æŒ‡ä¸€ä¸ªçŸ©é˜µçš„ä¸€ä¸ªä¸‰è§’éƒ¨åˆ†å…¨éƒ¨ä¸º $0$ï¼Œå¯¹è§’çŸ©é˜µåˆ™æ˜¯å¯¹è§’çº¿ä¹‹å¤–çš„å…ƒç´ å‡ä¸º $0$ã€‚é«˜æ–¯æ¶ˆå…ƒä¸­ï¼Œä¸‰è§’çŸ©é˜µä¸€èˆ¬æŒ‡ä¸‹ä¸‰è§’çŸ©é˜µï¼Œå¯¹è§’çŸ©é˜µä¸€èˆ¬æŒ‡é™¤å¸¸æ•°é¡¹éƒ¨åˆ†ä¸ºå¯¹è§’çŸ©é˜µçš„çŸ©é˜µã€‚\nå‡è®¾å¾—åˆ°äº†ä¸€ä¸ªå¯¹è§’çŸ©é˜µï¼š\n$$ \\begin{bmatrix} k_1 \u0026amp; 0 \u0026amp; 0 \u0026amp; c_1\\\\ 0 \u0026amp; k_2 \u0026amp; 0 \u0026amp; c_2\\\\ 0 \u0026amp; 0 \u0026amp; k_3 \u0026amp; c_3 \\end{bmatrix} $$\né‚£å°±ç›¸å½“äºæ˜¯ä¸€ä¸ªä¸ªçš„ä¸€å…ƒçº¿æ€§æ–¹ç¨‹ï¼Œç›´æ¥è§£å‡ºå³å¯ã€‚è€Œå¯¹è§’çŸ©é˜µå¯ä»¥é€šè¿‡ä¸‰è§’çŸ©é˜µå¾—å‡ºï¼š\n$$ \\begin{bmatrix} k_{11} \u0026amp; k_{12} \u0026amp; k_{13} \u0026amp; c_1\\\\ 0 \u0026amp; k_{22} \u0026amp; k_{23} \u0026amp; c_2\\\\ 0 \u0026amp; 0 \u0026amp; k_{33} \u0026amp; c_3 \\end{bmatrix} $$\né¦–å…ˆå¯ä»¥è§£å‡º $x_3$ï¼Œç„¶åå°† $x_3$ å¸¦å…¥ç¬¬ $2$ ä¸ªæ–¹ç¨‹ï¼Œåˆ™ $k_{23}x_3$ å°±æˆä¸ºäº†å¸¸æ•°é¡¹ï¼Œç§»é¡¹ä¸€ä¸‹å¾—åˆ°ï¼š\n$$ \\begin{bmatrix} k_{11} \u0026amp; k_{12} \u0026amp; k_{13} \u0026amp; c_1\\\\ 0 \u0026amp; k_{22} \u0026amp; 0 \u0026amp; c_2 - k_{23}x_3\\\\ 0 \u0026amp; 0 \u0026amp; k_{33} \u0026amp; c_3 \\end{bmatrix} $$\nåŒç†å¸¦å…¥ $x_2,x_3$ åˆ°ç¬¬ $1$ ä¸ªæ–¹ç¨‹ï¼š\n$$ \\begin{bmatrix} k_{11} \u0026amp; 0 \u0026amp; 0 \u0026amp; c_1 - k_{12}x_2 - k_{13}x_3\\\\ 0 \u0026amp; k_{22} \u0026amp; 0 \u0026amp; c_2 - k_{23}x_3\\\\ 0 \u0026amp; 0 \u0026amp; k_{33} \u0026amp; c_3 \\end{bmatrix} $$\nå…·ä½“æ­¥éª¤ä¸å®ä¾‹ åªè¦ä»ä¸Šå¾€ä¸‹å°†æ¯è¡Œä¸å®ƒä¸‹é¢çš„è¡Œè¿›è¡Œè¿ç®—ï¼Œæ¯æšä¸¾ä¸€è¡Œå°±æ¶ˆå»ä¸€ä¸ªå…ƒï¼Œæšä¸¾ç¬¬ $i$ è¡Œåˆ™æ¶ˆå» $x_i$ï¼Œå³é€šè¿‡åˆç­‰è¡Œå˜æ¢æŠŠç¬¬ $i + 1$ åˆ° $n$ çš„æ–¹ç¨‹çš„ $x_i$ ç³»æ•°å˜ä¸º $0$ã€‚æœ€åä»ä¸‹å¾€ä¸Šå¸¦å…¥å³å¯ã€‚\nä»¥ä¸Šé¢çš„çŸ©é˜µä¸ºä¾‹ï¼Œè¿™é‡Œå°±æ¨¡æ‹Ÿåˆ°å¾—åˆ°ä¸‰è§’çŸ©é˜µï¼š\n$$ \\begin{bmatrix} 2 \u0026amp; 2 \u0026amp; 3 \u0026amp; 10 \\\\ 3 \u0026amp; 1 \u0026amp; 4 \u0026amp; 12 \\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \\end{bmatrix} $$\nStep 1: $row_2 \\longleftarrow row_2 - \\frac{2}{3}row_1$ $$ \\begin{bmatrix} 2 \u0026amp; 2 \u0026amp; 3 \u0026amp; 10 \\\\ 0 \u0026amp; -2 \u0026amp; -\\frac{1}{2} \u0026amp; -3 \\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \\end{bmatrix} $$\nStep 2: $row_3 \\longleftarrow row_3 - \\frac{1}{2}row_1$ $$ \\begin{bmatrix} 2 \u0026amp; 2 \u0026amp; 3 \u0026amp; 10 \\\\ 0 \u0026amp; -2 \u0026amp; -\\frac{1}{2} \u0026amp; -3 \\\\ 0 \u0026amp; 0 \u0026amp; -\\frac{1}{2} \u0026amp; -4 \\end{bmatrix} $$\nStep 3: $row_3 \\longleftarrow row_3 - 0\\cdot row_2$\nå¢å¹¿çŸ©é˜µä¸å˜ã€‚\né«˜æ–¯-çº¦æ—¦æ¶ˆå…ƒ ç”±äºè®¡ç®—æœºä¸Šæµ®ç‚¹æ•°çš„ç²¾åº¦æœ‰é™ï¼Œè¦å°½å¯èƒ½é€‰æ‹©ç»å¯¹å€¼è¾ƒå¤§çš„æ•°ä½œä¸ºé™¤æ•°ï¼Œæ‰€ä»¥æšä¸¾åˆ°ç¬¬ $i$ è¡Œæ—¶ï¼Œå¯ä»¥æ‰¾åˆ° $x_i$ çš„ç³»æ•°æœ€å¤§çš„æ–¹ç¨‹ï¼Œä¸å½“å‰è¡Œäº¤æ¢ï¼Œè¿™ç§æ–¹æ³•å«åšé«˜æ–¯-çº¦æ—¦æ¶ˆå…ƒæ³•ã€‚\nè§£çš„åˆ¤æ–­ æ–¹ç¨‹ç»„æœ‰å¯èƒ½æœ‰æ— æ•°è§£ï¼ˆå«è‡ªç”±å…ƒï¼‰æˆ–æ— è§£ã€‚å¾—åˆ°ä¸€ä¸ªå¯¹è§’çŸ©é˜µåï¼Œè‹¥å­˜åœ¨å¯¹è§’å…ƒç´  $k_{ii} = 0$ï¼Œè€Œå¸¸æ•°é¡¹ $c_i \\ne 0$ï¼Œåˆ™æ— è§£ï¼Œå¦åˆ™è‹¥å­˜åœ¨å¯¹è§’å…ƒç´  $k_{ii} = 0$ï¼Œè€Œå¸¸æ•°é¡¹ $c_i = 0$ï¼Œåˆ™å«è‡ªç”±å…ƒã€‚\nä»£ç å®ç° class EquationGroup { public: enum class Result { UNIQUE, INFINITY, NO_SOLUTION }; void init(int n) { this-\u0026gt;n = n; e = vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt;(n + 1, vector\u0026lt;double\u0026gt;(n + 2)); } vector\u0026lt;double\u0026gt; \u0026amp;operator[](int x) { return e[x]; } pair\u0026lt;vector\u0026lt;double\u0026gt;, Result\u0026gt; solve() { transform(); Result res = calc(); vector\u0026lt;double\u0026gt; x(n + 1); for (int i = 1; i \u0026lt;= n; ++i) x[i] = e[i][n + 1]; return {x, res}; } private: vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; e; int n; // æœªçŸ¥æ•°ä¸ªæ•° void transform() { for (int i = 1; i \u0026lt;= n; ++i) { int p = i; // é€‰æ‹© e[][i] ç»å¯¹å€¼æœ€å¤§çš„ä¸€è¡Œè¿›è¡Œäº¤æ¢ for (int j = i + 1; j \u0026lt;= n; ++j) if (abs(e[p][i]) \u0026lt; abs(e[j][i])) p = j; if (p != i) for (int j = 1; j \u0026lt;= n + 1; ++j) swap(e[i][j], e[p][j]); // åˆç­‰è¡Œå˜æ¢ for (int j = i + 1; j \u0026lt;= n; ++j) { double rate = e[j][i] / e[i][i]; for (int k = 1; k \u0026lt;= n + 1; ++k) e[j][k] -= e[i][k] * rate; } } } Result calc() { Result res = Result::UNIQUE; for (int i = n; i \u0026gt;= 1; --i) { // æŠŠè§£ x_i å­˜åœ¨ e[i][n + 1] ä¸­ for (int j = i + 1; j \u0026lt;= n; ++j) e[i][n + 1] -= e[i][j] * e[j][n + 1]; if (!e[i][i]) { e[i][n + 1] /= e[i][i]; } else { if (e[i][n + 1]) res = Result::NO_SOLUTION; else if (res != Result::NO_SOLUTION) res = Result::INFINITY; } } return res; } };  ä¾‹é¢˜ Luogu P4035 çƒå½¢ç©ºé—´äº§ç”Ÿå™¨  ç»™å‡ºä¸€ä¸ª $n + 1$ ä¸ª $n$ ç»´ç©ºé—´çš„ç‚¹ï¼Œæ±‚è¿™ $n + 1$ ä¸ªç‚¹æ„æˆçš„ $n$ ç»´çƒä½“çš„çƒå¿ƒã€‚\n$1 \\le n \\le 10$ã€‚\n è®¾çƒå¿ƒä¸º $(x_1,x_2,\\dots,x_n)$ï¼ŒåŠå¾„ä¸º $r$ï¼Œå¯¹äºçƒä½“çš„æŸä¸ªç‚¹ $p$ï¼Œæœ‰å¦‚ä¸‹å…³ç³»ï¼š\n$$ \\sum_{i = 1}^{n} (p_i - x_i) ^ 2 = r ^ 2\\\\ $$\nå±•å¼€å¹¶ç§»é¡¹å¾—åˆ°ï¼š\n$$ \\sum_{i = 1}^{n} 2p_ix_i + (r ^ 2 - \\sum_{i = 1}^{n} x_i ^ 2) = \\sum_{i = 1}^{n} p_i ^ 2 $$\næŠŠæ‹¬å·çœ‹æˆä¸€ä¸ªæ•´ä½“ï¼Œæ˜¾ç„¶æ˜¯ä¸€ä¸ª $n + 1$ å…ƒçº¿æ€§æ–¹ç¨‹ç»„ï¼Œç›´æ¥é«˜æ–¯æ¶ˆå…ƒæ±‚è§£ã€‚\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; constexpr int MAXN = 10 + 5; int n; double pos[MAXN][MAXN], mat[MAXN][MAXN]; void preprocess() { for (int i = 1; i \u0026lt;= n + 1; ++i) { double sum = 0; for (int j = 1; j \u0026lt;= n; ++j) { mat[i][j] = 2 * pos[i][j]; sum += pos[i][j] * pos[i][j]; } mat[i][n + 1] = 1; mat[i][n + 2] = sum; } } void transform(int n) { for (int i = 1; i \u0026lt;= n; ++i) { int p = i; for (int j = i + 1; j \u0026lt;= n; ++j) if (abs(mat[p][i]) \u0026lt; abs(mat[j][i])) p = j; if (i != p) for (int j = i; j \u0026lt;= n + 1; ++j) swap(mat[i][j], mat[p][j]); for (int j = i + 1; j \u0026lt;= n; ++j) { double rate = mat[j][i] / mat[i][i]; for (int k = i; k \u0026lt;= n + 1; ++k) mat[j][k] -= rate * mat[i][k]; } } } void calc(int n) { for (int i = n; i \u0026gt;= 1; --i) { for (int j = i + 1; j \u0026lt;= n; ++j) mat[i][n + 1] -= mat[i][j] * mat[j][n + 1]; mat[i][n + 1] /= mat[i][i]; } } void guass(int n) { transform(n); calc(n); } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n + 1; ++i) for (int j = 1; j \u0026lt;= n; ++j) cin \u0026gt;\u0026gt; pos[i][j]; preprocess(); guass(n + 1); for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; mat[i][n + 2] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; return 0; }  Codeforces 24D Broken robot  $n$ è¡Œ $m$ åˆ—çš„çŸ©é˜µï¼Œ$(1, 1)$ æ˜¯çŸ©é˜µçš„å·¦ä¸Šè§’ï¼Œ$(n, m)$ æ˜¯çŸ©é˜µçš„å³ä¸‹è§’ã€‚ç°åœ¨ä½ åœ¨ $(x, y)$ï¼Œæ¯æ¬¡ç­‰æ¦‚ç‡å‘å·¦ï¼Œå³ï¼Œä¸‹èµ°æˆ–åŸåœ°ä¸åŠ¨ï¼Œä½†ä¸èƒ½èµ°å‡ºå»ï¼Œé—®èµ°åˆ°æœ€åä¸€è¡ŒæœŸæœ›çš„æ­¥æ•°ã€‚ï¼ˆåŸåœ°ä¸åŠ¨ä¹Ÿç®—ä¸€æ­¥ï¼‰\n$1 \\le n, m \\le 10 ^ 3$ï¼Œ$1 \\le x \\le n$ï¼Œ$1 \\le y \\le m$ã€‚\n å…ˆè€ƒè™‘ $m = 1$ çš„æƒ…å†µï¼Œæœ‰ $\\frac{1}{2}$ çš„æ¦‚ç‡ç•™åœ¨åŸåœ°ï¼Œ$\\frac{1}{2}$ çš„æ¦‚ç‡å‘ä¸‹èµ°ï¼ŒæœŸæœ›æ­¥æ•°ä¸º $2 (m - x)$ã€‚\nè‹¥ $m \u0026gt; 1$ï¼Œè®¾ $f[i][j]$ ä¸ºä» $(i, j)$ èµ°åˆ°æœ€åä¸€è¡Œçš„æœŸæœ›æ­¥æ•°ï¼Œåˆ™\n$$ f[i][j] = \\begin{cases} \\frac{f[i][j + 1] + f[i + 1][j] + f[i][j]}{3} + 1 \u0026amp; j = 1\\\\ \\frac{f[i][j - 1] + f[i][j + 1] + f[i + 1][j] + f[i][j]}{4} + 1 \u0026amp; 1 \u0026lt; j \u0026lt; m\\\\ \\frac{f[i][j - 1] + f[i + 1][j] + f[i][j]}{3} + 1 \u0026amp; j = m \\end{cases} $$\nç§»é¡¹å¯å¾—ï¼š\n$$ \\begin{cases} 2f[i][j] - f[i][j + 1] - f[i + 1][j] = 3 \u0026amp; j = 1\\\\ 3f[i][j] - f[i][j - 1] - f[i][j + 1] - f[i + 1][j] = 4 \u0026amp; 1 \u0026lt; j \u0026lt; m\\\\ 2f[i][j] - f[i][j - 1] - f[i + 1][j] = 3 \u0026amp; j = m \\end{cases} $$\näºæ˜¯æ¯è¡Œçš„è½¬ç§»å°±å¯ä»¥è§£å†³äº†ã€‚ç„¶è€Œæš´åŠ›æ¶ˆå…ƒçš„å¤æ‚åº¦ä¸æ­£ç¡®ï¼Œè€ƒè™‘åˆ°æ¯ä¸ªæ–¹ç¨‹éƒ½è‡³å¤šåªæœ‰ä¸‰ä¸ªç³»æ•°ä¸ä¸º $0$ï¼Œæ¯ä¸€è¡Œåªä¼šæ¶ˆå»ä¸‹ä¸€è¡Œçš„ä¸€ä¸ªå…ƒï¼ˆå¯ä»¥æ‰‹ç”»ä¸€ä¸ªçŸ©é˜µï¼‰ï¼Œåˆ©ç”¨è¿™ä¸ªæ€§è´¨ï¼Œæ¶ˆå…ƒå¯ä»¥åšåˆ° $\\Theta(m)$ï¼Œæ€»çš„å¤æ‚åº¦å°±æ˜¯ $\\Theta(m (n-x))$ã€‚\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; constexpr int MAXN = 1e3 + 5; // * * 0 0 0 0 | * // * * * 0 0 0 | * // 0 * * * 0 0 | * // 0 0 * * * 0 | * // 0 0 0 * * * | * // 0 0 0 0 * * | * int n, m, x, y; double mat[MAXN][MAXN], f[MAXN]; void fill() { mat[1][1] = 2; mat[1][2] = -1; mat[1][m + 1] = 3 + f[1]; for (int i = 2; i \u0026lt; m; ++i) { mat[i][i] = 3; mat[i][i - 1] = -1; mat[i][i + 1] = -1; mat[i][m + 1] = 4 + f[i]; } mat[m][m] = 2; mat[m][m - 1] = -1; mat[m][m + 1] = 3 + f[m]; } void gauss() { for (int i = 1; i \u0026lt; m; ++i) { double rate = mat[i + 1][i] / mat[i][i]; mat[i + 1][i] = 0; mat[i + 1][i + 1] -= rate * mat[i][i + 1]; mat[i + 1][m + 1] -= rate * mat[i][m + 1]; } mat[m][m + 1] /= mat[m][m]; for (int i = m - 1; i \u0026gt;= 1; --i) mat[i][m + 1] = (mat[i][m + 1] - mat[i + 1][m + 1] * mat[i][i + 1]) / mat[i][i]; for (int i = 1; i \u0026lt;= m; ++i) f[i] = mat[i][m + 1]; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (m == 1) { cout \u0026lt;\u0026lt; 2 * (n - x) \u0026lt;\u0026lt; endl; return 0; } for (int i = n - 1; i \u0026gt;= x; --i) { fill(); gauss(); } cout \u0026lt;\u0026lt; setprecision(8) \u0026lt;\u0026lt; f[y] \u0026lt;\u0026lt; endl; return 0; }  Luogu P3232 æ¸¸èµ°  ç»™å®šä¸€ä¸ª $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„æ— å‘è¿é€šå›¾ï¼Œé¡¶ç‚¹ä» $1$ ç¼–å·åˆ° $n$ï¼Œè¾¹ä» $1$ ç¼–å·åˆ° $m$ã€‚\nå° Z åœ¨è¯¥å›¾ä¸Šè¿›è¡Œéšæœºæ¸¸èµ°ï¼Œåˆå§‹æ—¶å° Z åœ¨ $1$ å·é¡¶ç‚¹ï¼Œæ¯ä¸€æ­¥å° Z ä»¥ç›¸ç­‰çš„æ¦‚ç‡éšæœºé€‰æ‹©å½“å‰é¡¶ç‚¹çš„æŸæ¡è¾¹ï¼Œæ²¿ç€è¿™æ¡è¾¹èµ°åˆ°ä¸‹ä¸€ä¸ªé¡¶ç‚¹ï¼Œè·å¾—ç­‰äºè¿™æ¡è¾¹çš„ç¼–å·çš„åˆ†æ•°ã€‚å½“å° Z åˆ°è¾¾ $n$ å·é¡¶ç‚¹æ—¶æ¸¸èµ°ç»“æŸï¼Œæ€»åˆ†ä¸ºæ‰€æœ‰è·å¾—çš„åˆ†æ•°ä¹‹å’Œã€‚ç°åœ¨ï¼Œè¯·ä½ å¯¹è¿™ $m$ æ¡è¾¹è¿›è¡Œç¼–å·ï¼Œä½¿å¾—å° Z è·å¾—çš„æ€»åˆ†çš„æœŸæœ›å€¼æœ€å°ã€‚\n$2 \\le n \\le 500$ï¼Œ$1 \\le m \\le 125000$ã€‚\n è®¾ $f[i]$ è¡¨ç¤ºèµ°åˆ° $i$ çš„æœŸæœ›æ¬¡æ•°ï¼Œ$deg[i]$ ä¸ºç‚¹ $x$ çš„åº¦ï¼Œåˆ™å¯¹äºä¸€æ¡è¾¹ $(x, y)$ï¼Œå…¶æœŸæœ›æ¬¡æ•°ä¸ºï¼š\n$$ \\frac{f[x]}{deg[x]} + \\frac{f[y]}{deg[y]} $$\nè€ƒè™‘ $f[i]$ çš„è½¬ç§»ï¼Œè®¾ $j$ ä¸º $i$ çš„ä¸Šä¸€ä¸ªç»“ç‚¹ï¼Œåˆ™ï¼š\n$$ f[i] = \\sum\\frac{f[j]}{deg[j]} + [i = 1] $$\nå› ä¸ºåˆå§‹åœ¨ç‚¹ $1$ï¼Œåˆ™æœŸæœ›æ¬¡æ•°ä¼šå¤š $1$ã€‚æŠŠè¿™ä¸ªæ–¹ç¨‹ï¼Œç”±äº $n$ æ˜¯ç»ˆç‚¹ï¼Œä¸å‚åŠ è½¬ç§»ï¼Œè®¾ $f[n] = 0$ã€‚äºæ˜¯å‰ $n - 1$ ä¸ªè½¬ç§»æ–¹ç¨‹ç»„æˆä¸€ä¸ªæ–¹ç¨‹ç»„ï¼Œè§£å‡ºå®ƒå³å¯ã€‚\næœ€åç®—å‡ºæ¯æ¡è¾¹çš„æœŸæœ›æ¬¡æ•°ï¼Œæ ¹æ®æ’åºä¸ç­‰å¼ï¼Œæ¬¡æ•°è¶Šå¤šçš„è¾¹åº”è¯¥ç¼–å·è¶Šå°ï¼Œè¿™æ ·ç­”æ¡ˆæ›´ä¼˜ã€‚\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; constexpr int MAXN = 500 + 10; constexpr int MAXM = 125000 + 10; struct Equation { double a[MAXN]; double \u0026amp;operator[](int x) { return a[x]; } }; struct EquationGroup { Equation e[MAXN]; int n; void init(int n) { this-\u0026gt;n = n; } Equation \u0026amp;operator[](int x) { return e[x]; } void transform() { for (int i = 1; i \u0026lt;= n; ++i) { int p = i; for (int j = i + 1; j \u0026lt;= n; ++j) if (abs(e[p][i]) \u0026lt; abs(e[j][i])) p = j; if (p != i) for (int j = 1; j \u0026lt;= n + 1; ++j) swap(e[i][j], e[p][j]); for (int j = i + 1; j \u0026lt;= n; ++j) { double rate = e[j][i] / e[i][i]; for (int k = 1; k \u0026lt;= n + 1; ++k) e[j][k] -= e[i][k] * rate; } } } void calc() { for (int i = n; i \u0026gt;= 1; --i) { for (int j = i + 1; j \u0026lt;= n; ++j) e[i][n + 1] -= e[i][j] * e[j][n + 1]; e[i][n + 1] /= e[i][i]; } } vector\u0026lt;double\u0026gt; solve() { transform(); calc(); vector\u0026lt;double\u0026gt; res(n + 1); for (int i = 1; i \u0026lt;= n; ++i) res[i] = e[i][n + 1]; return res; } }; struct Edge { int x, y; double p; bool operator\u0026lt;(const Edge \u0026amp;rhs) const { return p \u0026gt; rhs.p; } }; int n, m; EquationGroup e; vector\u0026lt;int\u0026gt; graph[MAXN]; int deg[MAXN]; Edge edges[MAXM]; double ans; void link(int x, int y) { graph[x].push_back(y); graph[y].push_back(x); ++deg[x]; ++deg[y]; } int main() { ios::sync_with_stdio(false); cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(3); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) { auto \u0026amp;[x, y, p] = edges[i]; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; link(x, y); } e.init(n - 1); for (int i = 1; i \u0026lt; n; ++i) { for (int j : graph[i]) if (j != n) e[i][j] = -1.0 / deg[j]; e[i][i] = 1; } e[1][n] = 1; auto f = e.solve(); for (int i = 1; i \u0026lt;= m; ++i) { auto \u0026amp;[x, y, p] = edges[i]; p = (x != n ? f[x] / deg[x] : 0) + (y != n ? f[y] / deg[y] : 0); } sort(edges + 1, edges + 1 + m); for (int i = 1; i \u0026lt;= m; ++i) ans += i * edges[i].p; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  Luogu P3211 XOR å’Œè·¯å¾„  ç»™å®šä¸€ä¸ªæ— å‘è¿é€šå›¾ï¼Œæœ‰ $n$ ä¸ªç‚¹å’Œ $m$ æ¡è¾¹ï¼Œå…¶èŠ‚ç‚¹ç¼–å·ä¸º $1$ åˆ° $n$ï¼Œå…¶è¾¹çš„æƒå€¼ä¸ºéè´Ÿæ•´æ•°ã€‚ä» $1$ å·èŠ‚ç‚¹å¼€å§‹ï¼Œä»¥ç›¸ç­‰çš„æ¦‚ç‡éšæœºé€‰æ‹©ä¸€ä¸ªæœ‰è¿è¾¹çš„ç‚¹ï¼Œå¹¶æ²¿è¿™æ¡è¾¹èµ°åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œé‡å¤è¿™ä¸ªè¿‡ç¨‹ï¼Œç›´åˆ°èµ°åˆ° $n$ å·èŠ‚ç‚¹ä¸ºæ­¢ï¼Œä¾¿å¾—åˆ°ä¸€æ¡ä» $1$ å·èŠ‚ç‚¹åˆ° $n$ å·èŠ‚ç‚¹çš„è·¯å¾„ï¼Œè¯·ä½ æ±‚å‡ºè¯¥ç®—æ³•å¾—åˆ°çš„è·¯å¾„çš„ XOR å’Œçš„æœŸæœ›å€¼ã€‚\nè®¾ $(x, y, w)$ ä¸ºå›¾ä¸­çš„ä¸€æ¡è¾¹ï¼Œ$1 \\le x, y \\le n$ï¼Œ$0 \\le w \\le 10 ^ 9$ï¼Œ$2 \\le n \\le 100$ï¼Œ$1 \\le m \\le 10000$ã€‚å›¾ä¸­å¯èƒ½æœ‰é‡è¾¹æˆ–è‡ªç¯ã€‚\n é¦–å…ˆå¯èƒ½æƒ³åˆ°è®¾ $f[x]$ ä¸º $x$ ç‚¹çš„ XOR æœŸæœ›ï¼Œæ–¹ç¨‹ä¸º\n$$ f[x] = \\sum_y \\frac{f[y] \\oplus w(x, y)}{deg[x]} $$\nä½†æ˜¯è¿™ç§æ–¹ç¨‹æ˜¯æ— æ³•è½¬ç§»çš„ã€‚å…ˆè€ƒè™‘ç­”æ¡ˆæ˜¯æ€ä¹ˆå¾—åˆ°çš„å‡è®¾æœ‰ä¸€æ¡è·¯å¾„ $P = \\{w_1, w_2, \\dots, w_k\\}$ï¼Œå…¶å¯¹ç­”æ¡ˆçš„è´¡çŒ®ä¸ºï¼š\n$$ p(w_1 \\oplus w_2 \\oplus \\cdots \\oplus w_k) $$\nå¦‚æœæŒ‰ä½è€ƒè™‘ï¼Œåˆ†å­çš„ç»“æœåªä¼šæ˜¯ $0$ æˆ– $1$ï¼Œåªéœ€è¦æ±‚å‡ºåˆ†å­çš„ç»“æœä¸º $1$ çš„æ¦‚ç‡ã€‚\nè®¾ $f[x][0/1]$ ä¸ºç‚¹ $x$ åˆ°ç‚¹ $n$ çš„è·¯å¾„å¼‚æˆ–å€¼ä¸º $0/1$ çš„æ¦‚ç‡ã€‚äºæ˜¯å¯ä»¥å†™æˆæ–¹ç¨‹ï¼š\n$$ f[x][0] = \\sum_y \\frac{f[y][w(x, y)]}{deg[x]}\\\\ f[x][1] = \\sum_y \\frac{f[y][w(x, y) \\oplus 1]}{deg[x]}\\\\ $$\nè®¾å½“å‰æšä¸¾çš„ä½æ•°ä¸º $b$ï¼Œåˆ™å¯¹ç­”æ¡ˆçš„è´¡çŒ®ä¸º $2 ^ b f[1][1]$ã€‚ä¸Šè¿°è½¬ç§»æ˜¾ç„¶å¯ä»¥é«˜æ–¯æ¶ˆå…ƒè§£å†³ï¼Œæ—¶é—´å¤æ‚åº¦ $\\Theta(n ^ 3 \\log_2 w)$ã€‚\næ³¨æ„è¿æ¥è‡ªç¯ä¸è¦è¿ä¸¤éã€‚\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; constexpr int MAXN = 100 + 10; class EquationGroup { public: void init(int n) { this-\u0026gt;n = n; e = vector\u0026lt;vector\u0026lt;long double\u0026gt;\u0026gt;(n + 1, vector\u0026lt;long double\u0026gt;(n + 2, 0)); } vector\u0026lt;long double\u0026gt; \u0026amp;operator[](int x) { return e[x]; } vector\u0026lt;long double\u0026gt; solve() { transform(); calc(); vector\u0026lt;long double\u0026gt; res(n + 1); for (int i = 1; i \u0026lt;= n; ++i) res[i] = e[i][n + 1]; return res; } private: int n; vector\u0026lt;vector\u0026lt;long double\u0026gt;\u0026gt; e; void transform() { for (int i = 1; i \u0026lt;= n; ++i) { int p = i; for (int j = i + 1; j \u0026lt;= n; ++j) if (abs(e[p][i]) \u0026lt; abs(e[j][i])) p = j; if (p != i) for (int j = i; j \u0026lt;= n + 1; ++j) swap(e[i][j], e[p][j]); for (int j = i + 1; j \u0026lt;= n; ++j) { long double rate = e[j][i] / e[i][i]; for (int k = i; k \u0026lt;= n + 1; ++k) e[j][k] -= rate * e[i][k]; } } } void calc() { for (int i = n; i \u0026gt;= 1; --i) { for (int j = i + 1; j \u0026lt;= n; ++j) e[i][n + 1] -= e[i][j] * e[j][n + 1]; e[i][n + 1] /= e[i][i]; } } }; int n, m, mx; EquationGroup e; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; graph[MAXN]; int deg[MAXN]; long double ans; void link(int x, int y, int w) { graph[x].push_back({y, w}); ++deg[x]; if (x != y) { graph[y].push_back({x, w}); ++deg[y]; } } long double calc(int b) { e.init(2 * n); for (int x = 1; x \u0026lt; n; ++x) { e[x][x] += deg[x]; e[x + n][x + n] += deg[x]; for (auto [y, w] : graph[x]) { int w1 = ((w \u0026gt;\u0026gt; b) \u0026amp; 1); e[x][y + w1 * n] += -1; e[x + n][y + (w1 ^ 1) * n] += -1; } } e[n][n] = 1; e[n][2 * n + 1] = 1; e[n + n][2 * n] = 1; e[n + n][2 * n + 1] = 0; auto f = e.solve(); return f[1 + n] * (1 \u0026lt;\u0026lt; b); } int main() { ios::sync_with_stdio(false); cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(3); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) { int x, y, w; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; w; link(x, y, w); mx = max(mx, w); } mx = (int) log2(mx); for (int i = 0; i \u0026lt;= mx; ++i) ans += calc(i); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  ","id":9,"section":"posts","summary":"é«˜æ–¯æ¶ˆå…ƒä¸»è¦ç”¨äºæ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„çš„è§£ï¼ŒåŒæ—¶å¯ä»¥è§£å†³æŸäº›æœ‰åæ•ˆæ€§çš„ DP é—®é¢˜ï¼Œ ç®—æ³•æ€æƒ³ å¢å¹¿çŸ©é˜µ ä¸ºäº†æ›´æ–¹ä¾¿åœ°æ±‚è§£æ–¹ç¨‹ç»„ï¼Œå¯ä»¥å°†ç³»æ•°å’Œå¸¸æ•°é¡¹æ”¾å…¥çŸ©é˜µï¼Œæ¥","tags":["OI","æ•°å­¦","çº¿æ€§ä»£æ•°","é«˜æ–¯æ¶ˆå…ƒ","C++"],"title":"é«˜æ–¯æ¶ˆå…ƒå­¦ä¹ ç¬”è®°","uri":"https://ctj12461.vercel.app/contents/20220206-gauss-elimination-note/","year":"2022"},{"content":"è¿™é‡Œç»™å‡ºä¸€ç§æ— éœ€æ¢æ ¹çš„ DP æ€è·¯ã€‚\nPart 1 æˆ‘ä»¬ä»ç»“ç‚¹çš„æ·»åŠ æ–¹å¼å…¥æ‰‹ï¼Œå¯ä»¥æŠŠç»“ç‚¹åˆ†ä¸ºä¸‰ç±»ï¼š\n åˆå§‹çš„ç»“ç‚¹ï¼Œè¿™ç§ç»“ç‚¹åªæœ‰ä¸€ä¸ª é€šè¿‡ Append æ·»åŠ çš„ç»“ç‚¹ï¼Œä»¥ä¸‹ç®€ç§° A ç±»ç»“ç‚¹ é€šè¿‡ Insert æ·»åŠ çš„ç»“ç‚¹ï¼Œä»¥ä¸‹ç®€ç§° I ç±»ç»“ç‚¹  ä¸æ¢æ ¹çš„æ€è·¯æ ¸å¿ƒå°±åœ¨äºä¿è¯è½¬ç§»æ—¶çš„è¿‡ç¨‹ç¬¦åˆç»“ç‚¹çš„æ·»åŠ è§„åˆ™ã€‚ä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬å¯ä»¥ç»™æ¯æ¡çº¿å®šå‘ã€‚åŒæ—¶å‡è®¾ $1$ ä¸ºæ ¹ï¼Œ$x$ ä¸ºå½“å‰ç»“ç‚¹ï¼Œ$y$ ä¸º $x$ çš„ä¸€ä¸ªå„¿å­ç»“ç‚¹ï¼Œ$fa$ ä¸º $x$ çš„çˆ¶äº²ç»“ç‚¹ã€‚å¾ˆæ˜¾ç„¶æ¥ä¸‹æ¥å¯ä»¥åˆ† $6$ ç±»è®¨è®ºï¼š\n  è‹¥ $x$ ä¸ºåˆå§‹ç»“ç‚¹ï¼Œåˆ™å…¶å­ç»“ç‚¹ã€$fa$ éƒ½åº”è¯¥è¿å‘ $x$\n  è‹¥ $x$ ä¸º A ç±»ç»“ç‚¹\n $x$ å‘ $fa$ è¿ä¸€æ¡çº¢çº¿ï¼Œå­ç»“ç‚¹è¿å‘ $x$ $x$ å‘å…¶ä¸­ä¸€ä¸ªå­ç»“ç‚¹ $y$ è¿ä¸€æ¡çº¢çº¿ï¼Œå…¶ä»–å­ç»“ç‚¹ä»¥åŠ $fa$ è¿å‘ $x$    è‹¥ $x$ ä¸º I ç±»ç»“ç‚¹\n $x$ å–ä»£ä¸€ä¸ªå­ç»“ç‚¹ $y$ è¿å‘ $fa$ çš„çº¢çº¿ï¼Œç„¶åæ¢æˆè“çº¿ $x$ å–ä»£ä¸¤ä¸ªä¸ªå­ç»“ç‚¹ $y_1$ å’Œ $y_2$ ä¹‹é—´çš„çº¢çº¿ï¼Œç„¶åæ¢æˆè“çº¿ $x$ å–ä»£ $fa$ è¿å‘ä¸€ä¸ªå­ç»“ç‚¹ $y$ çš„çº¢çº¿ï¼Œç„¶åæ¢æˆè“çº¿    ä¸Šé¢çš„åˆ†ç±»è®¨è®ºä¸­çš„â€œè¿å‘â€å¯ä»¥çœ‹æˆ Append æˆ– Insertï¼Œæ ¹æ®é¢˜æ„è®¡ç®—å°±å¯ä»¥äº†ã€‚\nPart 2 æ¥ä¸‹æ¥æ ¹æ®åˆ†ç±»è®¨è®ºè®¾å‡ºçŠ¶æ€ä»¥åŠå†™å‡ºæ–¹ç¨‹ï¼š\nlong long f[MAXN][6]; /** * f[x][0]: x is initial * f[x][1]: x -\u0026gt; fa * f[x][2]: x -\u0026gt; y * f[x][3]: y -\u0026gt; x -\u0026gt; fa * f[x][4]: y1 -\u0026gt; x -\u0026gt; y2 * f[x][5]: fa -\u0026gt; x -\u0026gt; y */  è®¾ $cont(x)$ è¡¨ç¤º $x$ å‘å…¶çˆ¶ç»“ç‚¹è¿çº¿çš„è´¡çŒ®ï¼Œåˆ™ $cont(x)=\\max\\{f[x][1],f[x][3]+len(x,fa(x))\\}$ã€‚ $$ f[x][0]=\\sum_{y\\in son(x)}cont(y)\\\\ f[x][1]=\\sum_{y\\in son(x)}cont(y)\\\\ f[x][2]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{\\max\\{f[y][0], f[y][2], f[y][4], f[y][5] + len(y,x)\\}-cont(y)\\}\\\\ f[x][3]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{f[y][1]+len(y,x)-cont(y)\\}\\\\ f[x][4]=\\sum_{y\\in son(x)}cont(y)+\\\\\\max_{y_1,y_2\\in son(x)\\wedge y_1\\ne y_2}\\{ f[y_1][1]+len(y_1,x)-cont(y_1)+\\max\\{f[y_2][0], f[y_2][2], f[y_2][4]\\}+len(y_2,x)-cont(y_2)\\}\\\\ f[x][5]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{\\max\\{f[y][0], f[y][2], f[y][4]\\}+len(y,x)-cont(y)\\} $$ ä¸Šé¢çš„è½¬ç§»éƒ½å¯ä»¥çœ‹æˆå…ˆä»å­ç»“ç‚¹æŒ‰ç…§ $cont(x)$ è½¬ç§»ï¼Œåœ¨é’¦å®šæŸä¸ªç»“ç‚¹æŒ‰ç…§ç‰¹å®šçš„æ–¹å¼è½¬ç§»ï¼Œè®°å½•ä¸‹æœ€ä¼˜çš„å·®å€¼åœ¨åŠ åˆ° $f$ é‡Œå³å¯ã€‚$f[x][4]$ æœ‰ä¸¤ä¸ªå˜é‡ï¼Œå¯ä»¥è€ƒè™‘æšä¸¾å…¶ä¸­ä¸€ä¸ªï¼Œç”¨ std::multiset\u0026lt;T\u0026gt; ç»´æŠ¤å¦å¤–ä¸€ä¸ªçš„æœ€å€¼å³å¯ã€‚\næ—¶é—´å¤æ‚åº¦ $O(n \\log_2 n)$ã€‚\nPart 3 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; constexpr int MAXN = 200000 + 10; constexpr int INFINITY = 0x7fffffff; int n; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; tree[MAXN]; long long f[MAXN][6]; /** * f[x][0]: x is initial * f[x][1]: x -\u0026gt; fa * f[x][2]: x -\u0026gt; y * f[x][3]: y -\u0026gt; x -\u0026gt; fa * f[x][4]: y1 -\u0026gt; x -\u0026gt; y2 * f[x][5]: fa -\u0026gt; x -\u0026gt; y */ void link(int x, int y, int l) { tree[x].push_back({y, l}); tree[y].push_back({x, l}); } void dfs(int x, int fa) { if (tree[x].size() == 1 \u0026amp;\u0026amp; fa != 0) { f[x][2] = f[x][3] = f[x][4] = f[x][5] = -INFINITY; return; } long long sum = 0, delta[4] = {-INFINITY, -INFINITY, -INFINITY, -INFINITY}; multiset\u0026lt;long long\u0026gt; val; val.insert(-INFINITY); for (auto [y, l] : tree[x]) { if (y == fa) continue; dfs(y, x); long long cont = max(f[y][1], f[y][3] + l); sum += cont; for (int i = 0; i \u0026lt; 6; ++i) f[x][i] += cont; delta[0] = max(delta[0], max(max(max(f[y][0], f[y][2]), f[y][4]), f[y][5] + l) - cont); delta[1] = max(delta[1], f[y][1] + l - cont); delta[3] = max(delta[3], max(max(f[y][0], f[y][2]), f[y][4]) + l - cont); val.insert(f[y][1] + l - cont); } for (auto [y, l] : tree[x]) { if (y == fa) continue; int cont = max(f[y][1], f[y][3] + l); val.erase(val.find(f[y][1] + l - cont)); delta[2] = max(delta[2], *val.rbegin() + max(max(f[y][0], f[y][2]), f[y][4]) + l - cont); val.insert(f[y][1] + l - cont); } f[x][2] += delta[0]; f[x][3] += delta[1]; f[x][4] += delta[2]; f[x][5] += delta[3]; for (int i = 0; i \u0026lt; 6; ++i) if (f[x][i] \u0026lt; 0) f[x][i] = -INFINITY; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; if (n == 1) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } for (int i = 1; i \u0026lt; n; ++i) { int x, y, l; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; l; link(x, y, l); } dfs(1, 0); cout \u0026lt;\u0026lt; max(max(f[1][0], f[1][2]), f[1][4]) \u0026lt;\u0026lt; endl; return 0; }  ","id":10,"section":"posts","summary":"è¿™é‡Œç»™å‡ºä¸€ç§æ— éœ€æ¢æ ¹çš„ DP æ€è·¯ã€‚ Part 1 æˆ‘ä»¬ä»ç»“ç‚¹çš„æ·»åŠ æ–¹å¼å…¥æ‰‹ï¼Œå¯ä»¥æŠŠç»“ç‚¹åˆ†ä¸ºä¸‰ç±»ï¼š åˆå§‹çš„ç»“ç‚¹ï¼Œè¿™ç§ç»“ç‚¹åªæœ‰ä¸€ä¸ª é€šè¿‡ Append æ·»åŠ çš„ç»“ç‚¹ï¼Œä»¥ä¸‹ç®€ç§° A ç±»ç»“","tags":["OI","DP","æ ‘å½¢ DP","C++"],"title":"Luogu P3647 è¿ç çº¿é¢˜è§£","uri":"https://ctj12461.vercel.app/contents/20220204-luogu-p3647-solution/","year":"2022"}],"tags":[{"title":"Arch Linux","uri":"https://ctj12461.vercel.app/tags/arch-linux/"},{"title":"BSGS","uri":"https://ctj12461.vercel.app/tags/bsgs/"},{"title":"Burnside å¼•ç†","uri":"https://ctj12461.vercel.app/tags/burnside-%E5%BC%95%E7%90%86/"},{"title":"C++","uri":"https://ctj12461.vercel.app/tags/c++/"},{"title":"DP","uri":"https://ctj12461.vercel.app/tags/dp/"},{"title":"Linux","uri":"https://ctj12461.vercel.app/tags/linux/"},{"title":"MultiGenerator","uri":"https://ctj12461.vercel.app/tags/multigenerator/"},{"title":"N æ¬¡å‰©ä½™","uri":"https://ctj12461.vercel.app/tags/n-%E6%AC%A1%E5%89%A9%E4%BD%99/"},{"title":"OI","uri":"https://ctj12461.vercel.app/tags/oi/"},{"title":"PÃ³lya å®šç†","uri":"https://ctj12461.vercel.app/tags/p%C3%B3lya-%E5%AE%9A%E7%90%86/"},{"title":"ä¸­å›½å‰©ä½™å®šç†","uri":"https://ctj12461.vercel.app/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"},{"title":"äºŒåˆ†å›¾","uri":"https://ctj12461.vercel.app/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"title":"å‡½æ•°å¯¹è±¡","uri":"https://ctj12461.vercel.app/tags/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/"},{"title":"åŸæ ¹","uri":"https://ctj12461.vercel.app/tags/%E5%8E%9F%E6%A0%B9/"},{"title":"åŒä½™","uri":"https://ctj12461.vercel.app/tags/%E5%90%8C%E4%BD%99/"},{"title":"å›¾è®º","uri":"https://ctj12461.vercel.app/tags/%E5%9B%BE%E8%AE%BA/"},{"title":"å¤šçº¿ç¨‹","uri":"https://ctj12461.vercel.app/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"å¤šé¡¹å¼","uri":"https://ctj12461.vercel.app/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"title":"å»ºæ¨¡","uri":"https://ctj12461.vercel.app/tags/%E5%BB%BA%E6%A8%A1/"},{"title":"æŠ€æœ¯","uri":"https://ctj12461.vercel.app/tags/%E6%8A%80%E6%9C%AF/"},{"title":"æ‹‰æ ¼æœ—æ—¥æ’å€¼","uri":"https://ctj12461.vercel.app/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"},{"title":"æ•°å­¦","uri":"https://ctj12461.vercel.app/tags/%E6%95%B0%E5%AD%A6/"},{"title":"æ•°è®º","uri":"https://ctj12461.vercel.app/tags/%E6%95%B0%E8%AE%BA/"},{"title":"æ•°è®ºåˆ†å—","uri":"https://ctj12461.vercel.app/tags/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/"},{"title":"æ ‡å‡†åº“","uri":"https://ctj12461.vercel.app/tags/%E6%A0%87%E5%87%86%E5%BA%93/"},{"title":"æ ‘å½¢ DP","uri":"https://ctj12461.vercel.app/tags/%E6%A0%91%E5%BD%A2-dp/"},{"title":"æ¬§æ‹‰å‡½æ•°","uri":"https://ctj12461.vercel.app/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"title":"æ¬§æ‹‰å®šç†","uri":"https://ctj12461.vercel.app/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"title":"ç§¯æ€§å‡½æ•°","uri":"https://ctj12461.vercel.app/tags/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/"},{"title":"ç­›æ³•","uri":"https://ctj12461.vercel.app/tags/%E7%AD%9B%E6%B3%95/"},{"title":"çº¿æ€§ä»£æ•°","uri":"https://ctj12461.vercel.app/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"title":"ç½®æ¢ç¾¤","uri":"https://ctj12461.vercel.app/tags/%E7%BD%AE%E6%8D%A2%E7%BE%A4/"},{"title":"ç¾¤è®º","uri":"https://ctj12461.vercel.app/tags/%E7%BE%A4%E8%AE%BA/"},{"title":"è«æ¯”ä¹Œæ–¯å‡½æ•°","uri":"https://ctj12461.vercel.app/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/"},{"title":"è«æ¯”ä¹Œæ–¯åæ¼”","uri":"https://ctj12461.vercel.app/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"title":"é…ç½®","uri":"https://ctj12461.vercel.app/tags/%E9%85%8D%E7%BD%AE/"},{"title":"é¡¹ç›®","uri":"https://ctj12461.vercel.app/tags/%E9%A1%B9%E7%9B%AE/"},{"title":"é«˜æ–¯æ¶ˆå…ƒ","uri":"https://ctj12461.vercel.app/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"}]}