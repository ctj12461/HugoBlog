{"categories":[{"title":"Document","uri":"https://ctj12461.vercel.app/categories/document/"},{"title":"Olympiad in Information","uri":"https://ctj12461.vercel.app/categories/olympiad-in-information/"},{"title":"Tech","uri":"https://ctj12461.vercel.app/categories/tech/"}],"posts":[{"content":"概述 MultiGenerator 是一个为 OI 而生的多线程并行数据生成库，基于 C++ 17，使用面向对象和泛型等 Morden C++ 高级特性，只需要添加最少的额外代码，就可以获得最高的性能。以下是一个能够指定数据范围的 A + B Problem 数据生成器的示例代码：\n#include \u0026lt;random\u0026gt; #include \u0026lt;MultiGenerator.hpp\u0026gt; using MultiGenerator::DataConfig; using MultiGenerator::GeneratingTask; using MultiGenerator::SolutionTask; using MultiGenerator::NormalTemplate; using MultiGenerator::entry; using MultiGenerator::testcase; /** 指定数据生成器，仅需继承一个抽象类和实现一个成员函数 */ class AddGenerator : public GeneratingTask { private: void generate(std::ostream \u0026amp;data, const DataConfig \u0026amp;config) override { /** DataConfig 为配置信息，可以用于储存数据范围等元信息 */ auto minValue = std::stoi(config.get(\u0026quot;minValue\u0026quot;).value()); auto maxValue = std::stoi(config.get(\u0026quot;maxValue\u0026quot;).value()); std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution\u0026lt;\u0026gt; dist(minValue, maxValue); /** 像 cout 一样输出生成结果 */ data \u0026lt;\u0026lt; dist(gen) \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; dist(gen) \u0026lt;\u0026lt; std::endl; } }; /** 指定数据求解器，也仅需继承一个抽象类和实现一个成员函数 */ class AddSolution : public SolutionTask { private: /** 假如你有标程，仅需要吧程序用这个类包装起来，再把 main() 改为这个成员函数即可 */ void solve(std::istream \u0026amp;dataIn, std::ostream \u0026amp;dataOut, const DataConfig \u0026amp;) override { int a, b; /** 像 cin 一样读入数据 */ dataIn \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; /** 像 cout 一样输出答案 */ dataOut \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; std::endl; } }; int main() { constexpr int MAX_THREAD_COUNT = 8; constexpr int MAX_TESTCASE_COUNT = 20; constexpr char PROBLEM_NAME[] = \u0026quot;add\u0026quot;; /** 创建一个题目生成模板，指定数据文件名为 add#.in/add#.out，# 是测试点编号，可以含子任务编号 */ MultiGenerator::NormalTemplate temp(PROBLEM_NAME); for (int i = 0; i \u0026lt; MAX_TESTCASE_COUNT; ++i) { /** 添加测试点配置，并指定生成器和求解器 */ temp.add\u0026lt;AddGenerator, AddSolution\u0026gt;(testcase(i, { entry(\u0026quot;minValue\u0026quot;, i * 1000000), entry(\u0026quot;maxValue\u0026quot;, (i + 1) * 1000000) })); } /** 开始根据指定的线程数生成数据 */ temp.execute(MAX_THREAD_COUNT); return 0; }  要求  C++ 17 Compiler C++ 基础知识，包括最基本的模板的使用（基本都可以满足） 能够认真阅读文档  安装 编译器支持 首先确保你有支持 C++ 17 的编译器，如果你已经有了，可以跳过这一步。\nLinux 绝大多数的 Linux 发行版预装的 GCC 版本都比较低，仅能支持 C++ 11，建议使用包管理器进行安装更新版本的 GCC，至少为 GCC 9，建议 GCC 11，这里仅列举部分安装方法，具体请查阅发行版的包管理器文档。\nDebian/Ubuntu/Deepin\n$ sudo apt install gcc-11 g++-11  Arch Linux/Manjaro\n$ sudo pacman -S gcc  CentOS/RHEL\n$ sudo yum -y install centos-release-scl $ yum -y install devtoolset-11-gcc devtoolset-11-gcc-c++ devtoolset-11-binutils echo \u0026quot;source /opt/rh/devtoolset-11/enable\u0026quot; \u0026gt;\u0026gt; /etc/profile  Windows 推荐使用 TDM-GCC，进入下载页面 https://jmeubank.github.io/tdm-gcc/download/，选择 64+32-bit 的安装包，安装即可。\nmacOS 一般 macOS 都已经自带 LLVM 环境和 Clang，如果没有还可以通过安装 Xcode 来安装 g++。\n安装 MultiGenerator MultiGenerator 是一个 header-only 库，所以无需任何编译即可使用，只需要复制 https://github.com/ctj12461/MultiGenerator/tree/master/src 下的所有文件到 include 路径即可。\nLinux $ git clone https://github.com/ctj12461/MultiGenerator.git $ sudo cp -r src/* /usr/local/include  如果你有 xmake，也可以按照如下方式安装：\n$ git clone https://github.com/ctj12461/MultiGenerator.git $ cd MultiGenerator $ sudo xmake install --root MultiGenerator  Windows/macOS 复制 https://github.com/ctj12461/MultiGenerator/tree/master/src 下的所有文件到编译器提供的 include 路径下，具体请在编译器安装路径下搜索或查看相关文档。一个简单的办法是找到 iostream 的位置，然后粘贴到相同的目录下即可。\n快速入门 导入库 仅需要使用 #include \u0026lt;MultiGenerator.hpp\u0026gt; 即可导入本库，库中所有的类和函数全部定义在 MultiGenerator 命名空间下，可以通过 using namespace MultiGenerator 来更加方便地使用本库，但是更推荐的方法是仅对有需要的类或函数使用 using 声明。\n以下是一个简单的例子：\n#include \u0026lt;MultiGenerator.hpp\u0026gt; using MultiGenerator::DataConfig; using MultiGenerator::GeneratingTask; using MultiGenerator::SolutionTask; using MultiGenerator::NormalTemplate; using MultiGenerator::entry; using MultiGenerator::testcase; int main() { return 0; }  事实上 MultiGenerator 对内部实现细节做了较多的封装，如果有使用 IDE 的智能提示功能，可能会发现有若干子命名空间，如 MultiGenerator::Context，MultiGenerator::Interface 等等，在绝大多数情况下，您都不需要使用这些内部的组件，只需使用定义在 MultiGenerator 下的部分，下文也仅会介绍这一部分。\n以下是本项目的目录结构。\nMultiGenerator/src ├── MultiGenerator │ ├── Context │ │ ├── Environment.hpp │ │ └── Stream.hpp │ ├── Executor │ │ ├── Channel.hpp │ │ ├── TaskExecutor.hpp │ │ └── ThreadPool.hpp │ ├── Interface │ │ ├── Component.hpp │ │ ├── Template.hpp │ │ └── Utility.hpp │ ├── Variable │ │ ├── Argument.hpp │ │ └── DataConfig.hpp │ └── Workflow │ ├── Callable.hpp │ ├── Runner.hpp │ ├── TaskGroup.hpp │ └── Task.hpp └── MultiGenerator.hpp  基本概念 Task 在 MultiGenerator 中，生成的过程可以被拆分为若干个部分，每个部分有不同的功能，比如根据参数生成数据，或者读入数据并输出正确答案。这样的每个部分被成为 Task。\nMultiGenerator 预定义了 3 种 Task，它们是更加具体的 Task，并规定了相关功能的接口，以便使用：\n GeneratingTask：表示所有生成数据的 Task 的抽象类，可以继承该抽象类并实现接口函数来获得生成数据的功能。 SolutionTask：表示所有根据给定数据求解答案的 Task 的抽象类，可以继承该抽象类并实现接口函数来获得求解答案的功能。一般使用您的标准程序即 std 来实现。 IntegratedGeneratingTask：表示所有同时生成数据和求解答案的 Task 的抽象类，可以用于实现必须同时生成和求解的生成器，比如一些强制在线题目。  您只需实现这些抽象类的接口，并通过给定的流进行 IO 操作，无需考虑文件系统相关的问题，MultiGenerator 可以处理它们。\nTemplate Template 规定了一道题目的生成程序应该如何调用 Task，比如普通的题目，没有强制在线操作，此时只需要分别生成数据和求解答案，就可以使用 NormalTemplate 来管理这些 GeneratingTask 和 SolutionTask。\nMultiGenerator 预定义了 2 种 Template：\n NormalTemplate：可以调用实现了 GeneratingTask 和 SolutionTask 的类，用于普通的数据生成，由于生成和求解是可分离的，所以可以更好地利用系统资源进行并行优化。 IntegratedTemplate：可以调用实现了 IntegratedGeneratingTask 的类，可以用于需要强制在线的题目的数据生成。  Template 可以接受一个字符串作为题目的名称，所有生成的数据都会自动带上该名称。然后您可以向 Template 添加测试点信息，如要使用的生成器（实现了 GeneratingTask）和求解器（实现了 SolutionTask），测试点编号，测试点的数据规模配置等。随后 Template 会自动将这些参数传给 Task，实现数据生成的定制。\n如果您需要对不同的测试点应用不同的生成器，比如在使用 NormalTemplate 时，需要构造具有特殊性质的数据，您可以定义多个生成器，只要它们实现了 GeneratingTask，就可以被 Template 调用，而无需做任何的特殊判断。\ntestcase testcase 是一个函数，可以用于生成一个测试点的配置，这个测试点可以是一个子任务中的测试点。它还接受一个 std::unordered_map\u0026lt;std::string, std::string\u0026gt; 作为测试点配置，这里选用 std::string 作为键和值是因为这样可以最简单的实现配置，假如您需要同时传入 int 和 double 的值作为配置，std::string 可以很好地储存它们。后面会详细介绍如何使用该函数。\nDataConfig DataConfig 储存了测试点配置信息（不包括测试点编号，事实上很少情况会需要编号，因为 MultiGenerator 会在外部自动处理测试点编号，无需 Task 内部插手），testcase 函数所接受的 std::unordered_map\u0026lt;std::string, std::string\u0026gt; 也就是构造它的参数。\nDataConfig 不会自动转换值到您所需要的类型，它只会返回一个 std::string，但是转换类型大多数情况下只需要使用 std::stoi() 或 std::stof() 完成，更加高级的也仅需要使用 std::stringstream 即可。\n创建 Task MultiGenerator 所提供的 Task 已经拥有大部分功能，如如何处理文件名，如何与文件系统交互，但它唯独不知道具体该如何生成数据，所以您只需要通过继承相关 Task 来实现接口，从而补上缺失的一部分功能。\nGeneratingTask 前面提到 GeneratingTask 表示所有生成数据的 Task，所以我们可以这么写：\nclass MyGenerator : public GeneratingTask { private: /** 实现这个接口 */ void generate(std::ostream \u0026amp;data, const DataConfig \u0026amp;config) override { /** 通过 DataConfig 获取配置，get 内填上自定义的键 */ int someValue = std::stoi(config.get(\u0026quot;some key\u0026quot;).value()); /** 在这里实现生成数据 */ int someResult = someFunction(); /** 输出结果 */ data \u0026lt;\u0026lt; someResult \u0026lt;\u0026lt; std::endl; } int sumeFunction() { return /* ... */; } };  如果您不了解 C++ 的面向对象特性，您可查阅相关资料，或者直接复制上面的模板，您只要保留上述 generate(std::ostream \u0026amp;data, const DataConfig \u0026amp;config) 成员函数即可。\nSolutionTask class MySolution : public SolutionTask { private: void solve(std::istream \u0026amp;dataIn, std::ostream \u0026amp;dataOut, const DataConfig \u0026amp;) override { int someValue; /** 像 std::cin 一样读入数据 */ dataIn \u0026gt;\u0026gt; someValue; int someResult = someFunction(); /** 像 std::cout 一样输出答案 */ dataOut \u0026lt;\u0026lt; someResult \u0026lt;\u0026lt; std::endl; } int sumeFunction() { return /* ... */; } };  还是同样的道理，您只需要保留 void solve(std::istream \u0026amp;dataIn, std::ostream \u0026amp;dataOut, const DataConfig \u0026amp;config) 成员函数，并在其中填上自己的东西即可。\n理论上您可以直接将 std 的东西复制进 MySolution 这个类，并把 main() 函数改为这个成员函数，然后做好初始化工作，因为所有的 Task 都是要在堆上分配内存然后运行的，所以不能够保证所有数据都和全局变量一样被初始化为 0。对于数组，可以将其替换为 std::array，它会默认初始化所有的元素为 0，且在使用上和原生数组没有任何差别，包括性能开销。\nIntegratedGeneratingTask 如果您需要同时生成和求解，那 IntegratedGeneratingTask 会是一个很好的选择，它同时提供了两个输出流，分别连接了数据的文件（*.in）和答案的文件（*.out）。\nclass MyIntegratedGenerator : public IntegratedGeneratingTask { private: void generate(std::ostream \u0026amp;dataIn, std::ostream \u0026amp;dataOut, const DataConfig \u0026amp;config) override { while (/* 条件 */) { auto someData = /* ... */; auto someAnswer = /* ... */; dataIn \u0026lt;\u0026lt; someData \u0026lt;\u0026lt; std::endl; dataOut \u0026lt;\u0026lt; someAnswer \u0026lt;\u0026lt; std::endl; } } };  IntegratedGeneratingTask 一般用于为强制在线题目或一些复杂的数据结构题目生成数据。\n","id":0,"section":"posts","summary":"概述 MultiGenerator 是一个为 OI 而生的多线程并行数据生成库，基于 C++ 17，使用面向对象和泛型等 Morden C++ 高级特性，只需要添加最少的额外代码，就可以获得最高的性能。以","tags":["C++","OI","多线程","MultiGenerator","项目"],"title":"MultiGenerator 使用文档","uri":"https://ctj12461.vercel.app/contents/20220404-multigenerator-document/","year":"2022"},{"content":"std::function 和 std::bind 是 C++ 中非常常用的两个工具，然而要正确使用这两个工具还要更深入的理解。\n最近写项目时遇到需要将不可复制构造的对象传给 std::bind 的情况，结果遇到了编译错误。代码逻辑可以抽象为下面这样：\n#include \u0026lt;functional\u0026gt; class Class { public: Class() {} Class(const Class \u0026amp;) = delete; Class \u0026amp;operator=(const Class \u0026amp;) = delete; Class(Class \u0026amp;\u0026amp;) = default; Class \u0026amp;operator=(Class \u0026amp;\u0026amp;) = default; }; void call(std::function\u0026lt;void()\u0026gt; func) { func(); } int main() { auto func = std::bind([](Class \u0026amp;) { /* code */ }, Class()); call(std::move(func)); return 0; }  这个错误 Language Server 是检测不到的，只有在编译后才能发现。编译错误信息如下：\nIn file included from project.cpp:1: In file included from /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/functional:59: /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/bits/std_function.h:159:10: error: call to implicitly-deleted copy constructor of 'std::_Bind\u0026lt;(lambda at project.cpp:19:27) (Class)\u0026gt;' new _Functor(*__source._M_access\u0026lt;const _Functor*\u0026gt;()); ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/bits/std_function.h:196:8: note: in instantiation of member function 'std::_Function_base::_Base_manager\u0026lt;std::_Bind\u0026lt;(lambda at project.cpp:19:27) (Class)\u0026gt;\u0026gt;::_M_clone' requested here _M_clone(__dest, __source, _Local_storage()); ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/bits/std_function.h:283:13: note: in instantiation of member function 'std::_Function_base::_Base_manager\u0026lt;std::_Bind\u0026lt;(lambda at project.cpp:19:27) (Class)\u0026gt;\u0026gt;::_M_manager' requested here _Base::_M_manager(__dest, __source, __op); ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/bits/std_function.h:423:35: note: in instantiation of member function 'std::_Function_handler\u0026lt;void (), std::_Bind\u0026lt;(lambda at project.cpp:19:27) (Class)\u0026gt;\u0026gt;::_M_manager' requested here _M_manager = \u0026amp;_My_handler::_M_manager; ^ project.cpp:20:10: note: in instantiation of function template specialization 'std::function\u0026lt;void ()\u0026gt;::function\u0026lt;std::_Bind\u0026lt;(lambda at project.cpp:19:27) (Class)\u0026gt;, void, void\u0026gt;' requested here call(std::move(func)); ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/functional:493:7: note: explicitly defaulted function was implicitly deleted here _Bind(const _Bind\u0026amp;) = default; ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/functional:412:29: note: copy constructor of '_Bind\u0026lt;(lambda at project.cpp:19:27) (Class)\u0026gt;' is implicitly deleted because field '_M_bound_args' has a deleted copy constructor tuple\u0026lt;_Bound_args...\u0026gt; _M_bound_args; ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:744:17: note: explicitly defaulted function was implicitly deleted here constexpr tuple(const tuple\u0026amp;) = default; ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:599:19: note: copy constructor of 'tuple\u0026lt;Class\u0026gt;' is implicitly deleted because base class '_Tuple_impl\u0026lt;0, Class\u0026gt;' has a deleted copy constructor class tuple : public _Tuple_impl\u0026lt;0, _Elements...\u0026gt; ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:435:17: note: explicitly defaulted function was implicitly deleted here constexpr _Tuple_impl(const _Tuple_impl\u0026amp;) = default; ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:408:7: note: copy constructor of '_Tuple_impl\u0026lt;0, Class\u0026gt;' is implicitly deleted because base class '_Head_base\u0026lt;0UL, Class\u0026gt;' has a deleted copy constructor : private _Head_base\u0026lt;_Idx, _Head\u0026gt; ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:86:17: note: explicitly defaulted function was implicitly deleted here constexpr _Head_base(const _Head_base\u0026amp;) = default; ^ /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/11.2.0/../../../../include/c++/11.2.0/tuple:125:39: note: copy constructor of '_Head_base\u0026lt;0, Class, true\u0026gt;' is implicitly deleted because field '_M_head_impl' has a deleted copy constructor [[__no_unique_address__]] _Head _M_head_impl; ^ project.cpp:7:5: note: 'Class' has been explicitly marked deleted here Class(const Class \u0026amp;) = delete; ^ 1 error generated.  这个编译信息具有一定的误导性，有可能首先会想到的是 std::bind 生成的函数对象不支持复制构造和移动构造，但实际上查看源码后发现，std::bind 返回一个 _Bind\u0026lt;_Signature\u0026gt; 类，其中一个特化为：\ntemplate \u0026lt;typename _Functor, typename... _Bound_args\u0026gt; class _Bind\u0026lt;_Functor(_Bound_args...)\u0026gt; : public _Weak_result_type\u0026lt;_Functor\u0026gt; { _Functor _M_f; tuple\u0026lt;_Bound_args...\u0026gt; _M_bound_args; // ... };  其中 _M_f 在这里是编译器将 lambda 表达式转换后的函数对象，复制构造和移动构造都可以支持，_M_bound_args 则是绑定的参数，使用 std::tuple 实现，其复制构造函数和移动构造函数均为 = default，所以至少移动构造函数也是可用的，也就是 std::bind 返回的这个函数对象 _Bind\u0026lt;_Signature\u0026gt; 也是可以移动构造的，因此 std::move(func) 是没有问题的。\n所以问题出在 std::function 上，再查看 std::function 的源码，找到其构造函数对其他函数对象的重载：\ntemplate \u0026lt;typename _Functor, typename = /* ... */, typename = /* ... */\u0026gt; function(_Functor __f) : _Function_base() { typedef _Function_handler\u0026lt;_Res(_ArgTypes...), _Functor\u0026gt; _My_handler; if (_My_handler::_M_not_empty_function(__f)) { _My_handler::_M_init_functor(_M_functor, std::move(__f)); _M_invoker = \u0026amp;_My_handler::_M_invoke; _M_manager = \u0026amp;_My_handler::_M_manager; } }  如果 std::function 接受了一个函数对象，那么就会使用 _My_handler::_M_init_functor(_M_functor, std::move(__f)) 将该函数对象复制到自身内部的 _M_functor 成员上，而这个函数最终会调用以下两个函数之一：\nstatic void _M_init_functor(_Any_data \u0026amp;__functor, _Functor \u0026amp;\u0026amp;__f, true_type) { ::new (__functor._M_access()) _Functor(std::move(__f)); } static void _M_init_functor(_Any_data \u0026amp;__functor, _Functor \u0026amp;\u0026amp;__f, false_type) { __functor._M_access\u0026lt;_Functor *\u0026gt;() = new _Functor(std::move(__f)); }  事实上也只会调用以上这几个函数，这个过程也都是移动构造，理论上即使删除了复制构造函数也是可以正常工作的，其实问题出在其他函数使用了复制，比如下面这对：\nstatic void _M_clone(_Any_data \u0026amp;__dest, const _Any_data \u0026amp;__source, true_type) { ::new (__dest._M_access()) _Functor(__source._M_access\u0026lt;_Functor\u0026gt;()); } static void _M_clone(_Any_data \u0026amp;__dest, const _Any_data \u0026amp;__source, false_type) { __dest._M_access\u0026lt;_Functor *\u0026gt;() = new _Functor(*__source._M_access\u0026lt;const _Functor *\u0026gt;()); }  这里 __source._M_access\u0026lt;_Functor\u0026gt;() 显然不是右值，只能调用复制构造函数。而模板实例化是全部的，不是只对有使用到的代码进行处理。结论就是不可以用 std::function 保存不可复制构造的函数对象，包括这种 std::bind，因此解决方案也就是不使用 std::function。然而这样就不容易对函数签名进行限制，比如下面的这种方法：\n#include \u0026lt;functional\u0026gt; class Class { public: Class() {} Class(const Class \u0026amp;) = delete; Class \u0026amp;operator=(const Class \u0026amp;) = delete; Class(Class \u0026amp;\u0026amp;) = default; Class \u0026amp;operator=(Class \u0026amp;\u0026amp;) = default; }; template \u0026lt;typename Functor\u0026gt; void call(Functor func) { func(); } int main() { auto func = std::bind([](Class \u0026amp;) { /* code */ }, Class()); call(std::move(func)); return 0; }  ","id":1,"section":"posts","summary":"std::function 和 std::bind 是 C++ 中非常常用的两个工具，然而要正确使用这两个工具还要更深入的理解。 最近写项目时遇到需要将不可复制构造的对象传给 std::bind 的情况，结果遇到了编","tags":["C++","标准库","函数对象","技术"],"title":"std::function 和 std::bind 的使用陷阱","uri":"https://ctj12461.vercel.app/contents/20220329-traps-of-std-function-and-std-bind/","year":"2022"},{"content":"记录一下安装 Arch Linux 后的常用软件安装以及配置。\nyay 使用 yay 从 AUR 上下载各种官方仓库所没有的包。\n项目主页：https://github.com/Jguer/yay。\n从源码安装：\n$ pacman -S --needed git base-devel $ git clone https://aur.archlinux.org/yay.git $ cd yay $ makepkg -si  或者下载二进制包：\n$ pacman -S --needed git base-devel $ git clone https://aur.archlinux.org/yay-bin.git $ cd yay-bin $ makepkg -si  用法与 pacman 一致。\ndebtap debtap 是 AUR 包，用于将 deb 包转换为 pacman 可以使用的包。\n安装：\n$ yay -S debtap  安装后可以编辑 /usr/bin/debtap，替换所有的 http://ftp.debian.org/debian/dists 为 https://mirrors.ustc.edu.cn/debian/dists，替换所有的 http://archive.ubuntu.com/ubuntu/dists 为 https://mirrors.ustc.edu.cn/ubuntu/dists/。\n使用：\n$ sudo debtap -u # 更新源列表 $ debtap -q package.deb # 转换 deb 包，-q 表示不要编辑除元数据之外的信息 $ sudo pacman -U package.tar.xz # 安装生成的包  clementine 一个跨平台的音乐播放器，不仅可以播放各种格式的音乐，还支持提取歌曲的元信息。\n安装：\n$ sudo pacman -S clementine $ sudo pacman -S gst-plugins-good gst-plugins-base \\ gst-libav gst-plugins-bad gst-plugins-ugly  由于 clementine 使用了 GStreamer，所以还要安装必要的插件，否则无法播放音乐。\nwireshark 基于 Qt 编写的开源抓包工具。\n可以编译源码，也可以直接用 pacman 安装：\n$ sudo pacman -S wireshark  默认情况下只能使用 root 用户运行才可以访问网卡等设备，通过修改用户组设置使得常用用户可以直接使用：\n$ sudo groupadd wireshark # 新建一个专用的用户组 $ sudo chgrp wireshark /usr/bin/dumpcap # 将dumpcap更改为wireshark用户组 $ sudo chmod 4755 /usr/bin/dumpcap # 4 表示执行时用户可以与所有者有相同权限 $ sudo gpasswd -a ctj12461 wireshark # 添加自己  附 wireshark 过滤出音乐的 HTTP request 的 pattern：\n(tcp.port == 80 || udp.port == 80) \u0026amp;\u0026amp; (http.request.uri contains \u0026quot;mp3\u0026quot; || http.request.uri contains \u0026quot;m4a\u0026quot; || http.request.uri contains \u0026quot;mp4\u0026quot; || http.request.uri contains \u0026quot;flac\u0026quot; || http.request.uri contains \u0026quot;ogg\u0026quot;)  VS Code 如果直接用包管理器安装 code，则会安装 Code - OSS，这个虽然也是 VS Code，但在协议上与 Microsoft 提供的 Visual Studio Code 不同，所以所带有的内容也有所差别，比如无法登陆 Microsoft 帐号，无法同步设置等。\n如果有需要，可以用 yay 安装 visual-studio-code-bin：\n$ yay -S visual-studio-code-bin  也是直接输入 code 运行。\nWPS 2019 for Linux 目前 WPS 对 Microsoft Office 的支持是最好的，而且还在稳定更新，推荐使用。\n使用 yay 安装，并且要安装可选的依赖包：\n$ yay -S wps-office-cn wps-office-mime-cn wps-office-mui-zh-cn # 安装中文环境的 WPS $ yay -S ttf-wps-fonts wps-office-fonts # 安装字体  如果使用 KDE，可能会遇到字体模糊的情况，这是由缩放不为 100% 引起的问题，WPS 使用了 Qt 所以只要在运行前加上环境变量 QT_SCREEN_SCALE_FACTORS=1 即可，对于启动器或桌面上的 Desktop Entry，只要在 /usr/share/applications 下修改所有含 wps 的 Desktop Entry 文件即可，按照下面修改即可：\n# /usr/share/applications/wps-office-wps.desktop Exec=env QT_SCREEN_SCALE_FACTORS=1 /usr/bin/wps %U  这个方法还适用于其他的 Qt 程序。\nfcitx 5 fcitx 5 使用简单，比较推荐。\n安装：\n$ sudo pacman -S fcitx5-im fcitx5-configtool fcitx5-chinese-addons fcitx5-rime  添加环境变量到 /etc/environment 以正常使用 fcitx5：\nGTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx INPUT_METHOD=fcitx SDL_IM_MODULE=fcitx GLFW_IM_MODULE=ibus  如果无法开机启动，则执以下命令：\n# 通过在 autostart 目录下添加启动项 $ cp /usr/share/applications/org.fcitx.Fcitx5.desktop ~/.config/autostart/  词库安装，可以自己选择：\n$ sudo pacman -S fcitx5-pinyin-zhwiki $ yay -S fcitx5-pinyin-sougou $ yay -S fcitx5-pinyin-zhwiki-rime $ yay -S fcitx5-pinyin-moegirl-rime  解决中文下按 [ 和 ] 输出为其他符号：编辑 /usr/share/fcitx5/punctuation/punc.mb.zh_CN，把 [ 和 ] 映射的字符修改为 【 和 】。\nIcalingua++ 一个 OICQ 前端，基于已经被封杀的 Icalingua，拥有大多数实用功能。GitHub 项目主页：https://github.com/icalingua-plus-plus/icalingua-plus-plus。有各种安装方式，如 AppImage、pacman、yay。\n若使用 pacman 安装，则需先下载软件包，比如是 icalingua-2.6.1-1-x86_64.pkg.tar.zst，则使用以下命令：\n$ sudo pacman -U icalingua-2.6.1-1-x86_64.pkg.tar.zst  若使用 yay：\n$ yay -S icalingua++  这里还是要说一句：tx nm*l。\n","id":2,"section":"posts","summary":"记录一下安装 Arch Linux 后的常用软件安装以及配置。 yay 使用 yay 从 AUR 上下载各种官方仓库所没有的包。 项目主页：https://github.com/Jgue","tags":["Linux","Arch Linux","配置"],"title":"Arch Linux 常用软件配置","uri":"https://ctj12461.vercel.app/contents/20220317-arch-linux-software-config/","year":"2022"},{"content":"二分图 定义 如果一个图 $G=(V,E)$ 中的结点可以被分为两个部分，且两个部分之内的点互相没有连边，则称这种图为二分图。如果每个结点的度数相等且都为 $k$，则称这种二分图为 $k$ - 正则二分图。\n判断 对图的结点进行黑白染色，相连的结点染不同的颜色，若最后满足每条边的两个端点颜色不相同，则这个图是二分图。树也是二分图。\n染色 这里的染色不同于判断的染色，它指的是对边进行染色。若染 $k$ 种颜色，则称其为二分图的 $k$ 染色。\n对于一个 $k$ - 正则二分图来说，它一定可以被 $k$ 染色，而对于一般的二分图，若其最大度数为 $k$，则它也可以被 $k$ 染色。\n匹配 在二分图的边集中选出一个非空子集，且这个非空子集内没有两条边连接了一个相同的端点，则这个非空子集被称为二分图的一个匹配，同样对于一般图也有类似的概念。\n若一个匹配的所含的边数最大，则称这个匹配为最大匹配。\n若二分图两边的结点个数相同，且存在一个匹配满足其中的边连接了所有的点，则这个匹配被称为这个二分图的完美匹配或者完备匹配。\n若每条边有边权，且一个匹配的所含的边的权值和最大，则这个匹配被称为这个二分图的最大权匹配。\n匈牙利算法 交替路 假设在二分图最大匹配的过程中，已经找到了一些边作为一个匹配，则一条交替路就是一个匹配边和非匹配边交替连接组成的简单路径。\n根据二分图的定义，假设一条交替路的起点在左边，且第一条边是匹配边，则这条交替路中的匹配边一定都是从左边到右边，而非匹配边一定是从右边到左边。\n交替路上的结点最多连接一条匹配边和一条非匹配边，所以如果把交替路上的匹配边变为非匹配边，非匹配边变为匹配边，则仍然满足条件，也就是交替路边集的匹配边集的补集也可以是匹配。\n增广路 匈牙利算法的核心就是找增广路，这条增广路是一条交替路。每次增广从左边开始，第一条边是非匹配边，最后一条边也是非匹配边，根据上文的描述，这样的路径的边数为奇数，非匹配边个数比匹配边个数多 $1$，若把匹配边与非匹配边反转，则反转后的边集仍然是一个合法的匹配，且比原来的匹配的边数多了 $1$。如果能找到一条这样的增广路，则此次增广成功。\n具体来说，比如一个左边的结点 $x$ 找到了一个右边的结点 $y$，它没有与其他左边的结点匹配过，则 $e(x,y)$ 可以作为一个匹配边，反转边集前，有 $1$ 条匹配边，$0$ 条非匹配边，增广成功。\n如果右边的结点 $y$ 已经有匹配了，那么就可以让原来 $y$ 的匹配 $x\u0026rsquo;$ 新找一个点 $y\u0026rsquo;$，如果能够找到这个 $y\u0026rsquo;$，那么 $e(x\u0026rsquo;,y\u0026rsquo;)$ 成为一个匹配边，$y$ 就无需和 $x\u0026rsquo;$ 匹配了，也就是说 $y$ 已经变为了一个没有匹配的点，$x$ 就可以与 $y$ 匹配了。如果 $x\u0026rsquo;$ 找不到 $y\u0026rsquo;$，那么 $x\u0026rsquo;$ 就要保持原样，和 $y$ 匹配，那么 $x$ 就不可以和 $y$ 匹配，只能继续寻找下一个可能的结点。\n对于 $x\u0026rsquo;$，它找 $y\u0026rsquo;$ 的过程和 $x$ 找 $y$ 的过程是一样的，所以可以递归实现。\n总结一下，一个结点 $x$ 的寻找过程可以分为两种情况：\n 找到一个未匹配结点 $y$，与它匹配 让一个已匹配的结点 $y$ 和 $y$ 的另一边的结点 $x\u0026rsquo;$ 取消匹配，让 $x\u0026rsquo;$ 找新匹配点 $y\u0026rsquo;$，若取消成功，则 $x$ 与 $y$ 可以匹配  可以发现 $x$ 寻找成功，则匹配边都变成了非匹配边，原来的非匹配边都变成了匹配边，也就是找增广路的过程，然后对这条增广路的匹配边与非匹配边反转，匹配边数加 $1$。就这样对于左边的每个结点都增广，尝试找到左边的每个结点对应的匹配，最后就找到了最大匹配。\n时间复杂度是 $O(|V||E|)$ 的，一般情况下跑不满这个上界。\n代码实现 bool augment(int x) { for (int y : graph[x]) { if (vis[y]) continue; // 无论是否增广成功，对于当前增广路上的结点，下次都可以不用再走这个点 vis[y] = true; // y 没有匹配或者取消 y 的匹配成功 if (!match[y] || augment(match[y])) { match[y] = x; return true; // 找到匹配点，增广成功 } } return false; // 没有找到结点，增广失败 } int hungary() { int res = 0; for (int i = 1; i \u0026lt;= n; ++i) match[i] = 0; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) // 每次增广都要清空 vis[j] = false; if (augment(i)) ++res; } return res; }  二分图最大匹配性质 相关概念 假设有一个图 $G=(V,E)$，下面是一些常见的概念：\n 边覆盖：边覆盖是 $E$ 的一个子集 $E\u0026rsquo;$，$\\forall\\ x \\in E$，满足 $x$ 是边 $e$ 的端点，且 $e \\in E\u0026rsquo;$，也就是 $E\u0026rsquo;$ 中的边的端点的并集是 $V$ 独立集：独立集是 $V$ 的一个子集 $V\u0026rsquo;$，$\\forall\\ x,y \\in V$，满足 $e(x,y) \\notin E$，也就是独立集中的点互不相连 团：团是图 $G$ 的一个子图 $G\u0026rsquo;=(V\u0026rsquo;,E\u0026rsquo;)$，$V\u0026rsquo; \\subseteq V$，$E\u0026rsquo; \\subseteq E$，且团是完全图，即 $\\forall\\ x,y \\in V$，满足 $e(x,y) \\in E\u0026rsquo;$，也就是团中的点互相连边 点覆盖：点覆盖是 $V$ 的一个子集 $V\u0026rsquo;$，$\\forall\\ e(x,y) \\in V$，满足 $x \\in V\u0026rsquo;$ 或 $y \\in V\u0026rsquo;$，也就是 $V\u0026rsquo;$ 中的点所连的边的并集是 $E$  等式 若一个图是二分图，则有如下性质：\n 若二分图不存在孤立的点，则 $|$最小边覆盖$| = |V| - |$最大匹配$|$ $|$最大独立集$| = |$补图的最大团$| = |V| - |$最大匹配$|$ $|$最小点覆盖$| = |$最大匹配$|$  与 DAG 的关系 对于一个 DAG $G$，构造二分图 $G\u0026rsquo;$，满足 $G$ 中的有向边 $e(x,y)$ 与 $G\u0026rsquo;$ 中的边 $e(x,y\u0026rsquo;)$ 一一对应，其中 $x$ 和 $y\u0026rsquo;$ 在两边。此时满足 $|G$ 的最小路径覆盖$| = |G\u0026rsquo;$ 的最小点覆盖$|$。路径覆盖指选出一些路径 $p$ 组成一个集合 $P$，满足图中所有点都被至少一个 $p$ 经过，且 $p \\in P$。\n建模相关 可以通过一些转化把题目转化为二分图的问题，用上面的性质解决，详情见下面的例题。\n例题 Luogu P2055 假期的宿舍  学校放假了……有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。\n比如 A 和 B 都是学校的学生，A 要回家，而 C 来看 B，C 与 A 不认识。我们假设每个人只能睡和自己直接认识的人的床。那么一个解决方案就是 B 睡 A 的床而 C 睡 B 的床。而实际情况可能非常复杂，有的人可能认识好多在校学生，在校学生之间也不一定都互相认识。\n我们已知一共有 $n$ 个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。\n$T$ 组数据，$1\\le T\\le 20$，$1\\le n\\le 50$。\n 每个人只能睡一张床，一张床也只能被一个人睡，所以这就是一个二分图最大匹配的问题，把留在学校的学生和外校的学生放在左边，本校的学生的床放在右边，如果 A 和 B 是朋友，则它们可以睡对方的床（如果有），就把 A 向 B 的床连边，把 B 向 A 的床连边，求最大匹配即可。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; constexpr int MAX_N = 50 + 5; int t, n; bool local[MAX_N], home[MAX_N]; vector\u0026lt;int\u0026gt; graph[MAX_N]; int match[MAX_N]; bool vis[MAX_N]; void clear() { for (int i = 1; i \u0026lt;= n; ++i) { graph[i].clear(); match[i] = 0; } } bool augment(int x) { for (int y : graph[x]) { if (vis[y]) continue; vis[y] = true; if (!match[y] || augment(match[y])) { match[y] = x; return true; } } return false; } bool hungary() { int tot = 0, cnt = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (local[i] \u0026amp;\u0026amp; home[i]) continue; ++tot; for (int j = 1; j \u0026lt;= n; ++j) vis[j] = false; if (augment(i)) ++cnt; } return tot == cnt; } void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; local[i]; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; home[i]; clear(); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { bool fri; cin \u0026gt;\u0026gt; fri; if (fri) { if (local[j]) graph[i].push_back(j); if (local[i]) graph[j].push_back(i); } } if (local[i] \u0026amp;\u0026amp; !home[i]) graph[i].push_back(i); } cout \u0026lt;\u0026lt; (hungary() ? \u0026quot;^_^\u0026quot; : \u0026quot;T_T\u0026quot;) \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; }  Luogu P6268 舞会  某学校要召开一个舞会。已知学校所有 $n$ 名学生中，有 $m$ 对男生和女生互相跳过舞，一个男生或一个女生可能和多个人互相跳过舞。在这个舞会上，要求被邀请的学生中的任何一对男生和女生互相都不能跳过舞。求这个舞会最多能邀请多少个学生参加。\n$1\\le n\\le 1000$，$1\\le m\\le 2000$。\n 把跳过舞的男生和女生连边，因为不可能和同性跳舞，所以可以把这个图看成二分图，男生在左边，女生在右边，要求选出的同学之间没有互相跳过舞，显然同性可以满足这个条件，对于异性，只要没有互相跳过舞，也就是在图中没有连边，这个问题就是求二分图的最大独立集。建出图后先染色，分出二分图的两部分，没有连边的点可以分到任意一遍，然后利用 $|$最大独立集$| = |V| - |$最大匹配$|$ 求出答案即可。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; constexpr int MAX_N = 1000 + 10; constexpr int MAX_M = 2000 + 10; int n, m; int col[MAX_N]; vector\u0026lt;int\u0026gt; tmp[MAX_N], graph[MAX_N]; bool vis[MAX_N]; int match[MAX_N]; void link(vector\u0026lt;int\u0026gt; graph[], int x, int y) { graph[x].push_back(y); } void coloring(int x, int now) { if (vis[x]) return; col[x] = now; vis[x] = true; for (int y : tmp[x]) { if (!now) link(graph, x, y); coloring(y, now ^ 1); } } bool augment(int x) { for (int y : graph[x]) { if (vis[y]) continue; vis[y] = true; if (!match[y] || augment(match[y])) { match[y] = x; return true; } } return false; } int hungary() { int res = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (col[i]) continue; for (int j = 1; j \u0026lt;= n; ++j) vis[j] = false; if (augment(i)) ++res; } return res; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; ++x; ++y; link(tmp, x, y); link(tmp, y, x); } for (int i = 1; i \u0026lt;= n; ++i) if (!vis[i]) coloring(i, 0); cout \u0026lt;\u0026lt; n - hungary() \u0026lt;\u0026lt; endl; return 0; }  Luogu P1129 矩阵游戏  小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \\times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：\n 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。  游戏的目标，即通过若干次操作，使得方阵的主对角线（左上角到右下角的连线）上的格子均为黑色。\n对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。\n$T$ 组数据，$1\\le T\\le 20$，$1\\le n\\le 200$。\n 首先，如果有两个黑色格子在同一行或同一列，则不可能通过任何操作将它们拆分到不同行或不同列，又因为主对角线上的格子两两不在同一行也不在同一列，则游戏有解的条件就是存在 $n$ 个黑色格子两两不在同一行也不在同一列。由于在同一行或同一列的格子最多只能对答案有 $1$ 的贡献，所以可以强制只选择一行或一列中的一个格子。\n考虑把每一行建一个结点放在左边，用 $x$ 表示，每一列建一个结点放在右边，用 $y\u0026rsquo;$表示，如果格子 $x,y$ 为黑色，则连一条边 $e(x,y\u0026rsquo;)$。这样做一个二分图最大匹配，就满足了每一行或每一列最多有 $1$ 的贡献的条件，如果最后存在完美匹配，则游戏有解，否则无解。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; constexpr int MAX_N = 200 + 10; int t, n; vector\u0026lt;int\u0026gt; graph[MAX_N]; bool vis[MAX_N]; int match[MAX_N]; void link(int x, int y) { graph[x].push_back(y); } void clear() { for (int i = 1; i \u0026lt;= n; ++i) { graph[i].clear(); match[i] = 0; } } bool augment(int x) { for (int y : graph[x]) { if (vis[y]) continue; vis[y] = true; if (!match[y] || augment(match[y])) { match[y] = x; return true; } } return false; } int hungary() { int res = 0; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) vis[j] = false; if (augment(i)) ++res; } return res; } void solve() { cin \u0026gt;\u0026gt; n; clear(); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { int col; cin \u0026gt;\u0026gt; col; if (col) link(i, j); } } cout \u0026lt;\u0026lt; (hungary() == n ? \u0026quot;Yes\u0026quot; : \u0026quot;No\u0026quot;) \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; }  Luogu P1963 变换序列  给出一个序列 $0,1,2,\\dots, n-1$，一个变换序列 $T$ 可以 $i$ 变为 $T_i$，$T$ 可以视为一个排列且 $T_i \\in [0,n-1]$。$\\forall\\ x,y \\in [0,n-1]$，定义它们的距离 $D(x,y)=\\min(|x-y|,n-|x-y|)$，即把 $x,y$ 看成环上的点时的距离。给出每个 $D(i,T_i)$，求出一个满足条件的序列 $T$ 且字典序最小，或判断无解。\n$1\\le n\\le 10000$。\n 设 $d_i=D(i,T_i)$，则 $i$ 对于的可能的 $T_i$ 为 $x-d_i,x+d_i,x-(n-d_i),x+(n-d_i)$ 且满足在 $[0,n-1]$ 之内。同时注意判断这些 $T_i$ 带入 $D(i,T_i)$ 的计算式时是否能够满足条件，即 $d_i\\le n-d_i$，如果不能满足，那么这就不是合法的 $D(i,T_i)$，也就无解了。\n然后就是二分图最大匹配了，每个 $i$ 从左边向右边可能的 $T_i$ 连边，可以先求出一个可行解。在求可行解的过程中，为了能够让某些点能够匹配，我们断开了一些已匹配点的匹配关系，所以这个可行解不一定满足字典序最小。\n我们可以再跑一遍最大匹配，让从前往后贪心地让每个点先断开已有的匹配，重新选择编号更小的点，这个过程就是增广的过程，同时根据贪心的思想，更前面的点选择的编号更小一定比后面选这个编号更优，如果在重新增广的过程中遇到要更改更前面的点的匹配时，直接退出即可，即使现在无法换到更小的编号，也能够保证总体上的答案更优。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; constexpr int MAX_N = 1e4 + 10; int n, d[MAX_N]; std::vector\u0026lt;int\u0026gt; graph[MAX_N]; bool vis[MAX_N], fixed[MAX_N]; int match[MAX_N], ans[MAX_N]; inline void link(int x, int y) { graph[x].push_back(y); } bool augment(int x) { for (int y : graph[x]) { if (vis[y]) continue; vis[y] = true; if (match[y] == -1 || augment(match[y])) { match[y] = x; return true; } } return false; } bool exchange(int x) { if (fixed[x]) return false; for (int y : graph[x]) { if (vis[y]) continue; vis[y] = true; if (match[y] == -1 || exchange(match[y])) { match[y] = x; return true; } } return false; } bool hungary() { int res = 0; for (int i = 0; i \u0026lt; n; ++i) match[i] = -1; for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) vis[j] = false; if (augment(i)) ++res; } if (res != n) return false; for (int i = 0; i \u0026lt; n; ++i) { int other = -1; for (int j = 0; j \u0026lt; n; ++j) { vis[j] = false; if (match[j] == i) other = j; } match[other] = -1; if (!exchange(i)) match[other] = i; fixed[i] = true; } return true; } int main() { std::ios::sync_with_stdio(false); std::cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i) { std::cin \u0026gt;\u0026gt; d[i]; if (d[i] \u0026gt; n - d[i]) continue; if (i - d[i] \u0026gt;= 0) link(i, i - d[i]); if (i + d[i] \u0026lt; n) link(i, i + d[i]); if (i - (n - d[i]) \u0026gt;= 0) link(i, i - (n - d[i])); if (i + (n - d[i]) \u0026lt; n) link(i, i + (n - d[i])); } if (hungary()) { for (int i = 0; i \u0026lt; n; ++i) ans[match[i]] = i; for (int i = 0; i \u0026lt; n; ++i) std::cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; std::cout \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026quot;No Answer\u0026quot; \u0026lt;\u0026lt; std::endl; } return 0; }  UVa 1663 Purifying Machine  给出 $m$ 个长度为 $n$ 的模板 01 串，某些串含有至多一个 *，表示此处可以匹配 0 或 1，根据这些模板构造出一个数字集合，满足其中的数字的二进制表示都为 $n$ 位，且能够匹配每一个模板串，要求你构造一些 01 串，最多也可以含有至多一个 *，使得这些数字能够和至少一个 01 串匹配，且该集合外的数字均不能和任意一个 01 串匹配，求最小的 01 串个数。\n$1\\le n\\le 10$，$1\\le m\\le 1000$。\n 容易证明不存在 $3$ 个及以上的数字在二进制表示下只有 $1$ 位互不相同，所以可以把每个数字看作结点，每个含 * 的 01 串看作连接两个匹配的数字的结点的边，则这个图是二分图。\n但是这个二分图并不一定连通，对于那些孤立的结点（数字），只能用固定的 01 串取匹配它们。对于剩下的连通的结点，要有最少的含 * 的 01 串匹配每个结点，相当于选出最少的边，使得每个结点都是这个边集中的某条边的端点，这就是最小边覆盖问题。\n先对二分图染色，做一遍最大匹配，再利用 $|$最小边覆盖$| = |V| - |$最大匹配$|$ 求出连通部分的答案，再加上孤立部分的答案就是总答案了。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAX_N = 10; const int MAX_NODE = (1 \u0026lt;\u0026lt; MAX_N); int n, m; vector\u0026lt;int\u0026gt; tmp[MAX_NODE], graph[MAX_NODE]; int match[MAX_NODE]; bool selected[MAX_NODE], exist[MAX_NODE], vis[MAX_NODE], col[MAX_NODE]; int selectedTot, graphTot; char str[MAX_N + 1]; void link(vector\u0026lt;int\u0026gt; graph[], int x, int y) { graph[x].push_back(y); } bool augment(int x) { for (int i = 0; i \u0026lt; (int) graph[x].size(); ++i) { int y = graph[x][i]; if (vis[y]) continue; vis[y] = true; if (match[y] == -1 || augment(match[y])) { match[y] = x; return true; } } return false; } int hungary() { int res = 0; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) match[i] = -1; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) { if (!exist[i] || col[i]) continue; for (int j = 0; j \u0026lt; (1 \u0026lt;\u0026lt; n); ++j) vis[j] = false; if (augment(i)) ++res; } return res; } void coloring(int x, bool now) { if (vis[x]) return; col[x] = now; vis[x] = true; for (int i = 0; i \u0026lt; (int) tmp[x].size(); ++i) { int y = tmp[x][i]; if (!now) link(graph, x, y); coloring(y, !now); } } int convert(char str[], int len) { int res = 0; for (int i = len - 1; i \u0026gt;= 0; --i) res = (res \u0026lt;\u0026lt; 1) + (str[i] - '0'); return res; } void clear() { selectedTot = graphTot = 0; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) { vis[i] = selected[i] = exist[i] = col[i] = false; tmp[i].clear(); graph[i].clear(); } } void input() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; clear(); for (int i = 1; i \u0026lt;= m; ++i) { cin \u0026gt;\u0026gt; str; for (int j = 0, k = n - 1; j \u0026lt; k; ++j, --k) swap(str[j], str[k]); int pos = -1; for (int j = 0; j \u0026lt; n; ++j) { if (str[j] == '*') { pos = j; break; } } if (pos == -1) { int id = convert(str, n); selected[id] = true; } else { str[pos] = '0'; int id = convert(str, n); selected[id] = true; str[pos] = '1'; id = convert(str, n); selected[id] = true; str[pos] = '*'; } } } void build() { for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) if (selected[i]) ++selectedTot; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) { for (int j = 0; j \u0026lt; n; ++j) { int id1 = (i \u0026amp; (~(1 \u0026lt;\u0026lt; j))), id2 = (i | (1 \u0026lt;\u0026lt; j)); if (selected[id1] \u0026amp;\u0026amp; selected[id2]) { exist[id1] = exist[id2] = true; link(tmp, id1, id2); link(tmp, id2, id1); } } } for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) { if (!exist[i]) continue; ++graphTot; coloring(i, false); } } bool solve() { input(); if (n == 0 \u0026amp;\u0026amp; m == 0) return true; build(); cout \u0026lt;\u0026lt; ((selectedTot - graphTot) + (graphTot - hungary())) \u0026lt;\u0026lt; endl; return false; } int main() { ios::sync_with_stdio(false); bool end = false; do end = solve(); while (!end); return 0; }  ","id":3,"section":"posts","summary":"二分图 定义 如果一个图 $G=(V,E)$ 中的结点可以被分为两个部分，且两个部分之内的点互相没有连边，则称这种图为二分图。如果每个结点的度数相等且都为 $k$，则","tags":["OI","图论","二分图","建模","C++"],"title":"二分图匹配学习笔记","uri":"https://ctj12461.vercel.app/contents/20220222-bipartite-graph-matching-note/","year":"2022"},{"content":"莫比乌斯反演可以用于优化一类式子的计算。\n莫比乌斯函数 定义 莫比乌斯函数的定义如下：\n$$ \\mu(n)= \\begin{cases} 0 \u0026amp; \\exists\\ p^2 \\mid n \\wedge p\u0026gt;1\\\\ (-1)^k \u0026amp; n=\\prod_{i=1}^{k} p_i \\end{cases} $$\n也就是说，如果 $n$ 含有平方约数，则 $\\mu(n)=0$，否则 $\\mu(n)=(-1)^k$，其中 $k$ 为 $n$ 中的本质不同的质约数个数。\n性质 积性函数 $\\mu(n)$ 为积性函数，证明如下：\n设 $a,b$ 满足 $\\gcd(a,b)=1$。\n 若 $a,b$ 其中一个数含有平方约数，则它们的乘积也一定含有平方约数，此时它们的莫比乌斯函数值都为 $0$，即 $\\mu(ab)=\\mu(a)\\mu(b)=0$。 否则 $a,b$ 都不含有平方约数，则设它们的质约数个数分别为 $k_a,k_b$，则 $\\mu(a)=(-1)^{k_a},\\mu(b)=(-1)^{k_b}$，因为满足 $\\gcd(a,b)=1$，故 $ab$ 的质约数个数为 $k_a+k_b$，$\\mu(ab)=(-1)^{k_a+k_b}=(-1)^{k_a}(-1)^{k_b}=\\mu(a)\\mu(b)$。  Q.E.D.\n与常数函数的卷积 这个性质十分重要，是反演的基础。这个性质可以写成 $I * \\mu= \\epsilon$，或者：\n$$ \\sum_{d\\mid n}I(\\frac{n}{d})\\mu(d)=\\epsilon(n) $$\n经常简记为：\n$$ \\sum_{d\\mid n} \\mu(d) = [n=1] $$\n$\\epsilon$ 是 Dirchlet 卷积的单位元函数。\n证明如下：\n考虑 $d$ 作为 $n$ 的约数，其自身对整体的贡献，设 $n,d$ 的唯一分解分别为 $n=\\prod_{i=1}^{k} p_i^{c_i}$，$d=\\prod_{i=1}^{k} p_i^{c\u0026rsquo;_i}$。\n 若 $\\exists\\ p_i$ 满足 $p_i^2 \\mid d$，则 $\\mu(d)=0$，容易发现这样的 $d$ 的唯一分解中，存在一个 $c\u0026rsquo;_i\u0026gt;1$。 若 $n\\ne 1$，则 $k\\ne 0$，对答案有贡献的 $d$ 一定满足 $\\forall\\ i\\in [1,k],c_i\\in [0,1]$，也就是每个 $p_i$ 选一次或不选。枚举 $d$ 选的质约数个数 $i$： $$ \\sum_{i=0}^{k} (-1)^i \\binom{k}{i}= \\sum_{i=0}^{k} \\binom{k}{i} 1^{k-i} (-1)^i= [1+(-1)]^k=0 $$ 特殊考虑 $n=1$，此时 $k=0$： $$ \\sum_{i=0}^{k} (-1)^i \\binom{k}{i}= (-1)^0 \\binom{0}{0}=1 $$  综上，$\\sum_{d\\mid n} \\mu(d) = \\sum_{i=0}^{k} (-1)^i \\binom{k}{i} = [n=1]$\nQ.E.D.\n容斥系数 $\\mu(n)$ 的本质其实是容斥系数，比如这个问题：长度为 $n$ 的整数序列，每个数的取值范围为 $[1,m]$，求满足序列元素的 $\\gcd$ 为 $1$ 的序列个数。\n直接计算比较难，可以用容斥原理，先设 $f(x)$ 为序列元素的 $\\gcd$ 为 $x$ 的倍数的序列个数，再考虑重复。显然 $f(x)=\\lfloor \\frac{m}{x} \\rfloor^{n}$。假设我们用全集的大小 $f(1)$ 减去不合法的部分，对 $f$ 的自变量取值进行讨论：\n 若 $x=x_0^k$ 且 $k\u0026gt;1$，显然 $x$ 是 $x_0$ 的倍数且 $x_0$ 对应的序列集合包含了 $x$ 的情况，所以 $x$ 不需要再被重复计算。 若 $x=ab$，则 $a,b$ 对应的序列集合包含了 $x$ 的情况  若 $a,b$ 对答案都有贡献，则 $x$ 的贡献被多算了一次 若 $a,b$ 其中一个对答案都有贡献，则 $x$ 没有被重复计算 若 $a,b$ 其中对答案都没有贡献，则 $x$ 也不需要对答案有贡献   若 $x=abc$，则 $a,b,c$ 对应的序列集合包含了 $x$ 的情况  若 $a,b,c$ 对答案都有贡献，根据情况 2，$x$ 对应的序列集合含于 $a,b,c,ab,bc,ab$ 中，而 $ab,bc,ab$ 都把 $a,b,c$ 的集合中的 $x$ 的情况扣掉了，所以现在要把 $x$ 的贡献加回去。 若 $a,b,c$ 其中一个对答案都没有贡献，则同情况 2，不需要加贡献 若仅 $a,b,c$ 其中一个对答案都有贡献，则同情况 1，不需要加贡献 若 $a,b,c$ 其中对答案都没有贡献，则 $x$ 也不需要对答案有贡献   etc.  可以看出一个规律：\n 若 $x$ 为某个数的贡献且不等于那个数，则相当于含有平方约数，可以相当于它的贡献乘 $0$ 否则考虑它能够拆成 $x=abc\\cdots$，若其中一个的贡献为 $0$，则 $x$ 本身也不需要对答案有贡献，也就是其中一个数有平方约数，它就不需要有贡献 若都有 $a,b,c,\\dots$ 都有贡献，则贡献是正还是负，取决于 $a,b,c,\\dots$ 的个数，为奇数则为负贡献，否则为正贡献。  这与 $\\mu(n)$ 的定义完全一致，所以我们完全可以把 $\\mu(n)$ 当成容斥系数。\n莫比乌斯反演 反演公式 约数反演公式 $$ f(n)=\\sum_{d\\mid n} g(d) \\implies g(n) = \\sum_{d\\mid n} \\mu(\\frac{n}{d}) f(d) $$\n倍数反演公式 $$ f(n)=\\sum_{n\\mid d} g(d) \\implies g(n) = \\sum_{n\\mid d} \\mu(\\frac{d}{n}) f(d) $$\n常见结论 $$ \\epsilon(n) = \\sum_{d\\mid n}\\mu(d)\\\\ \\varphi(n) = \\sum_{d\\mid n}\\mu(\\frac{n}{d})d = \\sum_{d\\mid n}\\mu(d)\\frac{n}{d}\\\\ d(n) = \\sum_{x\\mid n} I(\\frac{n}{x})I(x) = \\sum_{x\\mid n}1\\\\ \\sigma(n) = \\sum_{d\\mid n} I(\\frac{n}{d})d = \\sum_{d\\mid n} d $$\n或者是 Dirchlet 卷积形式：\n$$ \\epsilon = I * \\mu\\\\ \\varphi = \\mu * id\\\\ d = I * I\\\\ \\sigma = I * id $$\n应用 如果一个函数 $g(n)$ 难以计算，但知道了它与另一个函数 $f(x)$ 的关系，如 Dirchlet 卷积的形式，则可以通过莫比乌斯反演得到。或者可以通过莫比乌斯反演对式子进行变换化简，方便计算。\n例题 Luogu P2522 Problem b  对于给出的 $n$ 个询问，每次求有多少个数对 $(x,y)$，满足 $a \\le x \\le b$，$c \\le y \\le d$，且 $\\gcd(x,y) = k$。\n$1\\le n,k\\le 5\\times 10^4$，$1\\le a\\le b\\le 5\\times 10^4$，$1\\le c\\le d\\le 5\\times 10^4$。\n 设 $S(n,m)=\\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)=k]$，则每次询问的答案为 $S(b,d)-S(a-1,d)-S(b,c-1)+S(a-1,c-1)$。接下来进行 $S(n,m)$ 的推导：\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} S(n,m) \u0026amp; = \\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)=k]\\\\ \u0026amp; = \\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(\\frac{i}{k},\\frac{i}{k})=1]\\\\ \u0026amp; = \\sum_{i=1}^{\\floor{\\frac{n}{k}}} \\sum_{j=1}^{\\floor{\\frac{m}{k}}} [\\gcd(i,j)=1]\\\\ \\end{aligned} $$\n注意到 $[\\gcd(i,j)=1]$ 与 $\\epsilon(\\gcd(i,j))$ 等价，用 $\\epsilon(\\gcd(i,j))$ 替换：\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} S(n,m) \u0026amp; = \\sum_{i=1}^{\\floor{\\frac{n}{k}}} \\sum_{j=1}^{\\floor{\\frac{m}{k}}} [\\gcd(i,j)=1]\\\\ \u0026amp; = \\sum_{i=1}^{\\floor{\\frac{n}{k}}} \\sum_{j=1}^{\\floor{\\frac{m}{k}}} \\epsilon(\\gcd(i,j))\\\\ \u0026amp; = \\sum_{i=1}^{\\floor{\\frac{n}{k}}} \\sum_{j=1}^{\\floor{\\frac{m}{k}}} \\sum_{d\\mid \\gcd(i,j)} \\mu(d)\\\\ \\end{aligned} $$\n变换求和顺序，先枚举 $d$，则 $d\\mid \\gcd(i,j)$，也就是 $d\\mid i \\wedge d\\mid j$，则后续枚举 $i,j$ 也要满足能够被 $d$ 整除：\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} S(n,m) \u0026amp; = \\sum_{i=1}^{\\floor{\\frac{n}{k}}} \\sum_{j=1}^{\\floor{\\frac{m}{k}}} \\sum_{d\\mid \\gcd(i,j)} \\mu(d)\\\\ \u0026amp; = \\sum_{d=1}^{\\min\\left(\\floor{\\frac{n}{k}},\\floor{\\frac{m}{k}}\\right)} \\mu(d) \\sum_{i=1}^{\\floor{\\frac{n}{k}}} [d\\mid i]\\sum_{j=1}^{\\floor{\\frac{m}{k}}} [d\\mid j]\\\\ \u0026amp; = \\sum_{d=1}^{\\min\\left(\\floor{\\frac{n}{k}},\\floor{\\frac{m}{k}}\\right)} \\mu(d) \\floor{\\frac{\\floor{\\frac{n}{k}}}{d}} \\floor{\\frac{\\floor{\\frac{m}{k}}}{d}}\\\\ \u0026amp; = \\sum_{d=1}^{\\min\\left(\\floor{\\frac{n}{k}},\\floor{\\frac{m}{k}}\\right)} \\mu(d) \\floor{\\frac{n}{dk}} \\floor{\\frac{m}{dk}}\\\\ \\end{aligned} $$\n后面的 $\\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\floor{\\frac{n}{dk}} \\floor{\\frac{m}{dk}}$ 用数论分块优化，这个式子就仅有 $O(\\sqrt{n}+\\sqrt{m})$ 种取值，且相同的取值都在连续的一段区间，所以可以预处理 $\\sum_{d=1}^{\\min(n,m)} \\mu(d)$，每一段区间就是 $\\mu(d)$ 的区间和乘后面的式子。\n认为 $a,b,c,d$ 同阶，则时间复杂度 $O(a+n\\sqrt{a})$。\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAX_N = 5e4; int n, t, mu[MAX_N + 10], prime[MAX_N + 10], notPrime[MAX_N + 10]; void sieve(int n) { mu[1] = 1; notPrime[1] = 1; for (int i = 1; i \u0026lt;= n; ++i) { if (!notPrime[i]) { prime[++t] = i; mu[i] = -1; } for (int j = 1; j \u0026lt;= t; ++j) { if (i * prime[j] \u0026gt; n) break; notPrime[i * prime[j]] = true; mu[i * prime[j]] = i % prime[j] == 0 ? 0 : -mu[i]; if (i % prime[j] == 0) break; } } for (int i = 1; i \u0026lt;= n; ++i) mu[i] += mu[i - 1]; } // 这里其实算的是 gcd(i, j) = 1 的个数 // 也就是 S(n, m) = calc(n / k, m / k) int calc(int n, int m) { int res = 0; for (int l = 1, r; l \u0026lt;= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); res += (mu[r] - mu[l - 1]) * (n / l) * (m / l); } return res; } int main() { sieve(); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { int a, b, c, d, k, res = 0; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d \u0026gt;\u0026gt; k; res += calc(b / k, d / k); res -= calc(b / k, (c - 1) / k); res -= calc((a - 1) / k, d / k); res += calc((a - 1) / k, (c - 1) / k); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } return 0; }  Luogu P2257 YY 的 GCD  给出 $n,m$，求满足 $1\\le x\\le n,1\\le y\\le m$ 且 $\\gcd(x,y)$ 为质数的有序数对 $(x,y)$ 个数。\n有 $t$ 组数据，$1\\le t\\le 10^4$，$1\\le n,m\\le 10^7$。\n 设质数集为 $\\mathrm{P}$，则我们要求出以下式子：\n$$ \\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)\\in \\mathrm{P}] $$\n考虑枚举 $p=\\gcd(i,j) \\in \\mathrm{P}$，则：\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} \\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)\\in \\mathrm{P}] \u0026amp; = \\sum_{p\\in \\mathrm{P}} \\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j) = p]\\\\ \u0026amp; = \\sum_{p\\in \\mathrm{P}} \\sum_{d=1}^{\\min\\left(\\floor{\\frac{n}{p}},\\floor{\\frac{m}{p}}\\right)} \\mu(d) \\floor{\\frac{n}{dp}} \\floor{\\frac{m}{dp}} \\end{aligned} $$\n这样子做绝对会 TLE，因为如果使用这个形式进行计算，必须要枚举 $p$，所以进行优化，设 $t=dp$，则 $d=\\frac{t}{p}$，所以式子变成这样：\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} \\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)\\in \\mathrm{P}] \u0026amp; = \\sum_{p\\in \\mathrm{P}} \\sum_{d=1}^{\\min\\left(\\floor{\\frac{n}{p}},\\floor{\\frac{m}{p}}\\right)} \\mu(d) \\floor{\\frac{n}{dp}} \\floor{\\frac{m}{dp}}\\\\ \u0026amp; = \\sum_{p\\in \\mathrm{P}} \\sum_{p\\mid t} \\mu(\\frac{t}{p}) \\floor{\\frac{n}{t}} \\floor{\\frac{m}{t}}\\\\ \u0026amp; = \\sum_{t=1}^{\\min(n,m)} \\floor{\\frac{n}{t}} \\floor{\\frac{m}{t}} \\sum_{p \\mid t} \\mu(\\frac{t}{p}) \\end{aligned} $$\n可以把后面的 $\\sum_{p \\mid t} \\mu(\\frac{t}{p})$ 看成一个与 $t$ 有关的函数，那么我们就可以通过枚举每个质数 $p$，让它去贡献它的每一个倍数，这个可以 $O(n \\log_2 n)$ 预处理，再 $O(n)$ 预处理前缀和，然后每次询问就可以直接数论分块了。\n同样认为 $n,m$ 同阶，则时间复杂度 $O(n \\log_2 n+t\\sqrt{n})$。\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAX_N = 1e7 + 10; int prime[MAX_N], notPrime[MAX_N], mu[MAX_N]; long long sum[MAX_N]; int n, m, t, l; void sieve() { notPrime[0] = notPrime[1] = true; mu[1] = 1; for (int i = 2; i \u0026lt; MAX_N; ++i) { if (!notPrime[i]) { prime[++l] = i; mu[i] = -1; } for (int j = 1; j \u0026lt;= l; ++j) { if (i * prime[j] \u0026gt; MAX_N - 1) break; notPrime[i * prime[j]] = true; mu[i * prime[j]] = i % prime[j] ? -mu[i] : 0; if (i % prime[j] == 0) break; } } for (int i = 1; i \u0026lt;= l; ++i) for (int j = 1; prime[i] * j \u0026lt; MAX_N; ++j) sum[prime[i] * j] += mu[j]; for (int i = 2; i \u0026lt; MAX_N; ++i) sum[i] += sum[i - 1]; } long long calc(int n, int m) { long long res = 0; for (int l = 1, r; l \u0026lt;= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); res += (sum[r] - sum[l - 1]) * (n / l) * (m / l); } return res; } int main() { sieve(); cin \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= t; ++i) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; cout \u0026lt;\u0026lt; calc(n, m) \u0026lt;\u0026lt; endl; } return 0; }  Luogu P3704 数字表格  设 $f_i$ 为斐波那契数列的第 $i$ 项，求: $$ \\prod_{i=1}^{n} \\prod_{j=1}^{m} f_{\\gcd(i,j)} \\bmod (10^9+7) $$\n$t$ 组数据，$1\\le t\\le 10^3$，$1\\le n,m\\le 10^6$。\n 先枚举 $d$ 作为 $\\gcd(i,j)$，考虑每个 $f(d)$ 会被乘几次，也就是把式子化成这样：\n$$ \\prod_{d=1}^{\\min(n,m)} f(d)^{\\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)=d]} $$\n首先可以化简指数，设指数为 $t(d)$：\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} t(d)=\\sum_{k=1}^{\\min\\left(\\floor{\\frac{n}{d}},\\floor{\\frac{m}{d}}\\right)} \\mu(k) \\floor{\\frac{n}{dk}} \\floor{\\frac{m}{dk}}\\\\ \\prod_{d=1}^{\\min(n,m)} f(d)^{\\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)=d]} = \\prod_{d=1}^{\\min(n,m)} f(d)^{t(d)}\\\\ $$\n现在已经可以使用数论分块套数论分块 A 了这道题了，只要再预处理一个前缀积及其逆元，时间复杂度 $O(n+tn^{\\frac{3}{4}}\\log_2 n)$。你没有看错，可以 $\\Theta(n)$ 预处理斐波那契数列的前缀积的逆元。\n这个算法跑得巨慢，实现不好就会 TLE。进行用上面的技巧进行优化，设 $p=dk$，则 $k=\\frac{p}{d}$，则：\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} t(d) = \\sum_{d\\mid p} \\mu(\\frac{p}{d}) \\floor{\\frac{n}{p}} \\floor{\\frac{m}{p}} $$\n先枚举 $p$，现在 $p$ 从指数上变到了底数上，所以加变为乘，也就是变换求积顺序：\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} \\prod_{d=1}^{\\min(n,m)} f(d)^{t(d)} \u0026amp; = \\prod_{p=1}^{\\min(n,m)} \\prod_{d\\mid p} f(d)^{\\mu(\\frac{p}{d}) \\floor{\\frac{n}{p}} \\floor{\\frac{m}{p}}}\\\\ \u0026amp; = \\prod_{p=1}^{\\min(n,m)} \\left(\\prod_{d\\mid p} f(d)^{\\mu(\\frac{p}{d})}\\right)^{\\floor{\\frac{n}{p}} \\floor{\\frac{m}{p}}} \\end{aligned} $$\n所以现在只要预处理出 $\\prod_{d\\mid p} f(d)^{\\mu(\\frac{p}{d})}$，再做前缀积，很明显可以 $O(n\\log_2 n)$ 预处理这个式子，用上文的贡献法实现即可。\n至于求斐波那契数列前缀积的逆元的方法，其实适用于任意的正整数序列。具体可以看这里。\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAX_N = 1e6 + 10; constexpr int MOD = 1e9 + 7; int t, n, m; int prime[MAX_N], mu[MAX_N], tot; bool notPrime[MAX_N]; int fib[MAX_N], ifib[MAX_N]; int prod[MAX_N], iprod[MAX_N]; int tmp[MAX_N]; int power(int x, int y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % MOD; x = 1ll * x * x % MOD; } return res; } void preprocessMu(int n) { notPrime[1] = true; mu[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; mu[i] = -1; } for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * prime[j] \u0026lt;= n; ++j) { notPrime[i * prime[j]] = true; if (i % prime[j]) { mu[i * prime[j]] = -mu[i]; } else { mu[i * prime[j]] = 0; break; } } } } void preprocessFib(int n) { fib[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) fib[i] = (fib[i - 1] + fib[i - 2]) % MOD; tmp[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) tmp[i] = 1ll * tmp[i - 1] * fib[i] % MOD; int itmp = power(tmp[n], MOD - 2); for (int i = n; i \u0026gt;= 1; --i) { ifib[i] = 1ll * itmp * tmp[i - 1] % MOD; itmp = 1ll * itmp * fib[i] % MOD; } } void preprocessProd(int n) { for (int i = 1; i \u0026lt;= n; ++i) prod[i] = 1; for (int i = 1; i \u0026lt;= n; ++i) { if (!mu[i]) continue; if (mu[i] == 1) { for (int j = i, k = 1; j \u0026lt;= n; j += i, ++k) prod[j] = 1ll * prod[j] * fib[k] % MOD; } else { for (int j = i, k = 1; j \u0026lt;= n; j += i, ++k) prod[j] = 1ll * prod[j] * ifib[k] % MOD; } } prod[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { tmp[i] = prod[i]; prod[i] = 1ll * prod[i - 1] * prod[i] % MOD; } iprod[n] = power(prod[n], MOD - 2); for (int i = n - 1; i \u0026gt;= 0; --i) iprod[i] = 1ll * iprod[i + 1] * tmp[i + 1] % MOD; } void solve() { int res = 1; for (int l = 1, r; l \u0026lt;= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); res = 1ll * res * power(1ll * prod[r] * iprod[l - 1] % MOD, 1ll * (n / l) * (m / l) % (MOD - 1)) % MOD; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(false); preprocessMu(MAX_N - 10); preprocessFib(MAX_N - 10); preprocessProd(MAX_N - 10); cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; solve(); } return 0; }  SPOJ GCDMAT GCD OF MATRIX  给出 $n,m$，并给出 $t$ 组询问，每组询问给出 $i_1,j_1,i_2,j_2$，求： $$ \\sum_{i=i_1}^{i_2} \\sum_{j=j_1}^{j_2} \\gcd(i,j) $$\n$1\\le t\\le 500$，$1\\le n,m\\le 5\\times 10^4$，$1\\le i_1\\le i_2 \\le n$，$1\\le j_1\\le j_2 \\le m$。\n 先设 $S(n,m)=\\sum_{i=1}^{n} \\sum_{i=1}^{m} \\gcd(i,j)$，这是一个比较套路的式子，用到了 $\\varphi = \\mu * id$ 的结论：\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} S(n,m) \u0026amp; = \\sum_{d=1}^{\\min(n,m)} d \\sum_{i=1}^{n} \\sum_{j=1}^{m} [\\gcd(i,j)=d]\\\\ \u0026amp; = \\sum_{d=1}^{\\min(n,m)} d \\sum_{k=1}^{\\min\\left(\\floor{\\frac{n}{d}},\\floor{\\frac{m}{d}}\\right)} \\mu(k) \\floor{\\frac{n}{dk}} \\floor{\\frac{m}{dk}}\\\\ \\end{aligned} $$\n设 $p=dk$：\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} S(n,m) \u0026amp; = \\sum_{d=1}^{\\min(n,m)} d \\sum_{k=1}^{\\min\\left(\\floor{\\frac{n}{d}},\\floor{\\frac{m}{d}}\\right)} \\mu(k) \\floor{\\frac{n}{dk}} \\floor{\\frac{m}{dk}}\\\\ \u0026amp; = \\sum_{d}^{\\min(n,m)} d \\sum_{d \\mid p} \\mu(\\frac{p}{d}) \\floor{\\frac{n}{p}}\\floor{\\frac{m}{p}}\\\\ \u0026amp; = \\sum_{p=1}^{\\min(n,m)} \\floor{\\frac{n}{p}}\\floor{\\frac{m}{p}} \\sum_{d \\mid p} \\mu(\\frac{p}{d}) d \\\\ \u0026amp; = \\sum_{p=1}^{\\min(n,m)} \\varphi(p) \\floor{\\frac{n}{p}}\\floor{\\frac{m}{p}} \\end{aligned} $$\n时间复杂度 $O(n+t\\sqrt{n})$。\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAX_N = 1e6 + 10; constexpr int MOD = 1e9 + 7; int t, n, m, i1, i2, j1, j2; int prime[MAX_N], phi[MAX_N], tot; bool notPrime[MAX_N]; void preprocess(int n) { notPrime[1] = 1; phi[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; phi[i] = i - 1; } for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * prime[j] \u0026lt;= n; ++j) { notPrime[i * prime[j]] = true; if (i % prime[j]) { phi[i * prime[j]] = phi[i] * (prime[j] - 1); } else { phi[i * prime[j]] = phi[i] * prime[j]; break; } } } for (int i = 2; i \u0026lt;= n; ++i) { phi[i] = phi[i - 1] + phi[i]; if (phi[i] \u0026gt;= MOD) phi[i] -= MOD; } } int calc(int n, int m) { int res = 0; for (int l = 1, r, e = min(n, m), val; l \u0026lt;= e; l = r + 1) { r = min(n / (n / l), m / (m / l)); val = 1ll * (n / l) * (m / l) % MOD; res = (res + 1ll * (phi[r] - phi[l - 1] + MOD) * val) % MOD; } return res; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; t; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; preprocess(min(n, m)); while (t--) { cin \u0026gt;\u0026gt; i1 \u0026gt;\u0026gt; j1 \u0026gt;\u0026gt; i2 \u0026gt;\u0026gt; j2; long long ans = calc(i2, j2); ans -= calc(i1 - 1, j2); ans -= calc(i2, j1 - 1); ans += calc(i1 - 1, j1 - 1); cout \u0026lt;\u0026lt; (ans % MOD + MOD) % MOD \u0026lt;\u0026lt; endl; } return 0; }  Luogu P6156 简单题  给出 $n, k$，求： $$ \\sum_{i=1}^{n} \\sum_{j=1}^{n} (i+j)^k f(\\gcd(i,j)) \\gcd(i,j)\\\\ f(n) = \\begin{cases} 0 \u0026amp; \\exists\\ p^2 \\mid n \\wedge p\u0026gt;1\\\\ 1 \u0026amp; \\text{otherwise} \\end{cases} $$\n$1\\le n\\le 5\\times 10^6$，$1\\le k\\le 10^{18}$。\n 首先容易发现 $f(n)=\\mu^2(n)$。设答案为 $\\text{ans}$，先枚举 $d=\\gcd(i,j)$：\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} \\text{ans} \u0026amp; = \\sum_{i=1}^{n} \\sum_{j=1}^{n} (i+j)^k \\mu^2(\\gcd(i,j)) \\gcd(i,j)\\\\ \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d \\sum_{i=1}^{n} \\sum_{j=1}^{n} (i+j)^k [\\gcd(i,j)=d]\\\\ \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d^{k+1} \\sum_{i=1}^{n} \\sum_{j=1}^{n} (\\frac{i}{d}+\\frac{j}{d})^k [\\gcd(\\frac{i}{d},\\frac{j}{d})=1]\\\\ \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d^{k+1} \\sum_{i=1}^{\\floor{\\frac{n}{d}}} \\sum_{j=1}^{\\floor{\\frac{n}{d}}} (i+j)^k [\\gcd(i,j)=1]\\\\ \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d^{k+1} \\sum_{t=1}^{\\floor{\\frac{n}{d}}}\\mu(t) \\sum_{i=1}^{\\floor{\\frac{n}{d}}} \\sum_{j=1}^{\\floor{\\frac{n}{d}}} (i+j)^k [t\\mid i][t\\mid j]\\\\ \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d^{k+1} \\sum_{t=1}^{\\floor{\\frac{n}{d}}}\\mu(t) t^k \\sum_{i=1}^{\\floor{\\frac{n}{d}}} \\sum_{j=1}^{\\floor{\\frac{n}{d}}} (\\frac{i}{t}+\\frac{j}{t})^k [t\\mid i][t\\mid j]\\\\ \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d^{k+1} \\sum_{t=1}^{\\floor{\\frac{n}{d}}}\\mu(t) t^k \\sum_{i=1}^{\\floor{\\frac{n}{dt}}} \\sum_{j=1}^{\\floor{\\frac{n}{dt}}} (i+j)^k\\\\ \\end{aligned} $$\n设 $f(n) = \\sum_{i=1}^{n} \\sum_{j=1}^{n} (i+j)^k$，$p=dt$：\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} \\text{ans} \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d^{k+1} \\sum_{t=1}^{\\floor{\\frac{n}{d}}}\\mu(t) t^k \\sum_{i=1}^{\\floor{\\frac{n}{dt}}} \\sum_{j=1}^{\\floor{\\frac{n}{dt}}} (i+j)^k\\\\ \u0026amp; = \\sum_{d=1}^{n} \\mu^2(d)d^{k+1} \\sum_{t=1}^{\\floor{\\frac{n}{d}}}\\mu(t) t^k f\\left(\\floor{\\frac{n}{dt}}\\right)\\\\ \u0026amp; = \\sum_{p=1}^{n} f\\left(\\floor{\\frac{n}{p}}\\right) \\sum_{d\\mid p} \\mu^2(d) \\mu\\left(\\frac{p}{d}\\right) d^{k+1} \\left(\\frac{p}{d}\\right)^k\\\\ \u0026amp; = \\sum_{p=1}^{n} f\\left(\\floor{\\frac{n}{p}}\\right) p^k \\sum_{d\\mid p} \\mu^2(d) \\mu\\left(\\frac{p}{d}\\right) d \\end{aligned} $$\n设 $g(n)=\\sum_{d\\mid n} \\mu^2(d) \\mu\\left(\\frac{n}{d}\\right) d$：\n$$ \\newcommand\\floor[1]{\\left\\lfloor #1 \\right\\rfloor} \\begin{aligned} \\text{ans} \u0026amp; = \\sum_{p=1}^{n} f\\left(\\floor{\\frac{n}{p}}\\right) g(p) p^k\\\\ \u0026amp; = \\sum_{p=1}^{n} f\\left(\\floor{\\frac{n}{p}}\\right) g(p) id_k(p) \\end{aligned} $$\n这个式子当中，出现了三个函数，依次考虑怎么求它们。\n求 $f(n)$ 对于 $f(n) = \\sum_{i=1}^{n} \\sum_{j=1}^{n} (i+j)^k$，有两种方法：\n方法 1\n考虑作为底数的 $i+j$ 的每个值出现了多少次，$i+j\\in [2,2n]$，为了方便，我们把 $1$ 也算进去，打表发现每个值的出现次数满足如下函数关系：\n$$ cnt(i)= \\begin{cases} i-1 \u0026amp; i \\le n+1\\\\ 2n-i+1 \u0026amp; i \u0026gt; n+1 \\end{cases} $$\n于是设 $pre[i]=\\sum_{j=1}^{i} (j-1)j^k$，$suf[i]=\\sum_{j=i}^{2n} (2n-j+1)j^k$，$sum[i]=\\sum_{j=1}^{i} j^k$，则：\n$$ f(i)=pre[i+1]+(suf[i+2]-suf[2i+1])-(2n-2i)(sum[2i]-sum[i+1]) $$\n可以看成以 $i+1$ 为分界，前面的用 $pre[i+1]$，后面先用 $suf[i+2]-suf[2i+1]$ 算出在 $[i+2,2i]$ 中的和，因为 $suf[i]$ 以 $2n$ 为参考，还包含 $[i+1,2n]$ 中的值，现在以 $2i$ 为参考，所以会多算 $(2n-2i)(sum[2i]-sum[i+1])$。\n方法 2\n上述式子有更简单的表示方法，设 $s_1(n)=\\sum_{i=1}^{n} i^k$，$s_2(n)=\\sum_{i=1}^{n}s_1(i)$，则 $f(n)=s_2(2n)-2s_2(n)$，证明省略，事实证明方法 1 更容易发现。\n两种方法预处理的时间复杂度都是 $\\Theta(n)$。\n求 $g(n)$ 根据积性函数的判断性质：若 $f(n),g(n)$ 均为积性函数，则下列函数也为积性函数：\n$$ h_1(n)=f(n)g(n)\\\\ h_2(n)=\\sum_{d\\mid n} f(\\frac{n}{d}) g(d) $$\n分析 $g(n)=\\sum_{d\\mid n} \\mu^2(d) \\mu\\left(\\frac{n}{d}\\right) d$ 的表达式：$g(n)$ 是 $\\mu^2(n)n$ 和 $\\mu(n)$ 的 Dirchlet 卷积，$\\mu^2(n)n$ 由三个函数 $\\mu(n),\\mu(n),n$ 三个函数相乘得到，故 $g(n)$ 为积性函数。\n分析 $g(n)$ 的性质，可以先从 $g(p^k)$ 的值入手，其中 $p$ 为质数：\n $k=0$，则 $g(p^k)=g(1)=\\mu^3(1)=1$ $k=1$，则 $g(p^k)=g(p)=\\mu^2(1)\\mu(p)+\\mu^2(p)\\mu(1)p=p-1$ $k=2$，则 $g(p^k)=g(p^2)=\\mu^2(1)\\mu(p^2)+\\mu^2(p)\\mu(p)p+\\mu^2(p^2)\\mu(1)=-p$ $k\\ge 3$，根据抽屉原理，$d$ 和 $\\frac{p^k}{d}$ 中至少有一个的 $p$ 的指数大于 $1$，故 $\\mu^2(d)$ 和 $\\mu\\left(\\frac{p^k}{d}\\right)$ 至少有一个为 $0$，相乘后 $g(p^k)=0$  所以在欧拉筛时根据 $i\\cdot prime[j]$ 与 $prime[j]$ 的关系进行计算即可。时间复杂度 $\\Theta(n)$。\n求 $id_k(n)$ 再考虑求 $id_k(n)$，这是个完全积性函数，所以随便筛一下就可以了，比如在遇到质数 $p$ 时用快速幂求一下 $id_k(p)$，其他时候就令 $id_k(i\\cdot prime[j])=id_k(i)id_k(prime[j])$ 即可，时间复杂度 $\\Theta(n+\\pi(n)\\log_2 k)\\approx \\Theta(n)$。\n然后预处理一下 $g(n)id_k(n)$ 的前缀和，数论分块求解即可，总时间复杂度 $O(n+\\sqrt{n})$。这种方法也可以通过 $1\\le n\\le 10^7$ + 多组询问的加强版。\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAX_N = 5e6 + 10; constexpr int MAX_SIZE = 1e7 + 10; constexpr int MOD = 998244353; int n; long long k; int prime[MAX_SIZE], tot; bool notPrime[MAX_SIZE]; int prod[MAX_SIZE], f[MAX_N], g[MAX_SIZE], sum[MAX_N]; int fPre[MAX_SIZE], fSuf[MAX_SIZE], fSum[MAX_SIZE]; int ans; int power(int x, long long y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % MOD; x = 1ll * x * x % MOD; } return res; } void sieve(int n) { n *= 2; prod[1] = 1; g[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; prod[i] = power(i, k); g[i] = i - 1; } for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; 1ll * i * prime[j] \u0026lt;= n; ++j) { const int next = i * prime[j]; notPrime[next] = true; prod[next] = 1ll * prod[i] * prod[prime[j]] % MOD; if (i % prime[j]) { g[next] = g[i] * (prime[j] - 1); } else if ((i / prime[j]) % prime[j]) { g[next] = -g[i / prime[j]] * prime[j]; break; } else { g[next] = 0; break; } } } n /= 2; for (int i = 1; i \u0026lt;= n; ++i) { sum[i] = (sum[i - 1] + 1ll * prod[i] * g[i]) % MOD; sum[i] = (sum[i] + MOD) % MOD; } } void preprocess(int n) { for (int i = 1; i \u0026lt;= 2 * n; ++i) { fPre[i] = (fPre[i - 1] + 1ll * prod[i] * (i - 1)) % MOD; fSum[i] = (fSum[i - 1] + prod[i]) % MOD; } for (int i = 2 * n; i \u0026gt;= 1; --i) fSuf[i] = (fSuf[i + 1] + 1ll * prod[i] * (2 * n - i + 1)) % MOD; for (int i = 1; i \u0026lt;= n; ++i) { int mid = i + 1, res = 0; res = ((fPre[mid] + fSuf[mid + 1]) % MOD - fSuf[2 * i + 1]) % MOD; res = (res - 1ll * (2 * n - 2 * i) * (fSum[2 * i] - fSum[mid])) % MOD; res = (res + MOD) % MOD; f[i] = res; } } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; sieve(n); preprocess(n); for (int l = 1, r; l \u0026lt;= n; l = r + 1) { r = n / (n / l); ans = (ans + 1ll * (sum[r] - sum[l - 1] + MOD) * f[n / l]) % MOD; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  ","id":4,"section":"posts","summary":"莫比乌斯反演可以用于优化一类式子的计算。 莫比乌斯函数 定义 莫比乌斯函数的定义如下： $$ \\mu(n)= \\begin{cases} 0 \u0026amp; \\exists\\ p^2 \\mid n \\wedge p\u0026gt;1\\\\ (-1)^k \u0026amp; n=\\prod_{i=1}^{k} p_i \\end{cases} $$ 也就是说，如果 $n$ 含有平方约","tags":["OI","数学","数论","莫比乌斯反演","莫比乌斯函数","数论分块","积性函数","筛法","C++"],"title":"莫比乌斯反演学习笔记","uri":"https://ctj12461.vercel.app/contents/20220220-mobius-inversion-note/","year":"2022"},{"content":"解各种同余方程是同余问题的一个重要部分，本文介绍各种同余方程的求解方法。\n二元线性不定方程 形式 不定方程的范围很广泛，只要没有确定的解的方程都可以叫不定方程。本文主要讨论数论中的不定方程。\n$$ ax+by=c\\ (a,b,c,x,y\\in \\mathrm{Z}) $$\n形如上面这种形式，满足各项的系数和解均为整数的方程就是数论中的不定方程。\n求解 Theorem 1：$\\forall a, b \\in \\mathrm{Z}$，一定存在 $x,y\\in \\mathrm{Z}$，使得 $ax+by=\\gcd(a,b)$。\n这个定理又叫做裴蜀定理，根据这个定理，可以得出不定方程 $ax+by=c$ 有解的充要条件就是 $\\gcd(a,b)\\mid c$。记 $d=\\gcd(a,b)$，则我们可以先求出 $ax\u0026rsquo;+by\u0026rsquo;=d$ 的解，再令 $x=\\frac{c}{d}x\u0026rsquo;,y=\\frac{c}{d}y\u0026rsquo;$，就得出原方程的一组解。\n求 $x\u0026rsquo;,y\u0026rsquo;$ 的过程可以用扩展欧几里得算法，即 exgcd 解决。\nTheorem 2：若 $\\gcd(a,b)=1$，且 $x_0,y_0$ 是方程 $ax+by=c$ 的一组解，则该方程的通解为 $x=x_0+kb,y=y_0-ka$，其中 $k\\in \\mathrm{Z}$。\n换句话说，$x,y$ 这两个解是具有周期性的。根据这个定理，我们知道一定有一个 $x\\in [0,b)$，而对于方程 $ax+by=c$，则一定有一个 $x\\in [0,\\frac{b}{\\gcd(a,b)})$，由此可以求一个不定方程的一个元的最小非负整数解，具体地，假设知道了一个解 $x_0$，则最小非负整数 $x=(x_0 \\bmod m + m) \\bmod m$，其中 $m=\\frac{b}{\\gcd(a,b)}$。\n总结一下，求解二元线性不定方程 $ax+by=c$ 的流程如下：\n 求出 $ax+by=\\gcd(a,b)$ 的一组解 $x\u0026rsquo;,y\u0026rsquo;$，并根据 $\\gcd(a,b)\\mid c$ 判断方程有无解 令 $x=\\frac{c}{\\gcd(a,b)}x\u0026rsquo;,y=\\frac{c}{\\gcd(a,b)}y\u0026rsquo;$，$x,y$ 为 $ax+by=c$ 的一组解 若需要求 $x$ 的最小非负整数解，则将 $x=(x_0 \\bmod m + m) \\bmod m$ 作为最终的答案，其中 $m=\\frac{b}{\\gcd(a,b)}$  线性同余方程 形式 $$ ax \\equiv c \\pmod{p} $$\n形如这样的方程，就被称线性同余方程。\n求解 任意的线性同余方程都可以与一个二元线性不定方程互相转化，比如上面的方程就与二元线性不定方程有如下关系：\n$$ ax \\equiv c \\pmod{p} \\iff ax+py=c $$\n所以可以把线性同余方程转化为一个二元线性不定方程，求出 $x$ 即可，包括有无解的判定条件都是一样的。\n代码 template \u0026lt;typename T\u0026gt; T exgcd(T a, T b, T \u0026amp; x, T \u0026amp; y) { if (b == 0) { x = 1; y = 0; return a; } else { T d = exgcd(b, a % b, x, y); T t = x; x = y; y = t - a / b * y; return d; } } template \u0026lt;typename T\u0026gt; optional\u0026lt;T\u0026gt; solveEquation(T a, T c, T p) { a = (a % p + p) % p; c = (c % p + p) % p; T x, y; T d = exgcd(a, p, x, y); if (c % d != 0) return nullopt; x = (1ll * (c / d) * x % (p / d) + (p / d)) % (p / d); return x; }  中国剩余定理 形式 $$ \\begin{cases} x \\equiv a_1 \\pmod{m_1}\\\\ x \\equiv a_2 \\pmod{m_2}\\\\ \\cdots\\\\ x \\equiv a_n \\pmod{m_n}\\\\ \\end{cases} \\\\ \\forall i\\ne j,\\gcd(m_i,m_j)=1 $$\n形如上面这样的线性同余方程组且满足每个方程的模数两两互质，就可以用中国剩余定理解决。中国剩余定理也叫做 CRT (Chinese Remainder Theorem)。\n求解  令 $M=\\prod_{i=1}^{n} m_i$，$M$ 不对任何数取模 对于 $m_i$，令 $M_i=\\prod_{i\\ne j}m_j=\\frac{M}{m_i}$，$M_i^{-1}$ 为 $M_i$ 对 $m_i$ 的逆元，$c_i=M_iM_i^{-1}$，$c_i$ 不能对 $m_i$ 取模 令 $x=\\sum_{i=1}^{n}a_ic_i \\bmod M$，则 $x$ 为模 $M$ 意义下的唯一解  算法正确性证明 对于 $\\forall i\\ne j$，$m_i\\mid M_j$，故 $m_i\\mid a_jc_j$，所以在模 $m_i$ 情况下，$x \\equiv a_ic_i \\pmod{m_i}$。\n因为 $M_i^{-1}$ 为 $M_i$ 对 $m_i$ 的逆元，故在模 $m_i$ 的同余式中 $c_i\\equiv 1 \\pmod{m_i}$，$a_ic_i\\equiv a_i \\pmod{m_i}$，即 $x \\equiv a_i \\pmod{m_i}$，满足第 $i$ 个方程。\n解在模 $M$ 意义下的唯一性证明 设 $x,y$ 不相等，$x,y\u0026lt;M$，但都满足方程组，则可以有下面的方程组：\n$$ \\begin{cases} x - y\\equiv 0 \\pmod{m_1}\\\\ x - y\\equiv 0 \\pmod{m_2}\\\\ \\cdots\\\\ x - y\\equiv 0 \\pmod{m_n}\\\\ \\end{cases} $$\n则 $\\forall i,m_i\\mid |x-y|$，所以 $M \\mid |x-y|$，即 $|x-y|=kM$，因为 $|x-y|\u0026lt;M$，故 $k=0$，推出 $x=y$，与假设矛盾。\n代码 int exgcd(int a, int b, int \u0026amp; x, int \u0026amp; y) { if (b == 0) { x = 1; y = 0; return a; } else { int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - (a / b) * y; return d; } } int solveEquation(int a, int c, int p) { int x, y; exgcd(a, p, x, y); x = (1ll * x * c % p + p) % p; return x; } inline int inv(int x, int p) { return solveEquation(x, 1, p); } int chineseRemainderTheorem(int n, int a[], int m[]) { int mod = 1, ans = 0; for (int i = 1; i \u0026lt;= n; ++i) mod *= m[i]; for (int i = 1; i \u0026lt;= n; ++i) { int modi = mod / m[i]; ans = (ans + 1ll * a[i] * modi * inv(modi)) % mod; // 用 exgcd 求逆元 } return ans; }  扩展中国剩余定理 形式 $$ \\begin{cases} a_1 x \\equiv c_1 \\pmod{m_1}\\\\ a_2 x \\equiv c_2 \\pmod{m_2}\\\\ \\cdots\\\\ a_n x \\equiv c_n \\pmod{m_n}\\\\ \\end{cases} $$\n相比普通中国剩余定理求解的方程组，少了模数互质的限制。\n求解 考虑合并方程。设当前要合并前 $i$ 个方程，显然可以转化为合并前 $i-1$ 个方程与第 $i$ 个方程。\n设 $x_i$ 为合并前 $i$ 个方程的解，$d_i=\\operatorname{lcm}(m_1,m_2,\\dots,m_i)$。构造 $x_i=sx_{i-1}+t$，我们要使 $x_i$ 能够满足前 $i-1$ 个方程，就要满足以下条件：\n $\\forall j \u0026lt; i$，$a_j(sx_{i-1}+t)\\equiv a_j x_{i-1} \\pmod{m_j}$ $a_i(sx_{i-1}+t) \\equiv c_i \\pmod{m_i}$  最简单的办法就是令 $s=1,t=d_{i-1}y_i$，并求一个合适的 $y_i$，也就是要求出以下方程的解 $y_i$： $$ a_i d_{i-1}y_i \\equiv c_i - a_i x_{i-1} \\pmod{m_i} $$\n用 exgcd 解决，若该线性同余方程无解，则方程组无解，否则求出前 $i$ 个方程的解 $x_i$，进行下一次合并。\n假设各个 $m_i$ 同阶，时间复杂度 $O(n \\log_2 m_i)$。\n代码 int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } int exgcd(int a, int b, int \u0026amp; x, int \u0026amp; y) { if (b == 0) { x = 1; y = 0; return a; } else { int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - (a / b) * y; return d; } } optional\u0026lt;int\u0026gt; solveEquation(int a, int c, int p) { a = (a % p + p) % p; c = (c % p + p) % p; int x, y, d = exgcd(a, p, x, y); if (c % d) return nullopt; x *= (c / d); int m = p / d; x = (x % m + m) % m; return x; } optional\u0026lt;int\u0026gt; exChineseRemainderTheorem(int n, int a[], int c[], int m[]) { int x = 0, d = 1; for (int i = 1; i \u0026lt;= n; ++i) { auto oy = solveEquation(a[i] * d, c[i] - a[i] * x, m[i]); if (!oy.has_value()) return nullopt; int y = oy.value(); int g = gcd(d, m[i]); d = d / g * m[i]; x = (x + 1ll * (d / m[i] * g) * y) % d; } return x; }  BSGS 离散对数 与离散对数相对的是我们熟悉的连续对数，也就是最经常接触的对数。而离散对数是在同余中的一个概念。\n若在模 $m$ 意义下，$x$ 满足以下等式：\n$$ a^x \\equiv b \\pmod{m} $$\n则 $x$ 为以 $a$ 为底的 $b$ 的离散对数。注意离散对数不同于连续对数，一个数的离散对数有很多个，并不是唯一的。\n如果 $\\gcd(a,m)=1$，则我们可以使用 BSGS 算法求解一个数的最小的离散对数。\n求解 因为 $\\gcd(a,m)=1$，则 $a^k$ 对 $m$ 的逆元一定存在。所以我们可以把 $a^x$ 写成 $a^{ps-q}$ 并直接将 $a^{-q}$ 提取出来，即：\n$$ a^{ps} \\equiv ba^q \\pmod{m} $$\n考虑暴力的思路，可以枚举两边的 $p,q$，如果有同余的两个 $a^{ps},ba^q$，就更新答案。\n考虑到枚举会计算许多重复的东西，可以用某种数据结构维护映射表，存下每个 $(ba^q,q)$，再枚举左边找相应的同余的项。我们先假设 $x=ps-q \\in [0,m)$，则当 $s=\\lceil\\sqrt{m}\\rceil$ 时，时间复杂度最优，为 $\\Theta(\\sqrt{m})$ 或 $\\Theta(\\sqrt{m}\\log_2 \\sqrt{m})$，具体为哪种复杂度，取决于是用哈希表还是平衡树实现。\n可解性证明 至于为什么一定有 $x\\in [0,m)$，使用抽屉原理证明：\n对于任意的 $x$，$a^x \\bmod m$ 最多只有 $m$ 种取值，而在 $x\\in [0,m]$ 时，一共有 $m+1$ 种指数，则根据抽屉原理得出必定存在一对 $x,y$ 满足 $a^x \\equiv a^y \\pmod{m}$。设 $t=|x-y|$，则 $a^x a^k=a^{x+t}a^k$，因为已经保证 $\\gcd(a,m)=1$，则逆元一定存在，所以可以规定 $t\\in\\mathrm{Z}$，所以指数具有周期性，一定可以得到 $x\\in [0,m)$。\n代码 int power(int x, int y, int m) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % m; x = 1ll * x * x % m; } return res; } optional\u0026lt;int\u0026gt; bsgs(int a, int b, int m) { a %= m; b %= m; unordered_map\u0026lt;int, int\u0026gt; buc; int s = ceil(sqrt(m)), prod = b, base = power(a, s, m); buc[b] = 0; for (int i = 0; i \u0026lt; s; ++i) { prod = 1ll * prod * a % m; buc[prod] = i; } prod = 1; for (int i = 0; i \u0026lt;= s; ++i) { auto it = buc.find(prod); if (it != buc.end() \u0026amp;\u0026amp; i * s - it-\u0026gt;second \u0026gt;= 0) return i * s - it-\u0026gt;second; prod = 1ll * prod * base % m; } return nullopt; }  扩展 BSGS 形式 $$ a^x \\equiv b \\pmod{m} $$\n其中 $a,m$ 不一定互质。这种情况下，逆元不一定存在，也就不可以把指数拆成两个部分来优化。\n考虑先把式子化为 $\\gcd(a,m)=1$ 的形式。方法是不断提取出 $a$ 与 $m$ 互质的部分，任何整个式子同除以这个数。\n$$ a \\equiv c \\pmod{m} \\iff \\frac{a}{d} \\equiv \\frac{c}{d} \\pmod{\\frac{m}{d}}\\ (d\\mid a \\wedge d\\mid c \\wedge d\\mid m) $$\n这个式子是同余式的基本性质。所以按照这样的方法提取：\n$$ a^x \\equiv b \\pmod{m}\\\\ \\Downarrow\\\\ \\frac{a}{d_1}a^{x-1} \\equiv \\frac{b}{d_1} \\pmod{\\frac{m}{d_1}}\\\\ \\Downarrow\\\\ \\frac{a^2}{d_1 d_2}a^{x-2} \\equiv \\frac{b}{d_1 d_2} \\pmod{\\frac{m}{d_1 d_2}}\\\\ \\Downarrow\\\\ \\vdots\\\\ \\Downarrow\\\\ \\frac{a^k}{d_1 d_2\\cdots d_k}a^{x-k} \\equiv \\frac{b}{d_1 d_2\\cdots d_k} \\pmod{\\frac{m}{d_1 d_2\\cdots d_k}}\\\\ $$\n假设现在 $a$ 与 $\\frac{m}{d_1 d_2\\cdots d_k}$ 互质，就可以用 BSGS 求出最后一个方程的解 $x-k$，再加上 $k$ 就是 $x$ 了。\n需要注意两点：\n 若在提取过程中，出现 $d_1 d_2 \\cdots d_i \\nmid b$，则方程无法再继续提取，方程无解 有可能答案在 $[0,k)$ 内，只要 $O(k)$ 枚举检验即可。  int gcd(int a, int b) { int t; while (b) { t = a; a = b; b = a % b; } return a; } int power(int x, int y, int m) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % m; x = 1ll * x * x % m; } return res; } int exgcd(int a, int b, int \u0026amp; x, int \u0026amp; y) { if (b == 0) { x = 1; y = 0; return a; } else { int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - a / b * y; return d; } } int inverse(int a, int p) { int x, y; exgcd(a, p, x, y); x = (x % p + p) % p; return x; } optional\u0026lt;int\u0026gt; bsgs(int a, int b, int m) { a %= m; b %= m; unordered_map\u0026lt;int, int\u0026gt; buc; int s = ceil(sqrt(m)), prod = b, base = power(a, s, m); buc[b] = 0; for (int i = 0; i \u0026lt; s; ++i) { prod = 1ll * prod * a % m; buc[prod] = i; } prod = 1; for (int i = 0; i \u0026lt;= s; ++i) { auto it = buc.find(prod); if (it != buc.end() \u0026amp;\u0026amp; i * s - it-\u0026gt;second \u0026gt;= 0) return i * s - it-\u0026gt;second; prod = 1ll * prod * base % m; } return nullopt; } optional\u0026lt;int\u0026gt; exBsgs(int a, int b, int m) { a = (a % m + m) % m; b = (b % m + m) % m; if (m == 1 || b == 1) return 0; int prod = 1, d, k = 0; while (true) { d = gcd(a, m); if (d == 1) break; if (b % d) return nullopt; b /= d; m /= d; ++k; prod = prod * (a / d) % m; if (prod == b) return k; } auto res = bsgs(a, 1ll * b * inverse(prod, m) % p, m); if (!res.has_value()) return nullopt; return res.value() + k; }  阶与原根 阶 对于一对互质的整数 $a,m$，若 $r$ 满足 $r \\ne 0$ 且 $a^r \\equiv 1 \\pmod{m}$ 且不存在任何小于 $r$ 的正整数满足该同余式，则称 $r$ 为 $a$ 对 $m$ 的阶，记作 $r = \\delta_m(a)$。\nTheorem 1：$0 \u0026lt; \\delta_m(a) \\le \\varphi(m)$。\n若 $\\gcd(a,m)=1$，则欧拉定理一定成立，即 $a^{\\varphi(m)} \\equiv 1 \\pmod{m}$，显然 $0 \u0026lt; \\delta_m(a) \\le \\varphi(m)$。\nTheorem 2：若 $a^k \\equiv 1 \\pmod{m}$，则 $\\delta_m(a) \\mid k$。\n假设满足 $\\delta_m(a) \\nmid k$ 但 $a^k \\equiv 1 \\pmod{m}$，则 $k=s\\delta_m(a)+t$，其中 $t \\in (0,\\delta_m(a))$，所以：\n$$ a^k \\equiv (a^{\\delta_m(a)})^sa^t \\equiv a^t \\pmod{m} $$\n根据阶的定义，$a^t \\not\\equiv 1 \\pmod{m}$，所以矛盾，故 $\\delta_m(a) \\mid k$。\n原根 若 $a$ 满足 $\\delta_m(a)=\\varphi(m)$，则 $a$ 为 $m$ 的原根。\nTheorem 1：$a$ 为 $m$ 的原根的充要条件为 $\\gcd(a,m)=1$ 且对于 $\\varphi(m)$ 的每一个质因数，$a^{\\frac{\\varphi(m)}{p}} \\not\\equiv 1 \\pmod{m}$。\n根据这个定理，可以轻松判断一个数是否是另一个数的原根。\nint gcd(int a, int b) { int t; while (b) { t = a; a = b; b = t % b; } return a; } int phi(int x) { int res = x; for (int i = 2; i * i \u0026lt;= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } int power(int x, int y, int m) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % m; x = 1ll * x * x % m; } return res; } bool isPrimitiveRoot(int a, int m) { if (gcd(a, m) != 1) return false; int pm = phi(m), tmp = pm; a %= m; for (int i = 2; i * i \u0026lt;= tmp; ++i) { if (tmp % i) continue; if (power(a, pm / i, m) == 1) return false; while (tmp % i == 0) tmp /= i; } if (tmp \u0026gt; 1) if (power(a, pm / tmp, m) == 1) return false; return true; }  Theorem 2：一个数 $m$ 有原根，当且仅当 $m$ 为 $2,4,p^k,2p^k$，其中 $k\\in \\mathrm{N^*}$，$p$ 为奇质数。\nTheorem 3：若一个数 $m$ 有原根，则其原根个数为 $\\varphi(\\varphi(m))$。\nTheorem 4：若一个数 $m$ 有原根，则其最小原根的数量级为 $m^{\\frac{1}{4}}$。\n根据这个性质，只需要暴力枚举每个数，求一个数的最小原根的时间复杂度是可以接受的。\nint gcd(int a, int b) { int t; while (b) { t = a; a = b; b = t % b; } return a; } int phi(int x) { int res = x; for (int i = 2; i * i \u0026lt;= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } int power(int x, int y, int m) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % m; x = 1ll * x * x % m; } return res; } int primitiveRoot(int m) { int pm = phi(m), tmp = pm; vector\u0026lt;int\u0026gt; factor; for (int i = 2; i * i \u0026lt;= tmp; ++i) { if (tmp % i) continue; factor.push_back(i); while (tmp % i == 0) tmp /= i; } if (tmp \u0026gt; 1) factor.push_back(tmp); for (int i = 2; i \u0026lt;= m; ++i) { if (gcd(i, m) != 1) continue; bool found = true; for (int p : factor) { if (power(i, pm / p, m) == 1) { found = false; break; } } if (found) return i; } return -1; }  Theorem 5：若 $a$ 为 $m$ 的原根，则 $a,a^2,a^3,\\dots,a^{\\varphi(m)}$ 两两模 $m$ 不同余。\nTheorem 6：若 $a$ 为 $m$ 的原根，则对于任意的 $x \\in [1,\\varphi(m)]$，一定有一个 $k$ 与其一一对应，满足 $x \\equiv a^k \\pmod{m}$ 且 $k\\in [1,\\varphi(m)]$，$k$ 被称为 $x$ 的指标，记作 $I(x)$。\n比如 $m=13$，其最小原根 $a=2$，则把 $x$ 与 $I(x)$ 写成表格：\n   $x$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $9$ $10$ $11$ $12$     $I(x)$ $12$ $1$ $4$ $2$ $9$ $5$ $11$ $3$ $8$ $10$ $7$ $6$    这个定理可以用于把底数转换为原根的幂，可以利用这个性质解模数为质数的 $N$ 次剩余问题。\nN 次剩余 形式 $$ x^n \\equiv a \\pmod{m} $$\n其中 $m$ 为奇质数，求 $x\\in [0,m)$。由于 $m$ 不是奇质数的方法较复杂，这里不考虑。\n求解 设 $g$ 为其原根，则可以利用原根和指标的性质将 $x$ 转化为 $g^y$，即：\n$$ (g^y)^n \\equiv (g^n)^y \\equiv a \\pmod{m} $$\n这样就可以用 BSGS 求出 $y$，再用快速幂求得 $x$ 即可。\n也可以再将 $a$ 化为 $g^z$，然后方程化为：\n$$ g^{ny} \\equiv g^z \\pmod{m} $$\n于是就可以解出线性同余方程的解 $y$：\n$$ ny \\equiv z \\pmod{m} $$\n代码就不写了，上面组合一下就可以了。\n","id":5,"section":"posts","summary":"解各种同余方程是同余问题的一个重要部分，本文介绍各种同余方程的求解方法。 二元线性不定方程 形式 不定方程的范围很广泛，只要没有确定的解的方程都可","tags":["OI","数学","数论","同余","中国剩余定理","BSGS","原根","N 次剩余","C++"],"title":"同余方程学习笔记","uri":"https://ctj12461.vercel.app/contents/20220213-congruence-equation-note/","year":"2022"},{"content":"Burnside 引理和 Pólya 定理主要用于解决计算本质不同方案数的计数问题。\n群论 基本定义 群可以看成是一个由集合和某个二元运算组成的二元组 $(S,\\cdot)$，这里的 $\\cdot$ 就代表一个二元运算，这个二元运算需要满足结合律、存在单位元和逆元。群有很多的种类，比如置换群、循环群、矩阵群等，其中置换群就是我们接下来要介绍的。\n性质 若一个二元组 $(S,\\cdot)$ 是群，则它满足以下性质：\n 封闭性：$\\forall x,y\\in S$，若 $z=x\\cdot y$，则 $z\\in S$ 结合律：$\\forall x,y,z\\in S$，$(x\\cdot y)\\cdot z=x\\cdot (y \\cdot z)$ 单位元：存在唯一一个元素 $e \\in S$ 满足 $\\forall x \\in S$，$e\\cdot x=x$ 逆元：$\\forall x \\in S$，都可以找到唯一一个元素 $x^{-1}$ 满足 $x \\cdot x^{-1} = e$，这个元素称为 $x$ 的逆元  举一个简单的例子，$(\\mathrm{Z},+)$ 就是一个群，无论取哪两个元素进行加法运算，结果仍然是整数；加法满足结合律；单位元 $e = 0$；任意一个元素 $x$ 的逆元 $x^{-1} = -x$。\n置换与置换群 置换的基本定义 顾名思义，置换群就是置换组成的群。置换可以看成一个有限集合到自身的双射，具体一点，假设有两个长度相同的集合 $p,q$（这里假设集合可以有序），则置换 $f$ 作用于 $p$ 就是生成一个新的集合 $p\u0026rsquo;$，满足 $p\u0026rsquo;_i=p_{q_i}$。\n置换表示成下面这样：\n$$ f= \\begin{pmatrix} p_1, p_2, p_3, \\dots, p_n\\\\ p_{q_1}, p_{q_2}, p_{q_3}, \\dots p_{q_n} \\end{pmatrix} $$\n有时我们会看到这样的置换：\n$$ f= \\begin{pmatrix} 1, 2, 3, \\dots, n\\\\ p_1, p_2, p_3, \\dots, p_n \\end{pmatrix} $$\n这种置换也经常被简写为：\n$$ f= \\begin{pmatrix} p_1, p_2, p_3, \\dots, p_n \\end{pmatrix} $$\n置换的乘法 假设有两个置换 $f,g$，定义它们的乘法为 $f \\cdot g$： $$ f= \\begin{pmatrix} 1, 2, 3, \\dots, n\\\\ p_1, p_2, p_3, \\dots, p_n \\end{pmatrix} , g= \\begin{pmatrix} p_1, p_2, p_3, \\dots, p_n\\\\ q_1, q_2, q_3, \\dots, q_n \\end{pmatrix} \\\\ f \\cdot g = \\begin{pmatrix} 1, 2, 3, \\dots, n\\\\ q_1, q_2, q_3, \\dots, q_n \\end{pmatrix} $$\n循环置换 循环置换是特殊的置换，它表示为下面这样：\n$$ f= \\begin{pmatrix} 1, 2, 3, \\dots n - 1, n\\\\ 2, 3, 4, \\dots, n, 1 \\end{pmatrix} $$\n若两个置换不含相同的元素，则称这两个置换不相交。任何的置换都可以拆分为若干不相交的循环置换的乘积。比如下面的例子：\n$$ \\begin{pmatrix} a_1, a_2, a_3, a_4, a_5, a_6\\\\ a_2, a_1, a_5, a_4, a_6, a_3 \\end{pmatrix}= \\begin{pmatrix} a_1, a_2\\\\ a_2, a_1 \\end{pmatrix} \\cdot \\begin{pmatrix} a_3, a_5, a_6\\\\ a_5, a_6, a_3 \\end{pmatrix} \\cdot \\begin{pmatrix} a_4\\\\ a_4 \\end{pmatrix} $$\n要证明这个定理，可从把每个元素看成结点，上往下连有向边，因为上下两行的下标都是排列，则每个元素都在每一行有且仅出现一次，也就是入度和出度均为 $1$，显然只可能构成若干个简单环，每个简单环就代表一个循环置换。\n置换群 由置换和置换的乘法组成的群就是置换群，置换经过乘法运算后显然还是置换，多个置换的结合顺序先后不影响答案，单位元是恒等置换，即上下两行的元素排列相同，每个置换的逆元是交换上下两行的置换。\n本质不同计数问题与置换 这一类的问题通常会给出一些规定，定义了哪些状态是本质相同的。比如要求给一个 $2 \\times 2$ 的正方形染色，可选颜色有两种，如果一种方案可以通过旋转正方形得到另外一种，则这两种方案等价。\n如果我们把正方形的每个格子看成集合的一个元素，则可以通过定义置换来表示旋转，如果一个状态经过某个置换的作用后得到了另外一个状态，则它们等价。\nBurnside 引理 不动点 对于一个置换 $f$，若 $s$ 满足 $f(s) = s$，则称 $s$ 为 $f$ 的不动点。设有一个集合 $X$ 表示所有的状态，则记 $X^f$ 为 $f$ 作用于 $X$ 中的元素得到的不动点子集，记 $c_1(f) = |X^f|$。\n等价类 若两个集合经过置换作用后相等，则它们属于同一个等价类。\n引理内容 设 $A$，$B$ 为有限集合，$X$ 为 $A$ 到 $B$ 的映射组成的集合，$G$ 为 $A$ 上的置换群，$X/G$ 为 $X$ 中的映射经过 $G$ 中所有的置换作用后的等价类集合，则有：\n$$ |X/G|=\\frac{1}{|G|}\\sum_{f\\in G}|X^f|=\\frac{1}{|G|}\\sum_{f\\in G}c_1(f) $$\n即 $G$ 中所有的置换作用于 $X$ 的不动点个数的均值。\n直接理解这个公式比较难，我们使用上面的染色问题来解释。这里的 $A$ 就是表示 $2 \\times 2$ 正方形中的每个格子，$B$ 代表两种颜色，$X$ 就是代表染色方案，即一种染色方案就是格子对于上一种颜色的映射，$X$ 就是所有这些映射的集合。$G$ 作为 $A$ 上的置换群，代表旋转正方形的各种操作，$X/G$ 是等价类集合，即本质不同的染色方案。\n这个引理的证明比较复杂，需要较好的群论基础，还要了解轨道-稳定子定理，这里就不展开了，反正也不考证明。\n对正方形染色问题的解决 现在具体分析一下这个问题。旋转方法有 $4$ 种，分别是：\n 顺时针旋转 $0$，此时为恒等置换，随意染色，共 $2^4=16$ 种 顺时针旋转 $\\frac{\\pi}{2}$，此时仅有全部颜色相同的方案为不动点，共 $2$ 种 顺时针旋转 $\\pi$，此时只要对角的颜色相同即可，共 $2$ 对对角，每对 $2$ 种方案，共 $2^2 = 4$ 种 顺时针旋转 $\\frac{3\\pi}{2}$，这种情况同第二种，共 $2$ 种  带入公式得：\n$$ |X/G|=\\frac{1}{4}\\times (16+2+4+2)=6 $$\n可以自己枚举验证一下。\nPólya 定理 定理内容 Pólya 定理是 Burnside 引理的具体化，同时也有一定的限制条件。在前置条件于 Burnside 引理相同的情况下，给出 Pólya 定理的公式：\n$$ |X/G|=\\frac{1}{|G|}\\sum_{f\\in G} |B|^{\\tau(f)} $$\n其中 $\\tau(f)$ 表示 $f$ 的循环置换个数。根据上文任何置换都可以拆分为若干不相交循环置换的乘积，循环置换之间互不影响，故循环置换之内的元素染色方案必须相同，这样才能满足经过置换作用后仍然保持不变，即不动点，而循环置换之间可以不同，每个循环置换可以有 $|B|$ 种选择（按照上文的例子就是颜色数），通过乘法得出不动点总数为 $|B|^{\\tau(f)}$。\n一个理解循环置换的方法就是把它看成进行有向图连边后的环，可以通过找环来得出循环置换个数。\n用 Pólya 定理解决正方形染色问题 同样分 $4$ 类讨论：\n 顺时针旋转 $0$，$\\tau(f)=4$，共 $2^4=16$ 种 顺时针旋转 $\\frac{\\pi}{2}$，$\\tau(f)=1$，共 $2$ 种 顺时针旋转 $\\pi$，$\\tau(f)=2$，共 $2^2 = 4$ 种 顺时针旋转 $\\frac{3\\pi}{2}$，$\\tau(f)=1$，共 $2$ 种  $$ |X/G|=\\frac{1}{4}\\times (16+2+4+2)=6 $$\nPólya 定理的限制 有时题目会在染色方面做限制，例如某种颜色的使用次数，或颜色之间的互相制约等等，此时 Pólya 定理的简单计数就不管用了，需要通过 DP 或组合数学的方法求出不动点个数，带入 Burnside 引理公式计算。\n例题 Luogu P4980 【模板】Pólya 定理  给定一个 $n$个点，$n$ 条边的环，有 $n$ 种颜色，给每个顶点染色，问有多少种本质不同的染色方案，答案对 $10^9+7$ 取模。\n注意本题的本质不同，定义为：只需要不能通过旋转与别的染色方案相同。\n$1\\le n \\le 10^9$，$1\\le t \\le 10^3$。\n 容易想到旋转操作可以表示成 $n$ 种置换，第 $i$ 种代表旋转顺时针 $\\frac{2\\pi i}{n}$，即将每个点向前移动 $i$ 格。考虑第 $i$ 个置换拆分的循环置换个数，列出置换表达式：\n$$ f_i= \\begin{pmatrix} 1,2,3,\\dots,n-1,n\\\\ n-i+1,n-i+1,n-i+3,\\dots n-i-1,n-i \\end{pmatrix} $$\n考虑在环上跳的模型，设起点为 $S$，终点为 $T$，一次跳 $i$ 格，跳了 $x$ 次，则可以列出它们的关系：\n$$ S + ix \\equiv T \\pmod{n} $$\n根据线性同余方程的知识，可以得出方程有解，满足：\n$$ ix+ny=\\gcd(i,n),\\ \\gcd(i,n) \\mid (T-S) $$\n也就是，$T$ 与 $S$ 之间的距离是 $\\gcd(i,n)$ 的倍数，若 $S$ 固定，则有 $\\frac{n}{gcd(i,n)}$ 个对应的 $T$ 构成了循环，共有 $\\frac{n}{\\frac{n}{\\gcd(i,n)}}=\\gcd(i,n)$ 个循环，即 $\\tau(f_i)=\\gcd(i,n)$。\n使用 Pólya 定理，带入公式，最终答案为：\n$$ \\begin{aligned} \\frac{1}{n}\\sum_{i=1}^{n} n^{\\gcd(i,n)} \u0026amp; = \\frac{1}{n} \\sum_{d\\mid n}n^d \\sum_{i=1}^{n} [\\gcd(i,n)=d]\\\\ \u0026amp;= \\sum_{d\\mid n} n^{d-1} \\sum_{i=1}^{\\frac{n}{d}} [\\gcd(i,\\frac{n}{d})=1]\\\\ \u0026amp;= \\sum_{d\\mid n} n^{d-1} \\varphi(\\frac{n}{d}) \\end{aligned} $$\n单次询问时间复杂度 $\\Theta(d(n)(\\log_2 n+\\sqrt{n}))$。\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MOD = 1e9 + 7; int t, n; int phi(int x) { int res = x; for (int i = 2; i * i \u0026lt;= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } int power(int x, int y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % MOD; x = 1ll * x * x % MOD; } return res; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n; int ans = 0; for (int i = 1; i * i \u0026lt;= n; ++i) { if (n % i) continue; if (i * i == n) { ans = (ans + 1ll * power(n, i - 1) * phi(n / i)) % MOD; } else { ans = (ans + 1ll * power(n, i - 1) * phi(n / i)) % MOD; ans = (ans + 1ll * power(n, n / i - 1) * phi(i)) % MOD; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; }  Luogu P2561 黑白瓷砖  给出一个边长为 $n$ 的等边三角形，三角形是有 $\\frac{n(n+1)}{2}$ 个六边形组成的，对每个六边形黑白染色，若某一方案通过旋转、对称或旋转和对称同时进行可以得到另一个方案，则它们本质相同。求本质不同的方案数。\n$1\\le n\\le 20$。\n 根据图观察得出有 $6$ 种置换方案，分别为：\n 不做任何操作，$\\tau(f_1)=\\frac{n(n+1)}{2}$ 顺时针旋转 $\\frac{2\\pi}{3}$，$\\tau(f_2) = \\lceil \\frac{n(n+1)}{6} \\rceil$，三条边上关于中心旋转等角度旋转得到的三个点 顺时针旋转 $\\frac{4\\pi}{3}$，$\\tau(f_3) = \\lceil \\frac{n(n+1)}{6} \\rceil$，同上 对称，$\\tau(f_4) = \\sum_{i=1}^{n} \\lceil \\frac{i}{2} \\rceil$，每行的左右两边对称的一对为一个循环置换 先顺时针旋转 $\\frac{2\\pi}{3}$ 再对称，等价于换一条边做对称，同上 先顺时针旋转 $\\frac{4\\pi}{3}$ 再对称，等价于再换一条边做对称，同上  同时进行的情况不管是先旋转还是先对称，都是一样的，多次旋转或多次对称的情况等价于以上 $6$ 种中的某些情况。\n需要高精度计算，给出 Python 3 代码：\nfrom math import ceil n = int(input()) ex = int(ceil(n * (n + 1) / 6)) ans = 2 ** (n * (n + 1) // 2) ans += 2 ** (ex + 1) # 2, 3 ex = 0 for i in range(1, n + 1): ex += int(ceil(i / 2)) ans += 3 * (2 ** ex) # 4, 5, 6 ans //= 6 print(ans)  Luogu P1446 Cards  给出 $n$ 张牌，给每张牌染上红、绿、蓝三种颜色，要求这三种牌恰好有 $Sr,Sg,Sb$ 张，以及给出 $m$ 种洗牌方法，每种洗牌方法用一个排列 $X$ 表示，第 $i$ 张牌变为原来的第 $X_i$ 张牌。求本质不同的染色方案数。\n$1\\le n,m \\le 60$，$m+1\u0026lt;p\u0026lt;100$，$Sr,Sg,Sb\\le 20$，$n = Sr + Sg + Sb$。\n 由于对染色加上了限制，Polya 定理不能用了，考虑 Burnside 引理，并通过 DP 求出每组置换的不动点个数。显然每组置换为题目中的每种洗牌方式，另外要加上恒等置换。\n对于一种置换，求出其循环置换个数 $e$，及循环置换的作用的集合的元素个数 $c[i]$。显然为了满足不动点的要求，每个循环置换内的颜色应该相同。\n设 $f[i][r][g][b]$ 为选到了第 $i$ 个循环置换且三种颜色分别用了 $r,g,b$ 个的方案数，有如下状态转移方程：\n$$ f[0][0][0][0] = 1\\\\ f[i][r][g][b]\\longleftarrow f[i-1][r-c[i]][g][b]\\ (r\\ge c[i])\\\\ f[i][r][g][b]\\longleftarrow f[i-1][r][g-c[i]][b]\\ (g\\ge c[i])\\\\ f[i][r][g][b]\\longleftarrow f[i-1][r]][g][b-c[i]]\\ (b\\ge c[i]) $$\n则不动点个数为 $f[e][Sr][Sg][Sb]$。最终答案为：\n$$ \\frac{1}{m} \\sum_{x\\in \\mathrm{perm}} f[e[x]][Sr][Sg][Sb] $$\n时间复杂度 $\\Theta(nmSrSgSb)$。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; constexpr int MAX_M = 60 + 5; constexpr int MAX_S = 20 + 5; int n, m, sr, sg, sb, p; vector\u0026lt;int\u0026gt; perm[MAX_M]; bool vis[MAX_M]; int f[2][MAX_S][MAX_S][MAX_S], ans; int power(int x, int y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % p; x = 1ll * x * x % p; } return res; } int dfs(int now, const vector\u0026lt;int\u0026gt; \u0026amp; perm) { if (vis[now]) return 0; vis[now] = true; return dfs(perm[now], perm) + 1; } vector\u0026lt;int\u0026gt; findLoop(const vector\u0026lt;int\u0026gt; \u0026amp; perm) { vector\u0026lt;int\u0026gt; res = { 0 }; for (int i = 1; i \u0026lt;= n; ++i) vis[i] = false; for (int i = 1; i \u0026lt;= n; ++i) if (!vis[i]) res.push_back(dfs(i, perm)); return res; } int dp(const vector\u0026lt;int\u0026gt; \u0026amp; loop) { int e = loop.size() - 1; int res = 0; for (int r = 0; r \u0026lt;= sr; ++r) for (int g = 0; g \u0026lt;= sg; ++g) for (int b = 0; b \u0026lt;= sb; ++b) f[0][r][g][b] = 0; f[0][0][0][0] = 1; for (int i = 1; i \u0026lt;= e; ++i) { int now = (i \u0026amp; 1), pre = (now ^ 1); for (int r = 0; r \u0026lt;= sr; ++r) { for (int g = 0; g \u0026lt;= sg; ++g) { for (int b = 0; b \u0026lt;= sb; ++b) { int \u0026amp; val = f[now][r][g][b] = 0; if (r - loop[i] \u0026gt;= 0) val = (val + f[pre][r - loop[i]][g][b]) % p; if (g - loop[i] \u0026gt;= 0) val = (val + f[pre][r][g - loop[i]][b]) % p; if (b - loop[i] \u0026gt;= 0) val = (val + f[pre][r][g][b - loop[i]]) % p; if (i == e) res = (res + val) % p; } } } } return res; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; sr \u0026gt;\u0026gt; sg \u0026gt;\u0026gt; sb \u0026gt;\u0026gt; m \u0026gt;\u0026gt; p; n = sr + sg + sb; for (int i = 1; i \u0026lt;= m; ++i) { perm[i].push_back(0); for (int j = 1; j \u0026lt;= n; ++j) { int x; cin \u0026gt;\u0026gt; x; perm[i].push_back(x); } } // 判断是否已经存在循环置换 bool found = false; for (int i = 1; i \u0026lt;= m; ++i) { bool found2 = true; for (int j = 1; j \u0026lt;= n; ++j) { if (perm[i][j] != j) { found2 = false; break; } } if (found2) { found = true; break; } } if (!found) { ++m; for (int i = 0; i \u0026lt;= n; ++i) perm[m].push_back(i); } for (int i = 1; i \u0026lt;= m; ++i) ans = (ans + dp(findLoop(perm[i]))) % p; ans = 1ll * ans * power(m, p - 2) % p; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  BZOJ 1547 周末晚会  安排 $n$ 个人围绕着圆桌坐着，其中一些是男孩，另一些是女孩。你的任务是找出所有合法的方案数并对 $10^8+7$ 取模，使得不超过 $k$ 个女孩座位是连续的。循环同构会被认为是同一种方案。\n$T$ 组数据， $1\\le T\\le 50$，$1\\le n,k\\le 2000$。\n 一个已死 OJ 上的题目。\n设男孩为 B，女孩为 G，一共 $n$ 种置换，$f_i$ 表示顺时针 $i$ 格。可以用 DP 计算不动点个数。\n对于 $f_i$，如果没有 $k$ 的限制，在环上标记出每个点属于哪个循环置换，可以发现循环置换的种类是交错分布的，并以 $\\gcd(i,n)$ 为周期，所以我们对 $[1, \\gcd(i,n)]$ 怎么染色，$[\\gcd(i,n)+1,2\\gcd(i,n)]\\dots [n-\\gcd(i,n)+1, n]$ 也是怎么染色。问题转化为求对 $[1,\\gcd(i,n)]$ 染色且将这个区间头尾相接后仍然合法的方案数。\n环上的问题考虑断环为链，先枚举开头的 G 的个数，再计算后续的方案数，最后再加起来。设 $f[t][i][0/1]$ 为不考虑头尾相接情况下，强制开头有 $t$ 个 G，第 $i$ 位为 B 或 G 的方案数，$g[i]$ 为将 $[1,i]$ 头尾相接可以得到的合法方案数：\n$$ f[t][t][1]=1\\\\ f[t][i][0]=f[t][i-1][0]+f[t][i-1][1]\\\\ f[t][i][1]=\\sum_{j=i-k}^{i-1} f[t][j][0]\\\\ g[i]=\\sum_{t=0}^{k}(f[t][i][0]+\\sum_{j=i-(k-t)}^{i-1} f[t][j][0]) $$\n$f[t][i][1]$ 可以前缀和优化，转移都是 $O(1)$ 的。因为 $g[i]$ 要考虑头尾相接，所以末尾与开头的 G 的个数不能超过 $k$。可以发现对于每一组数据，我们只要预处理一遍 $g$ 就可以进行计算了，最终答案为：\n$$ \\begin{aligned} \\frac{1}{n} \\sum_{i=1}^{n}g[\\gcd(i,n)] \u0026amp; = \\frac{1}{n} \\sum_{d\\mid n}g[d]\\sum_{i=1}^{n}[\\gcd(i,n)=d]\\\\ \u0026amp; = \\frac{1}{n} \\sum_{d\\mid n}g[d] \\varphi(\\frac{n}{d}) \\end{aligned} $$\n单组数据的时间复杂度为 $\\Theta(nk+d(n)\\sqrt{n})$。\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAX_N = 2000 + 10; constexpr int MAX_K = 2000 + 10; constexpr int MOD = 1e8 + 7; int t, n, k; int f[MAX_N][2], sum[MAX_N], g[MAX_N]; int power(int x, int y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % MOD; x = 1ll * x * x % MOD; } return res; } int phi(int x) { int res = x; for (int i = 2; i * i \u0026lt;= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } void dp() { for (int i = 1; i \u0026lt;= n; ++i) g[i] = 0; for (int t = 0; t \u0026lt;= k; ++t) { for (int i = 0; i \u0026lt;= n; ++i) { f[i][0] = f[i][1] = 0; sum[i] = 0; } f[t][1] = 1; if (k \u0026gt;= n) g[t] = (g[t] + f[t][1]) % MOD; for (int i = t + 1; i \u0026lt;= n; ++i) { f[i][0] = (f[i - 1][0] + f[i - 1][1]) % MOD; f[i][1] = (sum[i - 1] - sum[max(i - k - 1, 0)] + MOD) % MOD; sum[i] = (sum[i - 1] + f[i][0]) % MOD; g[i] = ((g[i] + f[i][0]) % MOD + (sum[i - 1] - sum[max(i - (k - t) - 1, 0)] + MOD)) % MOD; } } } int solve() { int ans = 0; dp(); for (int i = 1; i * i \u0026lt;= n; ++i) { if (n % i) continue; if (i * i == n) { ans = (ans + 1ll * g[i] * phi(n / i)) % MOD; } else { ans = (ans + 1ll * g[i] * phi(n / i)) % MOD; ans = (ans + 1ll * g[n / i] * phi(i)) % MOD; } } ans = 1ll * ans * power(n, MOD - 2) % MOD; return ans; } int main() { cin \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= t; ++i) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; cout \u0026lt;\u0026lt; solve() \u0026lt;\u0026lt; endl; } return 0; }  POJ 2888 Magic Bracelet  有一个 $n$ 颗魔法珠子组成的魔法手镯。有 $m$ 种不同的魔法珠。每一种珠子都是无限的。将许多珠子串在一起，就可以制成一个美丽的圆形魔法手镯。某些种类的珠子会相互作用并爆炸，你必须非常小心以确保这些珠子不会串在一起。\n如果忽略围绕手镯中心旋转产生的重复，你可以制作多少个不同的手镯？答案对 $9973$ 取模。\n$1\\le n\\le 10^9$，$\\gcd(n, 9973)=1$，$1\\le m\\le 10$，$1\\le k\\le \\frac{m(m-1)}{2}$。\n 与上一题的分析思路类似，不同的是对于每个置换 $f_i$，需要求 $[1,\\gcd(i,n)]$ 头尾相接且满足制约条件的方案数。\n枚举开头的珠子，设 $f[t][i][j]$ 为强制 $t$ 开头，到第 $i$ 位时选择第 $j$ 种珠子，$valid[i][j]$ 表示 $i,j$ 两种珠子相邻是否合法，$g[i]$ 为将 $[1,i]$ 头尾相连的合法方案数。\n$$ f[t][1][i]=[t=i]\\\\ f[t][i][j]=\\sum_{valid(j,k)}f[t][i-1][k]\\\\ g[i]=\\sum_{valid(t,j)} f[t][i][j] $$\n实际转移是可以去掉 $t$ 这一维。$n$ 特别大，去掉 $t$ 后发现是一个矩阵乘法的形式，于是构造初始矩阵 $F_t$ 和转移矩阵 $T$：\n$$ F_t= \\begin{bmatrix} f[t][1][1] \u0026amp; f[t][1][2] \u0026amp; \\cdots \u0026amp; f[t][1][m] \\end{bmatrix} $$ $$ T= \\begin{bmatrix} valid[1][1] \u0026amp; valid[2][1] \u0026amp; \\cdots \u0026amp; valid[m][1]\\\\ valid[1][2] \u0026amp; valid[2][2] \u0026amp; \\cdots \u0026amp; valid[m][2]\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots\\\\ valid[1][m] \u0026amp; valid[2][m] \u0026amp; \\cdots \u0026amp; valid[m][m] \\end{bmatrix} $$\n求 $g[x]$，则用矩阵快速幂算出 $F_t\\times T^{x-1}$ 优化 DP，时间复杂度为 $\\Theta(m^3\\log_2x)$。\n最终答案为\n$$ \\begin{aligned} \\frac{1}{n} \\sum_{i=1}^{n}g[\\gcd(i,n)] \u0026amp; = \\frac{1}{n} \\sum_{d\\mid n}g[d]\\sum_{i=1}^{n}[\\gcd(i,n)=d]\\\\ \u0026amp; = \\frac{1}{n} \\sum_{d\\mid n}g[d] \\varphi(\\frac{n}{d}) \\end{aligned} $$\n单组数据时间复杂度为 $\\Theta(d(n)(m^3\\log_2x+\\sqrt{n}))$。\n值得一提的是，POJ 的评测环境已经很久没有升级过了，评测速度巨慢，而且现在还在使用 C++ 98，官方给出的解释是：\n Currently there is no plan to enable the experimental C++0x features before the new C++ standard is officially published and relatively well-supported.\n 所以接下来的代码在 POJ 无法通过，但已经在学校的自建 OJ 通过了，CPU 为 Intel(R) Core(TM) i5-8265U，每个测试点平均时间不超过 $80\\ \\text{ms}$，所以其实是很优秀的。根据实际情况，POJ 的评测记录已不具有参考性，所以就直接给出无法通过的代码。\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAX_M = 10 + 1; constexpr int MOD = 9973; class Matrix { public: Matrix(int row = 0, int column = 0) { this-\u0026gt;row = row; this-\u0026gt;column = column; for (int i = 1; i \u0026lt;= row; ++i) for (int j = 1; j \u0026lt;= column; ++j) data[i][j] = 0; } void unit() { for (int i = 1; i \u0026lt;= row; ++i) for (int j = 1; j \u0026lt;= column; ++j) data[i][j] = (i == j); } int * operator[](int x) { return data[x]; } const int * operator[](int x) const { return data[x]; } Matrix operator*(const Matrix \u0026amp; rhs) const { Matrix res(row, rhs.column); for (int i = 1; i \u0026lt;= row; ++i) for (int j = 1; j \u0026lt;= rhs.column; ++j) for (int k = 1; k \u0026lt;= column; ++k) res[i][j] = (res[i][j] + data[i][k] * rhs[k][j]) % MOD; return res; } Matrix operator^(int exp) const { Matrix res(row, row), base(*this); res.unit(); for (; exp; exp /= 2) { if (exp % 2) res = res * base; base = base * base; } return res; } private: int row, column; int data[MAX_M][MAX_M]; }; int t, n, m, k; bool valid[MAX_M][MAX_M]; int power(int x, int y) { x %= MOD; int res = 1; for (; y; y /= 2) { if (y % 2) res = res * x % MOD; x = x * x % MOD; } return res; } int phi(int x) { int res = x; for (int i = 2; i * i \u0026lt;= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } int dp(int t, int k) { Matrix f(1, m), trans(m, m); int res = 0; f[1][t] = 1; for (int i = 1; i \u0026lt;= m; ++i) for (int j = 1; j \u0026lt;= m; ++j) trans[j][i] = valid[i][j]; f = f * (trans ^ (k - 1)); for (int i = 1; i \u0026lt;= m; ++i) if (valid[t][i]) res += f[1][i]; return res % MOD; } int calc(int k) { int res = 0; for (int i = 1; i \u0026lt;= m; ++i) res += dp(i, k); return res % MOD; } int solve() { int ans = 0; for (int i = 1; i * i \u0026lt;= n; ++i) { if (n % i) continue; if (i * i == n) { ans = (ans + 1ll * calc(i) * phi(n / i)) % MOD; } else { ans = (ans + 1ll * calc(i) * phi(n / i)) % MOD; ans = (ans + 1ll * calc(n / i) * phi(i)) % MOD; } } return ans * power(n, MOD - 2) % MOD; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= m; ++i) for (int j = 1; j \u0026lt;= m; ++j) valid[i][j] = true; for (int i = 1; i \u0026lt;= k; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; valid[x][y] = valid[y][x] = false; } cout \u0026lt;\u0026lt; solve() \u0026lt;\u0026lt; endl; } return 0; }  ","id":6,"section":"posts","summary":"Burnside 引理和 Pólya 定理主要用于解决计算本质不同方案数的计数问题。 群论 基本定义 群可以看成是一个由集合和某个二元运算组成的二元组 $(S,\\cdo","tags":["OI","数学","群论","置换群","Burnside 引理","Pólya 定理","C++"],"title":"Burnside 引理 \u0026 Pólya 定理学习笔记","uri":"https://ctj12461.vercel.app/contents/20220212-burnside-lemma-and-polya-theorem-note/","year":"2022"},{"content":"欧拉函数 $\\varphi(n)$ 是一个重要的数论函数，它表示 $[1, n]$ 中与 $n$ 互质的数的个数。\n欧拉函数性质 积性函数 积性函数的定义是：如果一个函数 $f(n)$ 满足 $\\gcd(a,b)=1$ 时 $f(ab)=f(a)f(b)$，则 $f(n)$ 为积性函数。 若无需 $\\gcd(a,b)=1$ 就有 $f(ab)=f(a)f(b)$，则它为完全积性函数。\n$$ n = \\prod p_i^{c_i}\\\\ f(n) = \\prod f(p_i^{c_i}) $$\n一般来说，各种积性函数都是可以使用欧拉筛计算出来的，尽管方法各不相同。\n$\\varphi(n)$ 也是积性函数，证明就省略了。\n计算公式 因为 $\\varphi(n)$ 是积性函数，所以我们可以先研究 $\\varphi(p^k)$ 怎么计算。$p^k$ 的约数有 $1, p, p^2, \\dots, p^k$，而 $p^2, \\dots, p^k$ 都含有 $p$ 这个约数，如果一个数不与 $p^k$ 互质，则一点有 $p$ 这个约数，我们只有知道小于等于 $p^k$ 的数中 $p$ 的倍数有多少即可。由此得出 $\\varphi(n) = p^k - \\frac{p^k}{p} = p^k - p^{k-1}=p^k\\frac{p-1}{p}$。\n根据 $\\varphi(n)$ 的积性函数性质，得出对于任意的 $n$：\n$$ \\begin{aligned} \\varphi(n) \u0026amp; = \\prod p_i^{c_i} \\frac{p_i - 1}{p_i} \\\\ \u0026amp; = n \\prod \\frac{p_i-1}{p_i} \\\\ \u0026amp; = n \\prod (1 - \\frac{1}{p_i}) \\end{aligned} $$\n求和式 Formula 1 $$ n = \\sum_{d \\mid n} \\varphi(d) $$\n考虑设函数 $f(x, n)=\\sum_{i=1}^{n}[\\gcd(i,n)=x]$，则：\n$$ n=\\sum_{d \\mid n} f(d,n) $$\n又因为若 $\\gcd(i,n)=x$，则 $\\gcd(\\frac{i}{x},{\\frac{n}{x}})=1$，所以 $f(x,n)=\\varphi(\\frac{n}{x})$。带回原式：\n$$ n=\\sum_{d \\mid n}\\varphi(\\frac{n}{d}) $$\n因为 $d$ 与 $\\frac{n}{d}$ 是一起出现的，所以上式等价于原式。\nFormula 2 $$ \\sum_{i=1}^{n} \\sum_{j=1}^{n} [\\gcd(i,j)=1]=\\sum_{i=1}^{n}2\\varphi(i)-1 $$\n若我们仅考虑 $j\\le i$，则可以固定每个 $i$ 考虑，对于每个 $i$，与其互质的 $j$ 有 $\\varphi(i)$ 个，全部的和显然为 $\\sum_{i=1}^{n} \\varphi(i)$。对于 $j \\ge i$ 的情况，可以发现 $j,i$ 相当于前一种情况的 $i,j$，变换求和顺序后其实是等价的，即：\n$$ \\sum_{i=1}^{n} \\sum_{j=i}^{n} [\\gcd(i,j)=1]=\\sum_{j=1}^{n} \\sum_{i=1}^{j} [\\gcd(i,j)=1] $$\n左右能够枚举到的 $(i,j)$ 是一样的，又因为只有 $1$ 与本身互质，则原式等价于两种情况相加再扣除一个 $1$ 的重复。\nFormula 3 $$ \\sum_{i=1}^{n}i[\\gcd(i,n)=1]=\\frac{n\\varphi(n)}{2} $$\n根据更相减损术 $\\gcd(a,b)=\\gcd(b,a-b)$，可以知道若 $\\gcd(i,n)=1$，则 $\\gcd(n-i,n)=1$，也就是与 $n$ 互质的数是成对出现的，且每一对的和都为 $n$，考虑头尾相加，仿照等差数列的求和公式：\n$$ \\begin{aligned} \u0026amp; \\sum_{i=1}^{n}i[\\gcd(i,n)=1] + \\sum_{i=1}^{n}(n-i)[\\gcd(n-i,n)=1]\\\\ = \u0026amp;\\sum_{i=1}^{n} n[\\gcd(i,n)=1]\\\\ = \u0026amp;n\\varphi(n) \\end{aligned}\\\\ $$\n所以两边除以 $2$ 得出：\n$$ \\sum_{i=1}^{n}i[\\gcd(i,n)=1]=\\frac{n\\varphi(n)}{2} $$\n筛法 使用欧拉筛时随便求出即可。假设循环到 $i$：\n 若 $i$ 为质数，则 $\\varphi(i)=i-1$ 若 $p_j \\nmid i$，则 $\\gcd(p_j,i)=1$，根据积性函数性质，$\\varphi(ip_j)=\\varphi(i)\\varphi(p_j)=(p_j-1)\\varphi(i)$ 若 $p_j \\mid i$，则 $\\gcd(p_j,i)\\ne 1$，$i$ 中已有 $p_j$ 这个约数，根据计算公式，只要乘一次$\\frac{p_j-1}{p_j}$，则 $\\varphi(ip_j)=p_j\\varphi(i)$  代码实现 单次求解 int phi(int x) { int res = x; for (int i = 2; i * i \u0026lt;= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; }  欧拉筛 void sieve(int n) { notPrime[1] = true; for (int i = 2; i \u0026lt;= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; phi[i] = i - 1; } for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * prime[j] \u0026lt;= n; ++j) { notPrime[i * prime[j]] = true; if (i % prime[j]) { phi[i * prime[j]] = phi[i] * (prime[j] - 1); } else { phi[i * prime[j]] = phi[i] * prime[j]; break; } } } }  欧拉定理 定理内容 普通 $$ a^{\\varphi(m)} \\equiv 1 \\pmod{m}\\ (\\gcd(a,m)=1) $$\n扩展 $$ a^b \\equiv \\begin{cases} a^{b \\bmod \\varphi(m)} \u0026amp; \\gcd(a,m)=1\\\\ a^{b} \u0026amp; \\gcd(a,m)\\ne 1 \\wedge b \u0026lt; \\varphi(m)\\\\ a^{b \\bmod \\varphi(m) + \\varphi(m)} \u0026amp; \\gcd(a,m)\\ne 1 \\wedge b \\ge \\varphi(m) \\end{cases} \\pmod{m} $$\n应用 逆元 $$ a^{\\varphi(m)}\\equiv a\\cdot a^{\\varphi(m)-1}\\equiv 1 \\pmod{m}\\ (\\gcd(a,m)=1) $$\n当 $\\gcd(a,m)=1$ 时，$a^{\\varphi(m)-1}$ 就是 $a$ 的逆元。费马小定理就是其特殊情况。\n降幂 有时幂的指数恒大，快速幂的时间复杂度也无法接受，这时可以使用扩展欧拉定理对指数进行取模减小，优化算法。\n幂次幂 有时题目要求类似 $a^{b_1^{b_2^{\\cdots}}}$ 的式子，一般直接处理指数与底数的关系是不可做的，这时就可以使用扩展欧拉定理，同时由于复合欧拉函数 $\\varphi(\\varphi(\\dots\\varphi(n)\\dots))$ 的值变为 $1$ 的次数是 $O(\\log_2 n)$ 的，所以也只需要用 $O(\\log_2 n)$ 扩展欧拉定理，某一层的指数就会变为 $0$，配合快速幂，总体的时间复杂度为 $O(\\log_2^2 n)$。\n例题 Luogu P2158 仪仗队  给出一个 $n \\times n$ 的点阵，从左下角观察，一个点能够被观察到当且仅当其与左下角的点的连线上没有其他的点，就能够被观察到的点的个数（左下角的点不算）。\n\n$1\\le n \\le 40000$。\n 容易看出左上部分和右下部分的答案相同，先考虑右下，对点阵建坐标系，左下角为 $(0,1)$，则半平面 $x-y \\ge 0$ 中的点 $(x, y)$ 若满足 $\\gcd(x,y)=1$，则可以被观察到。这部分答案为 $\\sum_{i=1}^{n-1}\\varphi(i)$，左上部分答案也是这个，图中还有一个位于 $(1,2)$ 的点未被算到，再加 $1$ 即可，总答案为：\n$$ \\sum_{x=1}^{n-1} 2\\varphi(x)+1 $$\n欧拉筛求出欧拉函数后直接加即可。\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAXN = 40000 + 10; int n, ans = 1; bool notPrime[MAXN]; int tot, prime[MAXN], phi[MAXN]; void sieve(int n) { notPrime[1] = true; for (int i = 2; i \u0026lt;= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; phi[i] = i - 1; } for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * prime[j] \u0026lt;= n; ++j) { notPrime[i * prime[j]] = true; if (i % prime[j]) { phi[i * prime[j]] = phi[i] * (prime[j] - 1); } else { phi[i * prime[j]] = phi[i] * prime[j]; break; } } } } int main() { cin \u0026gt;\u0026gt; n; if (n == 1) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } sieve(n - 1); for (int i = 1; i \u0026lt;= n - 1; ++i) ans += 2 * phi[i]; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  Luogu P2303 Longge 的问题  给定一个整数 $n$，你需要求出 $\\sum_{i=1}^{n} \\gcd(i,n)$。\n$1\\le n\u0026lt; 2^{32}$\n 推式子，考虑枚举 $d$ 作为 $\\gcd(i,n)$：\n$$ \\begin{aligned} \\sum_{i=1}^{n} \\gcd(i,n)\u0026amp;=\\sum_{d \\mid n}d\\sum_{i=1}^{n}[\\gcd(i,n)=d]\\\\ \u0026amp;=\\sum_{d \\mid n}d\\sum_{i=1}^{n}[\\gcd(\\frac{i}{d},\\frac{n}{d})=1]\\\\ \u0026amp;=\\sum_{d \\mid n}d\\sum_{i=1}^{\\frac{n}{d}}[\\gcd(i,\\frac{n}{d})=1]\\\\ \u0026amp;=\\sum_{d \\mid n}d\\varphi(\\frac{n}{d}) \\end{aligned} $$\n枚举约数 $d$，再计算 $\\varphi$ 即可，时间复杂度 $O(d(n)\\varphi(n))$，$d(n)$ 表示 $n$ 的约数个数，实际上跑得很快。\n#include \u0026lt;iostream\u0026gt; using namespace std; long long n, ans; long long phi(long long x) { long long res = x; for (long long i = 2; i * i \u0026lt;= n; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } int main() { long long i; for (i = 1; i * i \u0026lt; n; ++i) if (n % i == 0) ans += i * phi(n / i) + (n / i) * phi(i); if (i * i == n) ans += i * phi(i); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  Luogu P2350 外星人  设 $\\varphi^x(n)$ 为对 $n$ 求 $x$ 次欧拉函数，即： $$ \\varphi^x(n)= \\begin{cases} \\varphi(n) \u0026amp; x=1\\\\ \\varphi^{x-1}(\\varphi(n)) \u0026amp; x\u0026gt;1 \\end{cases} $$ 现在给出 $n$ 的唯一分解 $\\prod_{i=1}^{m}p_i^{q_i}$，求出一个最小的 $x$ 使得 $\\varphi^x(n)=1$。\n$test$ 组数据，$1\\le test\\le 50$，$1\\le p_i\\le 10^5$，$1\\le q_i\\le 10^9$，$1\\le m\\le 2000$。\n 首先可以找一些规律，对于 $2^k$ 这一类数，显然最小的 $x=k$，因为每套一层欧拉函数就会使 $k$ 减小 $1$。\n对于其他不等于 $2$ 的质数 $p$，$\\varphi(p)=p-1=2^{k\u0026rsquo;}\\prod p_i\u0026rsquo;^{c_i\u0026rsquo;}$，$\\varphi^2(p)=2^{k\u0026rsquo;+k\u0026rsquo;-1}\\prod p_i\u0026rsquo;\u0026rsquo;^{c_i\u0026rsquo;\u0026rsquo;}$，$\\varphi^3(p)=2^{k\u0026rsquo;+k\u0026rsquo;\u0026rsquo;+k\u0026rsquo;\u0026rsquo;\u0026rsquo;-2}\\prod p_i\u0026rsquo;\u0026rsquo;\u0026rsquo;^{c_i\u0026rsquo;\u0026rsquo;\u0026rsquo;}$，依此类推，发现几个性质：\n 每个互质的 $p_i^{c_i}$ 同时减小 $c_i$，根据欧拉函数的公式可以得出 每次每个 $p_i^{c_i}\\ (p_i\\ne 2)$ 都会使前面的某些 $p_j^{c_j}$ 的 $c_j$ 增加，且 $p_j\u0026lt;p_i$，且一定有一个 $p_j=2$。 对于 $2^k$，不考虑后面的 $p_i^{c_i}$，每次 $k$ 会被减小 $1$ 最后一个被消去的质因数一定是 $2$  前 $3$ 个都很好理解，最后一个使用反证法，假设存在一个质因数 $p$ 大于 $2$，且经过 $t$ 次操作后，$2$ 的次数变为 $0$，而 $p$ 的次数大于 $0$，这种情况下若要满足最后一个被消去的质因数不是 $2$，则 $\\varphi^{t+1}(p)$ 不能有 $2$ 的约数，与性质 $2$ 矛盾，故假设不成立。\n所以，总共的消除次数就是 $2$ 的次数，这启发我们计算每个质因数 $p_i$ 最后能够产生多少个 $2$。设 $f[i]$ 表示 $i$ 能够产生的 $2$ 的个数，则：\n$$ f[2]=1\\\\ f[p]=f[p-1]\\\\ f[p^k]=kf[p]\\\\ f[ap]=f[a]+f[p]\\\\ $$\n其中 $p$ 为质数，这个 DP 在欧拉筛时求出即可。最后答案为：\n$$ \\sum_{i=1}^{m}qf[p]+[2\\notin\\{p_1,p_2,\\dots,p_m\\}] $$\n注意特判最开始的 $n$ 没有 $2$ 的约数的情况，这个时候要先求一次欧拉函数来获得 $2$ 的约数。\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAXP = 1e5 + 10; int t, m; int f[MAXP], prime[MAXP], tot; bool notprime[MAXP]; void preprocess(int n) { notprime[0] = notprime[1] = true; f[1] = 1; // 虽然 1 不能产生 2，但是为了方便可以这么写 for (int i = 2; i \u0026lt;= n; ++i) { if (!notprime[i]) { prime[++tot] = i; f[i] = f[i - 1]; } for (int j = 1; j \u0026lt;= tot; ++j) { if (i * prime[j] \u0026gt; n) break; notprime[i * prime[j]] = true; f[i * prime[j]] = f[i] + f[prime[j]]; if (i % prime[j] == 0) break; } } } void solve() { m = read(); bool found = false; long long ans = 0; for (int i = 1; i \u0026lt;= m; ++i) { int p, q; cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q; found |= (p == 2); ans += 1ll * f[p] * q; } ans += !found; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(false); preprocess(MAXP - 10); cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; }  Luogu P4139 上帝与集合的正确用法  给出 $p$，求以下式子： $$ 2^{2^{2^{\\cdots}}} \\bmod p $$ 可以看作 $\\infty$ 个 $2$，尽管这种式子不是很严谨。\n$T$ 组数据，$1\\le T \\le 10^3$，$1\\le p\\le 10^7$。\n 使用扩展欧拉定理，原式可以写成：\n$$ 2^{2^{2^{\\cdots}}} \\bmod p= \\begin{cases} 2^{2^{2^{\\cdots}} \\bmod \\varphi(p)} \\bmod p \u0026amp; \\gcd(2,p)=1\\\\ 2^{2^{2^{\\cdots}} \\bmod \\varphi(p) + \\varphi(p)} \\bmod p \u0026amp; \\gcd(2,p)\\ne 1 \\end{cases} $$\n这里把 $2^{2^{2^{\\cdots}}}$ 视为 $\\infty$，所以不存在 $2^{2^{2^{\\cdots}}}\u0026lt;\\varphi(p)$ 的情况。设 $f(p) = 2^{2^{2^{\\cdots}}} \\bmod p$，就可以把上面的式子写成这样：\n$$ f(p)= \\begin{cases} 2^{f(\\varphi(p))} \\bmod p \u0026amp; \\gcd(2,p)=1\\\\ 2^{f(\\varphi(p)) + \\varphi(p)} \\bmod p \u0026amp; \\gcd(2,p)\\ne 1 \\end{cases} $$\n当 $p=1$ 时，$f(p)=0$。先筛出 $\\varphi(p)$，再用递归实现 $f(p)$，$f(p)$ 只会递归 $(\\log_2 p)$ 层，可以再加上记忆化搜索。时间复杂度 $O(p+T\\log_2^2 p)$。\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAXP = 1e7 + 10; int t, p; int buc[MAXP]; int prime[MAXP], phi[MAXP], tot; bool notPrime[MAXP]; int gcd(int x, int y) { int t; while (y) { t = x; x = y; y = t % y; } return x; } int power(int x, int y, int p) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % p; x = 1ll * x * x % p; } return res; } void preprocess(int n) { notPrime[1] = true; for (int i = 2; i \u0026lt;= n; ++i) { if (!notPrime[i]) { prime[++tot] = i; phi[i] = i - 1; } for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * prime[j] \u0026lt;= n; ++j) { notPrime[i * prime[j]] = true; if (i % prime[j]) { phi[i * prime[j]] = phi[i] * (prime[j] - 1); } else { phi[i * prime[j]] = phi[i] * prime[j]; break; } } } } int calc(int p) { if (buc[p] != -1) return buc[p]; int res; if (gcd(2, p) == 1) res = power(2, calc(phi[p]), p); else res = power(2, calc(phi[p]) + phi[p], p); buc[p] = res; return res; } int main() { ios::sync_with_stdio(false); preprocess(MAXP - 1); for (int i = 0; i \u0026lt; MAXP; ++i) buc[i] = -1; buc[1] = buc[2] = 0; cin \u0026gt;\u0026gt; t; while (t--) { int x; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; calc(x) \u0026lt;\u0026lt; endl; } return 0; }  Luogu P3747 相逢是问候  维护一个长度为 $n$ 的数组，这个数组的下标为从 $1$ 到 $n$ 的正整数。\n一共有 $m$ 个操作，可以分为两种：\n 0 l r，对区间 $[l,r]$ 中的每一个数进行赋值：$a_i\\longleftarrow c^{a_i}$，$c$ 为一常数。 1 l r，查询区间 $[l,r]$ 中的 $a_i$ 之和对 $p$ 取模的值。  $1\\le n,m\\le 5\\times 10^4$，$1\\le p\\le 10^8$，$0\u0026lt;c\u0026lt;p$，$0\\le a_i \u0026lt; p$。\n 思路与上一题有异曲同工之处，每个数最多被赋值 $O(\\log_2 p)$ 次后就固定不变了，用线段树维护区间和以及区间的最小操作次数，每次修改只处理仍然需要计算的部分，总时间复杂度 $O(n\\log_2^3 p)$，常数小就可以过去了。\n考虑去掉一个 $O(\\log_2 p)$。由于 $\\varphi(p)$ 减小得很快，仅需要 $O(\\log_2 p)$ 次，意味着快速幂的模数也很少，考虑对每个模数 $M$ 预处理出 $p_1[i]=M^i$，$p_2[i]=M^{10000i}$，然后就可以 $O(1)$ 求幂了。时间复杂度 $O(n\\log_2^2 p)$。\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAXN = 5e4 + 10; constexpr int INFINITY = 0x3f3f3f3f; struct Node { int left, right; int cnt, sum; }; int n, m, p, c; int a[MAXN]; int seq[MAXN], g[MAXN], tot; Node tree[MAXN * 4]; int p1[10001], p2[10001], p3[32][10001], p4[32][10001]; int gcd(int x, int y) { int t; while (y) { t = x; x = y; y = t % y; } return x; } int powerImpl(int x, int y) { if (y == INFINITY) return INFINITY; int res = 1; for (; y; y /= 2) { if (y % 2) { if (x == INFINITY || 1ll * res * x \u0026gt;= p) return INFINITY; res = res * x; } if (x == INFINITY || 1ll * x * x \u0026gt;= p) x = INFINITY; else x = x * x; } return res; } int power(int y) { int y1 = y % 10000, y2 = y / 10000; if (p1[y1] == INFINITY || p2[y2] == INFINITY || 1ll * p1[y1] * p2[y2] \u0026gt;= p) return INFINITY; return p1[y1] * p2[y2]; } int power(int y, int id) { int y1 = y % 10000, y2 = y / 10000; return 1ll * p3[id][y1] * p4[id][y2] % seq[id]; } int powerImpl(int x, int y, int p) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % p; x = 1ll * x * x % p; } return res; } int phi(int x) { int res = x; for (int i = 2; i * i \u0026lt;= x; ++i) { if (x % i) continue; res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } void preprocess() { int x = p; while (seq[tot] != 1) { seq[++tot] = x; x = phi(x); } for (int i = 1; i \u0026lt;= tot; ++i) g[i] = gcd(seq[i], c); for (int i = 0; i \u0026lt;= 10000; ++i) { p1[i] = powerImpl(c, i); p2[i] = powerImpl(c, i * 10000); } for (int i = 1; i \u0026lt;= tot; ++i) { for (int j = 0; j \u0026lt;= 10000; ++j) { p3[i][j] = powerImpl(c, j, seq[i]); p4[i][j] = powerImpl(c, j * 10000, seq[i]); } } } // 核心部分，利用扩展欧拉定理求幂次幂 // 返回值一个是答案，一个是用于处理与 phi(p) 的大小关系 pair\u0026lt;int, int\u0026gt; calc(int dep, int lim, int a) { // phi 的值已经为 1 if (dep == tot) { int prod = a; for (int i = lim; i \u0026gt;= dep; --i) { prod = power(prod); // 用无穷大表示超过 p 的情况 if (prod == INFINITY) return { 0, INFINITY }; } return { 0, prod }; } // 已经到 a_i，无法继续递归 if (dep == lim + 1) return { a % seq[dep], a }; auto [res, prod] = calc(dep + 1, lim, a); // seq[i] 表示对 p 求 i 次欧拉函数的结果 // g[i] 表示 c 与 seq[i] 的 gcd if (g[dep] == 1) res = power(res, dep); else if (prod \u0026gt;= seq[dep + 1]) res = power(res + seq[dep + 1], dep); else res = power(prod, dep); prod = power(prod); return { res, prod }; } inline void pushup(int x) { tree[x].sum = (tree[x * 2].sum + tree[x * 2 + 1].sum) % p; tree[x].cnt = min(tree[x * 2].cnt, tree[x * 2 + 1].cnt); } void build(int x, int l, int r) { tree[x].left = l; tree[x].right = r; if (l == r) { tree[x].sum = a[l]; return; } int mid = (l + r) / 2; build(x * 2, l, mid); build(x * 2 + 1, mid + 1, r); pushup(x); } void modify(int x, int l, int r) { if (tree[x].cnt \u0026gt;= tot || tree[x].right \u0026lt; l || r \u0026lt; tree[x].left) return; if (tree[x].left == tree[x].right) { ++tree[x].cnt; tree[x].sum = calc(1, tree[x].cnt, a[tree[x].left]).first; return; } int mid = (tree[x].left + tree[x].right) / 2; if (l \u0026lt;= mid) modify(x * 2, l, r); if (mid \u0026lt; r) modify(x * 2 + 1, l, r); pushup(x); } int query(int x, int l, int r) { if (l \u0026lt;= tree[x].left \u0026amp;\u0026amp; tree[x].right \u0026lt;= r) return tree[x].sum; int mid = (tree[x].left + tree[x].right) / 2, res = 0; if (l \u0026lt;= mid) res = (res + query(x * 2, l, r)) % p; if (mid \u0026lt; r) res = (res + query(x * 2 + 1, l, r)) % p; return res; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; p \u0026gt;\u0026gt; c; preprocess(); for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; build(1, 1, n); for (int i = 1; i \u0026lt;= m; ++i) { int op, l, r; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; if (op == 0) modify(1, l, r); else cout \u0026lt;\u0026lt; query(1, l, r) \u0026lt;\u0026lt; endl; } return 0; }  ","id":7,"section":"posts","summary":"欧拉函数 $\\varphi(n)$ 是一个重要的数论函数，它表示 $[1, n]$ 中与 $n$ 互质的数的个数。 欧拉函数性质 积性函数 积性函数的定义是：如果一个函数 $f(n)$ 满足 $\\gcd(a,b)=1$ 时 $f(ab)=f","tags":["OI","数学","数论","欧拉函数","欧拉定理","C++"],"title":"欧拉函数 \u0026 欧拉定理学习笔记","uri":"https://ctj12461.vercel.app/contents/20220210-euler-function-and-euler-theorem-note/","year":"2022"},{"content":"拉格朗日插值是众多插值算法中的一种，插值是通过一些点来求出过这些点的多项式函数的过程。\n算法思想 构造函数 给出 $n + 1$ 个点 $(x_1,y_1),(x_2,y_2),\\dots,(x_n,y_n),(x_{n+1},y_{n+1})$，要求出过这些点的 $n$ 次多项式函数（也称该函数的度为 $n$），先考虑对每个点构造一个函数，第 $i$ 个点的函数为 $f_i(x)$，满足：\n$$ f_i(x) = \\begin{cases} y_i \u0026amp; x = x_i\\\\ 0 \u0026amp; x \\ne x_i \\end{cases} \\ (x\\in \\{x_1,x_2,\\dots,x_n,x_{n+1}\\}) $$\n最后将这些函数组合为最终的函数：\n$$ f(x) = \\sum_{i=1}^{n+1}f_i(x) $$\n接下来就是找到一种合适的形式来表示 $f_i(x)$ 的分段规定，可以让 $f_i(x)$ 含有一些因式，满足 $x=x_j,j\\ne i$ 时，其值为 $0$，$x=x_i$ 时，其值为 $y_i$。显然下面这种满足条件：\n$$ f_i(x) = y_i \\prod_{i\\ne j} \\frac{x-x_j}{x_i-x_j} $$\n所以最终的 $f(x)$ 的解析式为：\n$$ f(x) = \\sum_{i=1}^{n + 1} y_i \\prod_{i\\ne j} \\frac{x-x_j}{x_i-x_j} $$\n求单个函数值的时间复杂度是 $\\Theta(n^2)$。\n前后缀积优化 在一些题目中，插值所需的 $x$ 是连续的，当 $x\\in \\mathrm{N^*}$ 时，我们可以把公式写成这样：\n$$ f(x) = \\sum_{i=1}^{n + 1} y_i \\prod_{i\\ne j} \\frac{x-j}{i-j} = \\sum_{i=1}^{n + 1} y_i \\frac{pre[i - 1]suf[i+1]}{(i-1)!(n-i+1)!(-1)^{n-i+1}}\\\\ pre[i]=\\prod_{j=1}^{i} (k-j) = (k-i)pre[i-1]\\\\ suf[i]=\\prod_{j=i}^{n+1} (k-j)= (k-i)suf[i+1]\\\\ $$\n特殊地，$pre[0] = 1$，$suf[n+2] = 1$。\n这样单次插值的时间复杂度就是 $\\Theta(n)$。 当然，前后缀积优化还适用于 $x_i-x_{i-1}=d\\ (d\\ne 0,x\u0026gt;1)$ 的情况，即 $x_i$ 是一个公差不为 $0$ 的等差数列。\n重心拉格朗日插值 如果题面要求动态地加入插值点升高次数，上述方法不够优秀，从公式中可以发现，我们重复计算了许多东西，考虑把它们提取出来：\n$$ f(x) = \\sum_{i=1}^{n + 1} y_i \\prod_{i\\ne j} \\frac{x-x_j}{x_i-x_j} = \\sum_{i=1}^{n + 1} \\frac{y_i}{x-x_i} \\prod_{j=1}^{n+1}(x-x_j) \\prod_{i\\ne j}\\frac{1}{x_i-x_j} $$\n定义以下函数：\n$$ w(i)=\\prod_{i\\ne j}\\frac{1}{x_i-x_j}\\\\ c(x)=\\prod_{j=1}^{n+1}(x-x_j) $$\n其中 $w(i)$ 也被称为重心权。\n最终公式为：\n$$ f(x)=c(x) \\sum_{i=1}^{n + 1} w(i) \\frac{y_i}{x-x_i} $$\n显然只要 $\\Theta(1)$ 更新 $c(x)$，$\\Theta(nt)$ 求出 $w(n+2)$ 以及更新 $w(1\\dots n+1)$。最后 $\\Theta(nt)$ 求出新的 $f(x)$。$\\Theta(t)$ 为求逆元的复杂度，一般为 $\\Theta(\\log_2 M)$，$M$ 为模数。\n具体地，对于 $\\forall i\\in [1,n+1]$，$w(i)$ 都除以 $x_i-x_{n+2}$，而 $w(n+2)$ 只需扫一遍即可。\n代码实现 普通拉格朗日插值 int interpolation(int deg, int k, int x[], int y[]) { int res = 0; for (int i = 1; i \u0026lt;= deg + 1; ++i) { int num = y[i], den = 1; for (int j = 1; j \u0026lt;= deg + 1; ++j) { if (i == j) continue; num = 1ll * num * (k - x[j] + MOD) % MOD; den = 1ll * den * (x[i] - x[j] + MOD) % MOD; } res = (res + 1ll * num * power(den, MOD - 2)) % MOD; } return res; }  前后缀积优化 inline int sgnInv(int n) { static int inv[2] = {power(1, MOD - 2), power(MOD - 1, MOD - 2)}; return inv[n % 2]; } void preprocess(int deg) { fac[0] = 1; for (int i = 1; i \u0026lt;= deg + 1; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD; inv[deg + 1] = power(fac[deg + 1], MOD - 2); for (int i = deg; i \u0026gt;= 0; --i) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD; } int interpolation(int deg, int k, int y[]) { int res = 0; pre[0] = suf[deg + 2] = 1; for (int i = 1; i \u0026lt;= deg + 1; ++i) pre[i] = 1ll * pre[i - 1] * (k - i + MOD) % MOD; for (int i = deg + 1; i \u0026gt;= 1; --i) suf[i] = 1ll * suf[i + 1] * (k - i + MOD) % MOD; for (int i = 1; i \u0026lt;= deg + 1; ++i) { int num = 1ll * y[i] * pre[i - 1] % MOD * suf[i + 1] % MOD; int den = 1ll * inv[i - 1] * inv[deg - i + 1] % MOD * sgnInv(deg - i + 1) % MOD; res = (res + 1ll * num * den) % MOD; } return res; }  重心拉格朗日插值 int interpolationAdd(int nx, int ny) { ++deg; x[deg + 1] = nx; y[deg + 1] = ny; c = 1ll * c * (k - nx + MOD) % MOD; for (int i = 1; i \u0026lt;= deg; ++i) w[i] = 1ll * w[i] * power(x[i] - x[deg + 1] + MOD, MOD - 2) % MOD; for (int i = 1; i \u0026lt;= deg; ++i) w[deg + 1] = 1ll * w[deg + 1] * (x[deg + 1] - x[i] + MOD) % MOD; w[deg + 1] = power(w[deg + 1], MOD - 2); int res = 0; for (int i = 1; i \u0026lt;= deg + 1; ++i) res = 1ll * y[i] * w[i] % MOD * power(k - x[i]) % MOD; res = 1ll * res * c % MOD; return res; }  例题 Luogu P4593 教科书般的亵渎  给出一个单调递增的长度为 $n$ 的数列，每次操作可以使数列的值全部减少 $x$，满足 $x$ 恰好是操作开始前数列开头的值域连续段全部被减为小于等于 $0$，操作结束后，将该连续段删除，并获得 $1+2^k+\\cdots +x^k$ 的分数。题面给出数列中没有出现的数，共 $m$ 个。\n$1\\le n \\le 10^{13}$，$1\\le m \\le 10$。\n 把原题面转化为上述模型后，我们需要求 $f(x)=\\sum_{i=1}^{x}i^k$。\n这里给出一个结论：一个 $n$ 次函数的前缀和为 $n+1$ 次。\n所以考虑先求出 $\\forall i\\in [1,k+2]$ 的 $f(i)$，插值得到 $k+1$ 次的 $f(x)$。\n至于题目中的减操作，$\\Theta(m^2)$ 模拟每一段即可。若使用前后缀积优化，则时间复杂度为 $\\Theta(m^2k)$。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; using ll = long long; constexpr int maxm = 50 + 10; constexpr int mod = 1e9 + 7; int t, m; ll n, a[maxm]; int x[maxm], y[maxm]; int fac[maxm], inv[maxm], pre[maxm], suf[maxm]; int power(int x, int y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % mod; x = 1ll * x * x % mod; } return res; } inline int sgnInv(int n) { static int inv[2] = {power(1, mod - 2), power(mod - 1, mod - 2)}; return inv[n % 2]; } void preprocess() { fac[0] = 1; for (int i = 1; i \u0026lt;= maxm - 1; ++i) fac[i] = 1ll * fac[i - 1] * i % mod; inv[maxm - 1] = power(fac[maxm - 1], mod - 2); for (int i = maxm - 2; i \u0026gt;= 0; --i) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; } int interpolation(ll x0, int deg, int x[], int y[]) { int ans = 0; pre[0] = suf[deg + 2] = 1; for (int i = 1; i \u0026lt;= deg + 1; ++i) pre[i] = 1ll * pre[i - 1] * (x0 - i + mod) % mod; for (int i = deg + 1; i \u0026gt;= 1; --i) suf[i] = 1ll * suf[i + 1] * (x0 - i + mod) % mod; for (int i = 1; i \u0026lt;= deg + 1; ++i) { int num = 1ll * y[i] * pre[i - 1] % mod * suf[i + 1] % mod; int den = 1ll * inv[i - 1] * inv[deg - i + 1] % mod * sgnInv(deg - i + 1) % mod % mod; ans = (1ll * ans + 1ll * num * den % mod) % mod; } return (ans + mod) % mod; } int calc(ll x0) { if (x0 \u0026lt;= m + 3) return y[x0]; return interpolation(x0, m + 2, x, y); } int solve() { int ans = 0; for (int i = 1; i \u0026lt;= m + 3; ++i) { x[i] = i; y[i] = (y[i - 1] + power(i, m + 1)) % mod; } for (int i = 1; i \u0026lt;= m; ++i) { ans = (ans + calc(n)) % mod; for (int j = i; j \u0026lt;= m; ++j) ans = (ans - power(a[j], m + 1) + mod) % mod; for (int j = i + 1; j \u0026lt;= m; ++j) a[j] -= a[i]; n -= a[i]; } if (n != 0) ans = (ans + calc(n)) % mod; return ans; } int main() { ios::sync_with_stdio(false); preprocess(); cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) cin \u0026gt;\u0026gt; a[i]; sort(a + 1, a + 1 + m); cout \u0026lt;\u0026lt; solve() \u0026lt;\u0026lt; endl; } return 0; }  Luogu P3270 成绩比较  G 系共有 $N$ 位同学，$M$ 门必修课。这 $N$ 位同学的编号为 $0$ 到 $N-1$ 的整数，其中 B 神的编号为 $0$ 号。这 $M$ 门必修课编号为 $0$ 到 $M-1$ 的整数。一位同学在必修课上可以获得的分数是 $1$ 到 $U_i$ 中的一个整数。\n如果在每门课上 A 获得的成绩均小于等于 B 获得的成绩，则称 A 被 B 碾压。在 B 神的说法中，G 系共有 $K$ 位同学被他碾压（不包括他自己），而其他 $N-K-1$ 位同学则没有被他碾压。D 神查到了 B 神每门必修课的排名。\n这里的排名是指：如果 B 神某门课的排名为 $R$，则表示有且仅有 $R-1$ 位同学这门课的分数大于 B 神的分数，有且仅有 $N-R$ 位同学这门课的分数小于等于 B 神（不包括他自己）。\n请你求出所有可能的成绩种类数。\n$1\\le N\\le 100$，$1\\le M\\le 100$，$1\\le U_i\\le 10^9$，$1\\le R_i\\le N$。\n 考虑 DP。先只考虑成绩的相对关系，即先不管每个人的成绩具体是多少。设 $f[i][j]$ 表示前 $i$ 门课程 B 神能够碾压 $j$ 个人的方案数：\n$$ f[i][j]=\\sum_{k=j}^{N-1} f[i-1][k] \\binom{k}{j} \\binom{n-k-1}{r[i]-1-k+j}\\\\ f[0][N-1] = 1 $$\n这个式子意思是前 $i-1$ 门课中，B 神可以碾压 $k$ 人，但现在其中的 $k-j$ 人这门课成绩比 B 神高，无法被碾压，有 $\\binom{k}{j}$ 种方案，为了保证 B 神排名为 $r[i]$，除了刚才的 $k-j$ 人，还要有 $r[i]-1-k+j$ 人排在 B 神前面，这些人来自未被碾压的 $n-k-1$ 人中有 $\\binom{n-k-1}{r[i]-1-k+j}$ 种方案。\n由于每门课的排名固定互相独立，所以设 $d(i)$ 为第 $i$ 门课的人的排名固定时成绩方案数，则有：\n$$ d(i)=\\sum_{j=1} j^{N-R_i} (U_i-j)^{R_i-1} $$\n这里的算法是枚举 B 神的分数，然后统计每个人可能的分数的方案数。可以发现 $j^{N-R_i} (U_i-j)^{R_i-1}$ 是一个 $N-1$ 次多项式，则 $d(i)$ 是一个 $n$ 次多项式，插值解决。\n最后定义 $f[i][j]$ 为考虑成绩的具体取值的方案数：\n$$ f[i][j]=d(i)\\sum_{k=j}^{n-1} f[i-1][k] \\binom{k}{j} \\binom{n-k-1}{r[i]-1-k+j}\\\\ f[0][N-1]=1 $$\n最后答案为 $f[M][K]$。时间复杂度 $\\Theta(MN^2)$。\n#include \u0026lt;iostream\u0026gt; using namespace std; constexpr int MAXN = 100 + 10; constexpr int MOD = 1e9 + 7; int n, m, k; int u[MAXN], r[MAXN]; int c[MAXN][MAXN], d[MAXN], f[MAXN][MAXN]; int power(int x, int y) { int res = 1; for (; y; y /= 2) { if (y % 2) res = 1ll * res * x % MOD; x = 1ll * x * x % MOD; } return res; } int interpolation(int deg, int k, int x[], int y[]) { int res = 0; for (int i = 1; i \u0026lt;= deg + 1; ++i) { int num = y[i], den = 1; for (int j = 1; j \u0026lt;= deg + 1; ++j) { if (i == j) continue; num = 1ll * num * (k - x[j] + MOD) % MOD; den = 1ll * den * (x[i] - x[j] + MOD) % MOD; } res = (res + 1ll * num * power(den, MOD - 2)) % MOD; } return res; } int calc(int i) { int x[MAXN] = { 0 }, y[MAXN] = { 0 }; for (int j = 1; j \u0026lt;= min(u[i], n + 1); ++j) { x[j] = j; y[j] = (y[j - 1] + 1ll * power(j, n - r[i]) * power(u[i] - j, r[i] - 1)) % MOD; } if (u[i] \u0026lt;= n + 1) return y[u[i]]; return interpolation(n, u[i], x, y); } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= m; ++i) cin \u0026gt;\u0026gt; u[i]; for (int i = 1; i \u0026lt;= m; ++i) cin \u0026gt;\u0026gt; r[i]; for (int i = 0; i \u0026lt;= n; ++i) c[i][0] = c[i][i] = 1; for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt; i; ++j) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD; for (int i = 1; i \u0026lt;= m; ++i) d[i] = calc(i); f[0][n - 1] = 1; for (int i = 1; i \u0026lt;= m; ++i) { for (int j = 1; j \u0026lt; n; ++j) { for (int k = j; k \u0026lt; n; ++k) { if (k - j \u0026gt; r[i] - 1) continue; int cnt = 1ll * c[k][j] * c[n - k - 1][r[i] - 1 - (k - j)] % MOD; int pre = 1ll * d[i] * f[i - 1][k] % MOD * cnt % MOD; f[i][j] = (f[i][j] + pre) % MOD; } } } cout \u0026lt;\u0026lt; f[m][k] \u0026lt;\u0026lt; endl; return 0; }  Luogu P4463 calc  定义一个长度为 $n$ 的正整数数列 $a_n$ 的权值为 $\\prod_{i=1}a_i$，现在要求你求出所有满足以下条件的数列的权值并对质数 $p$ 取模：\n $\\forall i,j \\in [1,n]\\wedge i\\ne j$，$a_i\\ne a_j$。 $\\forall i \\in [1,n]$，$a_i\\in [1,k]$。  $1\\le k\\le 10^9$，$1\\le n\\le 500$，$2 \\le p \\le 10^9$，$p\u0026gt;k\u0026gt;n+1$。\n 设 $f[i][j]$ 为不考虑数的顺序情况下，在数列的前 $i$ 个数都属于 $[1,j]$ 的权值和，考虑选或不选 $j$ 这个数，则有：\n$$ f[i][j]=f[i][j-1]+j\\cdot f[i-1][j-1]\\\\ f[0][j]=1 $$\n最后答案为 $f[n][k]$。可以想到需要插值，现在重点是要知道 $f[n][x]$ 的次数。\n设 $d[i][j]$ 为 $f[i][j]$ 的次数.\n 首先可以知道 $d[0][j]=0$。 对于 $i=1$，仅考虑 $f[1][j]\\longleftarrow j\\cdot f[0][j-1]$，则 $d[1][j] = 1$，而考虑 $f[1][j]\\longleftarrow f[1][j-1]$，相当于做前缀和，则 $d[1][j] = 2$。 对于 $i=2$，仅考虑 $f[2][j]\\longleftarrow j\\cdot f[1][j-1]$，则 $d[2][j] = 3$，而考虑 $f[2][j]\\longleftarrow f[2][j-1]$，相当于做前缀和，则 $d[2][j] = 4$。 etc.  最后得到 $d[n][x]=2n$，则需要处理出 $2n+1$ 个 $f[n][x_i]$。 注意这还没考虑数的顺序，对数列进行全排列，答案为 $n!f[n][k]$。\n时间复杂度 $\\Theta(2n^2+8n^3)$。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; constexpr int MAXN = 500 + 10; int n, k, p, f[MAXN][MAXN * 2]; int x[MAXN * 2], y[MAXN * 2]; void DP() { for (int i = 0; i \u0026lt;= 2 * n; ++i) f[0][i] = 1; for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= 2 * n; ++j) f[i][j] = (f[i][j - 1] + 1ll * j * f[i - 1][j - 1]) % p; } int power(int x, int y) { int res = 1; while (y) { if (y % 2) res = 1ll * res * x % p; x = 1ll * x * x % p; y /= 2; } return res % p; } int inv(int x) { return power(x, p - 2); } int interpolation(int deg, int k, int x[], int y[]) { int ans = 0; for (int i = 1; i \u0026lt;= deg + 1; ++i) { int num = y[i], den = 1; for (int j = 1; j \u0026lt;= deg + 1; ++j) { if (i == j) continue; num = 1ll * num * (k - x[j] + p) % p; den = 1ll * den * (x[i] - x[j] + p) % p; } ans = (ans + 1ll num * inv(den) % p) % p; } return ans; } int main() { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p; DP(); for (int i = 1; i \u0026lt;= 2 * n + 1; ++i) { x[i] = i; y[i] = f[n][i]; } int ans = interpolation(2 * n, k % p, x, y); for (int i = 1; i \u0026lt;= n; ++i) ans = 1ll * ans * i % p; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  ","id":8,"section":"posts","summary":"拉格朗日插值是众多插值算法中的一种，插值是通过一些点来求出过这些点的多项式函数的过程。 算法思想 构造函数 给出 $n + 1$ 个点 $(x_1,y_1),(","tags":["OI","数学","多项式","拉格朗日插值","C++"],"title":"拉格朗日插值学习笔记","uri":"https://ctj12461.vercel.app/contents/20220207-lagrange-interpolation-note/","year":"2022"},{"content":"高斯消元主要用于求解线性方程组的解，同时可以解决某些有后效性的 DP 问题，\n算法思想 增广矩阵 为了更方便地求解方程组，可以将系数和常数项放入矩阵，接下来就可以用一些矩阵的操作来消元了。\n比如有一个方程组如下：\n$$ \\begin{cases} 3x+2y+3z=10\\\\ 3x+y+4z=12\\\\ x+y+z=4 \\end{cases} $$\n我们可以这么用矩阵表示:\n$$ \\begin{bmatrix} 2 \u0026amp; 2 \u0026amp; 3 \\\\ 3 \u0026amp; 1 \u0026amp; 4 \\\\ 1 \u0026amp; 1 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} 10 \\\\ 12 \\\\ 1 \\end{bmatrix} $$\n在理论分析和实现代码时，为了方便，通常把两个矩阵拼在一起，这个矩阵就是增广矩阵：\n$$ \\begin{bmatrix} 2 \u0026amp; 2 \u0026amp; 3 \u0026amp; 10 \\\\ 3 \u0026amp; 1 \u0026amp; 4 \u0026amp; 12 \\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \\end{bmatrix} $$\n增广矩阵的第 $i$ 行代笔第 $i$ 个方程，第 $i$ 列表示第 $i$ 个未知数的系数或常数项，接下来用 $x_i$ 表示第 $i$ 个未知数。\n初等行变换 初等行变换是指行之间的加减乘等运算。消元的本质就是利用初等行变换，使未知数的系数变为 $0$。具体地，初等行变换是两个行中的元素逐一进行运算，以上面的矩阵为例，记 $row_i$ 表示第 $i$ 行，则 $row_2 \\longleftarrow row_2 - \\frac{2}{3}row_1$ 的结果就是：\n$$ \\begin{bmatrix} 0 \u0026amp; -2 \u0026amp; -\\frac{1}{2} \u0026amp; -3 \\end{bmatrix} $$\n这个操作使该行的第 $1$ 个元素变为了 $0$，从方程的意义上考虑，就是消去了一个元。\n三角矩阵和对角矩阵 三角矩阵是指一个矩阵的一个三角部分全部为 $0$，对角矩阵则是对角线之外的元素均为 $0$。高斯消元中，三角矩阵一般指下三角矩阵，对角矩阵一般指除常数项部分为对角矩阵的矩阵。\n假设得到了一个对角矩阵：\n$$ \\begin{bmatrix} k_1 \u0026amp; 0 \u0026amp; 0 \u0026amp; c_1\\\\ 0 \u0026amp; k_2 \u0026amp; 0 \u0026amp; c_2\\\\ 0 \u0026amp; 0 \u0026amp; k_3 \u0026amp; c_3 \\end{bmatrix} $$\n那就相当于是一个个的一元线性方程，直接解出即可。而对角矩阵可以通过三角矩阵得出：\n$$ \\begin{bmatrix} k_{11} \u0026amp; k_{12} \u0026amp; k_{13} \u0026amp; c_1\\\\ 0 \u0026amp; k_{22} \u0026amp; k_{23} \u0026amp; c_2\\\\ 0 \u0026amp; 0 \u0026amp; k_{33} \u0026amp; c_3 \\end{bmatrix} $$\n首先可以解出 $x_3$，然后将 $x_3$ 带入第 $2$ 个方程，则 $k_{23}x_3$ 就成为了常数项，移项一下得到：\n$$ \\begin{bmatrix} k_{11} \u0026amp; k_{12} \u0026amp; k_{13} \u0026amp; c_1\\\\ 0 \u0026amp; k_{22} \u0026amp; 0 \u0026amp; c_2 - k_{23}x_3\\\\ 0 \u0026amp; 0 \u0026amp; k_{33} \u0026amp; c_3 \\end{bmatrix} $$\n同理带入 $x_2,x_3$ 到第 $1$ 个方程：\n$$ \\begin{bmatrix} k_{11} \u0026amp; 0 \u0026amp; 0 \u0026amp; c_1 - k_{12}x_2 - k_{13}x_3\\\\ 0 \u0026amp; k_{22} \u0026amp; 0 \u0026amp; c_2 - k_{23}x_3\\\\ 0 \u0026amp; 0 \u0026amp; k_{33} \u0026amp; c_3 \\end{bmatrix} $$\n具体步骤与实例 只要从上往下将每行与它下面的行进行运算，每枚举一行就消去一个元，枚举第 $i$ 行则消去 $x_i$，即通过初等行变换把第 $i + 1$ 到 $n$ 的方程的 $x_i$ 系数变为 $0$。最后从下往上带入即可。\n以上面的矩阵为例，这里就模拟到得到三角矩阵：\n$$ \\begin{bmatrix} 2 \u0026amp; 2 \u0026amp; 3 \u0026amp; 10 \\\\ 3 \u0026amp; 1 \u0026amp; 4 \u0026amp; 12 \\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \\end{bmatrix} $$\nStep 1: $row_2 \\longleftarrow row_2 - \\frac{2}{3}row_1$ $$ \\begin{bmatrix} 2 \u0026amp; 2 \u0026amp; 3 \u0026amp; 10 \\\\ 0 \u0026amp; -2 \u0026amp; -\\frac{1}{2} \u0026amp; -3 \\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \\end{bmatrix} $$\nStep 2: $row_3 \\longleftarrow row_3 - \\frac{1}{2}row_1$ $$ \\begin{bmatrix} 2 \u0026amp; 2 \u0026amp; 3 \u0026amp; 10 \\\\ 0 \u0026amp; -2 \u0026amp; -\\frac{1}{2} \u0026amp; -3 \\\\ 0 \u0026amp; 0 \u0026amp; -\\frac{1}{2} \u0026amp; -4 \\end{bmatrix} $$\nStep 3: $row_3 \\longleftarrow row_3 - 0\\cdot row_2$\n增广矩阵不变。\n高斯-约旦消元 由于计算机上浮点数的精度有限，要尽可能选择绝对值较大的数作为除数，所以枚举到第 $i$ 行时，可以找到 $x_i$ 的系数最大的方程，与当前行交换，这种方法叫做高斯-约旦消元法。\n解的判断 方程组有可能有无数解（含自由元）或无解。得到一个对角矩阵后，若存在对角元素 $k_{ii} = 0$，而常数项 $c_i \\ne 0$，则无解，否则若存在对角元素 $k_{ii} = 0$，而常数项 $c_i = 0$，则含自由元。\n代码实现 class EquationGroup { public: enum class Result { UNIQUE, INFINITY, NO_SOLUTION }; void init(int n) { this-\u0026gt;n = n; e = vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt;(n + 1, vector\u0026lt;double\u0026gt;(n + 2)); } vector\u0026lt;double\u0026gt; \u0026amp;operator[](int x) { return e[x]; } pair\u0026lt;vector\u0026lt;double\u0026gt;, Result\u0026gt; solve() { transform(); Result res = calc(); vector\u0026lt;double\u0026gt; x(n + 1); for (int i = 1; i \u0026lt;= n; ++i) x[i] = e[i][n + 1]; return {x, res}; } private: vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; e; int n; // 未知数个数 void transform() { for (int i = 1; i \u0026lt;= n; ++i) { int p = i; // 选择 e[][i] 绝对值最大的一行进行交换 for (int j = i + 1; j \u0026lt;= n; ++j) if (abs(e[p][i]) \u0026lt; abs(e[j][i])) p = j; if (p != i) for (int j = 1; j \u0026lt;= n + 1; ++j) swap(e[i][j], e[p][j]); // 初等行变换 for (int j = i + 1; j \u0026lt;= n; ++j) { double rate = e[j][i] / e[i][i]; for (int k = 1; k \u0026lt;= n + 1; ++k) e[j][k] -= e[i][k] * rate; } } } Result calc() { Result res = Result::UNIQUE; for (int i = n; i \u0026gt;= 1; --i) { // 把解 x_i 存在 e[i][n + 1] 中 for (int j = i + 1; j \u0026lt;= n; ++j) e[i][n + 1] -= e[i][j] * e[j][n + 1]; if (!e[i][i]) { e[i][n + 1] /= e[i][i]; } else { if (e[i][n + 1]) res = Result::NO_SOLUTION; else if (res != Result::NO_SOLUTION) res = Result::INFINITY; } } return res; } };  例题 Luogu P4035 球形空间产生器  给出一个 $n + 1$ 个 $n$ 维空间的点，求这 $n + 1$ 个点构成的 $n$ 维球体的球心。\n$1 \\le n \\le 10$。\n 设球心为 $(x_1,x_2,\\dots,x_n)$，半径为 $r$，对于球体的某个点 $p$，有如下关系：\n$$ \\sum_{i = 1}^{n} (p_i - x_i) ^ 2 = r ^ 2\\\\ $$\n展开并移项得到：\n$$ \\sum_{i = 1}^{n} 2p_ix_i + (r ^ 2 - \\sum_{i = 1}^{n} x_i ^ 2) = \\sum_{i = 1}^{n} p_i ^ 2 $$\n把括号看成一个整体，显然是一个 $n + 1$ 元线性方程组，直接高斯消元求解。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; constexpr int MAXN = 10 + 5; int n; double pos[MAXN][MAXN], mat[MAXN][MAXN]; void preprocess() { for (int i = 1; i \u0026lt;= n + 1; ++i) { double sum = 0; for (int j = 1; j \u0026lt;= n; ++j) { mat[i][j] = 2 * pos[i][j]; sum += pos[i][j] * pos[i][j]; } mat[i][n + 1] = 1; mat[i][n + 2] = sum; } } void transform(int n) { for (int i = 1; i \u0026lt;= n; ++i) { int p = i; for (int j = i + 1; j \u0026lt;= n; ++j) if (abs(mat[p][i]) \u0026lt; abs(mat[j][i])) p = j; if (i != p) for (int j = i; j \u0026lt;= n + 1; ++j) swap(mat[i][j], mat[p][j]); for (int j = i + 1; j \u0026lt;= n; ++j) { double rate = mat[j][i] / mat[i][i]; for (int k = i; k \u0026lt;= n + 1; ++k) mat[j][k] -= rate * mat[i][k]; } } } void calc(int n) { for (int i = n; i \u0026gt;= 1; --i) { for (int j = i + 1; j \u0026lt;= n; ++j) mat[i][n + 1] -= mat[i][j] * mat[j][n + 1]; mat[i][n + 1] /= mat[i][i]; } } void guass(int n) { transform(n); calc(n); } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n + 1; ++i) for (int j = 1; j \u0026lt;= n; ++j) cin \u0026gt;\u0026gt; pos[i][j]; preprocess(); guass(n + 1); for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; mat[i][n + 2] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; return 0; }  Codeforces 24D Broken robot  $n$ 行 $m$ 列的矩阵，$(1, 1)$ 是矩阵的左上角，$(n, m)$ 是矩阵的右下角。现在你在 $(x, y)$，每次等概率向左，右，下走或原地不动，但不能走出去，问走到最后一行期望的步数。（原地不动也算一步）\n$1 \\le n, m \\le 10 ^ 3$，$1 \\le x \\le n$，$1 \\le y \\le m$。\n 先考虑 $m = 1$ 的情况，有 $\\frac{1}{2}$ 的概率留在原地，$\\frac{1}{2}$ 的概率向下走，期望步数为 $2 (m - x)$。\n若 $m \u0026gt; 1$，设 $f[i][j]$ 为从 $(i, j)$ 走到最后一行的期望步数，则\n$$ f[i][j] = \\begin{cases} \\frac{f[i][j + 1] + f[i + 1][j] + f[i][j]}{3} + 1 \u0026amp; j = 1\\\\ \\frac{f[i][j - 1] + f[i][j + 1] + f[i + 1][j] + f[i][j]}{4} + 1 \u0026amp; 1 \u0026lt; j \u0026lt; m\\\\ \\frac{f[i][j - 1] + f[i + 1][j] + f[i][j]}{3} + 1 \u0026amp; j = m \\end{cases} $$\n移项可得：\n$$ \\begin{cases} 2f[i][j] - f[i][j + 1] - f[i + 1][j] = 3 \u0026amp; j = 1\\\\ 3f[i][j] - f[i][j - 1] - f[i][j + 1] - f[i + 1][j] = 4 \u0026amp; 1 \u0026lt; j \u0026lt; m\\\\ 2f[i][j] - f[i][j - 1] - f[i + 1][j] = 3 \u0026amp; j = m \\end{cases} $$\n于是每行的转移就可以解决了。然而暴力消元的复杂度不正确，考虑到每个方程都至多只有三个系数不为 $0$，每一行只会消去下一行的一个元（可以手画一个矩阵），利用这个性质，消元可以做到 $\\Theta(m)$，总的复杂度就是 $\\Theta(m (n-x))$。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; constexpr int MAXN = 1e3 + 5; // * * 0 0 0 0 | * // * * * 0 0 0 | * // 0 * * * 0 0 | * // 0 0 * * * 0 | * // 0 0 0 * * * | * // 0 0 0 0 * * | * int n, m, x, y; double mat[MAXN][MAXN], f[MAXN]; void fill() { mat[1][1] = 2; mat[1][2] = -1; mat[1][m + 1] = 3 + f[1]; for (int i = 2; i \u0026lt; m; ++i) { mat[i][i] = 3; mat[i][i - 1] = -1; mat[i][i + 1] = -1; mat[i][m + 1] = 4 + f[i]; } mat[m][m] = 2; mat[m][m - 1] = -1; mat[m][m + 1] = 3 + f[m]; } void gauss() { for (int i = 1; i \u0026lt; m; ++i) { double rate = mat[i + 1][i] / mat[i][i]; mat[i + 1][i] = 0; mat[i + 1][i + 1] -= rate * mat[i][i + 1]; mat[i + 1][m + 1] -= rate * mat[i][m + 1]; } mat[m][m + 1] /= mat[m][m]; for (int i = m - 1; i \u0026gt;= 1; --i) mat[i][m + 1] = (mat[i][m + 1] - mat[i + 1][m + 1] * mat[i][i + 1]) / mat[i][i]; for (int i = 1; i \u0026lt;= m; ++i) f[i] = mat[i][m + 1]; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (m == 1) { cout \u0026lt;\u0026lt; 2 * (n - x) \u0026lt;\u0026lt; endl; return 0; } for (int i = n - 1; i \u0026gt;= x; --i) { fill(); gauss(); } cout \u0026lt;\u0026lt; setprecision(8) \u0026lt;\u0026lt; f[y] \u0026lt;\u0026lt; endl; return 0; }  Luogu P3232 游走  给定一个 $n$ 个点 $m$ 条边的无向连通图，顶点从 $1$ 编号到 $n$，边从 $1$ 编号到 $m$。\n小 Z 在该图上进行随机游走，初始时小 Z 在 $1$ 号顶点，每一步小 Z 以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小 Z 到达 $n$ 号顶点时游走结束，总分为所有获得的分数之和。现在，请你对这 $m$ 条边进行编号，使得小 Z 获得的总分的期望值最小。\n$2 \\le n \\le 500$，$1 \\le m \\le 125000$。\n 设 $f[i]$ 表示走到 $i$ 的期望次数，$deg[i]$ 为点 $x$ 的度，则对于一条边 $(x, y)$，其期望次数为：\n$$ \\frac{f[x]}{deg[x]} + \\frac{f[y]}{deg[y]} $$\n考虑 $f[i]$ 的转移，设 $j$ 为 $i$ 的上一个结点，则：\n$$ f[i] = \\sum\\frac{f[j]}{deg[j]} + [i = 1] $$\n因为初始在点 $1$，则期望次数会多 $1$。把这个方程，由于 $n$ 是终点，不参加转移，设 $f[n] = 0$。于是前 $n - 1$ 个转移方程组成一个方程组，解出它即可。\n最后算出每条边的期望次数，根据排序不等式，次数越多的边应该编号越小，这样答案更优。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; constexpr int MAXN = 500 + 10; constexpr int MAXM = 125000 + 10; struct Equation { double a[MAXN]; double \u0026amp;operator[](int x) { return a[x]; } }; struct EquationGroup { Equation e[MAXN]; int n; void init(int n) { this-\u0026gt;n = n; } Equation \u0026amp;operator[](int x) { return e[x]; } void transform() { for (int i = 1; i \u0026lt;= n; ++i) { int p = i; for (int j = i + 1; j \u0026lt;= n; ++j) if (abs(e[p][i]) \u0026lt; abs(e[j][i])) p = j; if (p != i) for (int j = 1; j \u0026lt;= n + 1; ++j) swap(e[i][j], e[p][j]); for (int j = i + 1; j \u0026lt;= n; ++j) { double rate = e[j][i] / e[i][i]; for (int k = 1; k \u0026lt;= n + 1; ++k) e[j][k] -= e[i][k] * rate; } } } void calc() { for (int i = n; i \u0026gt;= 1; --i) { for (int j = i + 1; j \u0026lt;= n; ++j) e[i][n + 1] -= e[i][j] * e[j][n + 1]; e[i][n + 1] /= e[i][i]; } } vector\u0026lt;double\u0026gt; solve() { transform(); calc(); vector\u0026lt;double\u0026gt; res(n + 1); for (int i = 1; i \u0026lt;= n; ++i) res[i] = e[i][n + 1]; return res; } }; struct Edge { int x, y; double p; bool operator\u0026lt;(const Edge \u0026amp;rhs) const { return p \u0026gt; rhs.p; } }; int n, m; EquationGroup e; vector\u0026lt;int\u0026gt; graph[MAXN]; int deg[MAXN]; Edge edges[MAXM]; double ans; void link(int x, int y) { graph[x].push_back(y); graph[y].push_back(x); ++deg[x]; ++deg[y]; } int main() { ios::sync_with_stdio(false); cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(3); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) { auto \u0026amp;[x, y, p] = edges[i]; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; link(x, y); } e.init(n - 1); for (int i = 1; i \u0026lt; n; ++i) { for (int j : graph[i]) if (j != n) e[i][j] = -1.0 / deg[j]; e[i][i] = 1; } e[1][n] = 1; auto f = e.solve(); for (int i = 1; i \u0026lt;= m; ++i) { auto \u0026amp;[x, y, p] = edges[i]; p = (x != n ? f[x] / deg[x] : 0) + (y != n ? f[y] / deg[y] : 0); } sort(edges + 1, edges + 1 + m); for (int i = 1; i \u0026lt;= m; ++i) ans += i * edges[i].p; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  Luogu P3211 XOR 和路径  给定一个无向连通图，有 $n$ 个点和 $m$ 条边，其节点编号为 $1$ 到 $n$，其边的权值为非负整数。从 $1$ 号节点开始，以相等的概率随机选择一个有连边的点，并沿这条边走到下一个节点，重复这个过程，直到走到 $n$ 号节点为止，便得到一条从 $1$ 号节点到 $n$ 号节点的路径，请你求出该算法得到的路径的 XOR 和的期望值。\n设 $(x, y, w)$ 为图中的一条边，$1 \\le x, y \\le n$，$0 \\le w \\le 10 ^ 9$，$2 \\le n \\le 100$，$1 \\le m \\le 10000$。图中可能有重边或自环。\n 首先可能想到设 $f[x]$ 为 $x$ 点的 XOR 期望，方程为\n$$ f[x] = \\sum_y \\frac{f[y] \\oplus w(x, y)}{deg[x]} $$\n但是这种方程是无法转移的。先考虑答案是怎么得到的假设有一条路径 $P = \\{w_1, w_2, \\dots, w_k\\}$，其对答案的贡献为：\n$$ p(w_1 \\oplus w_2 \\oplus \\cdots \\oplus w_k) $$\n如果按位考虑，分子的结果只会是 $0$ 或 $1$，只需要求出分子的结果为 $1$ 的概率。\n设 $f[x][0/1]$ 为点 $x$ 到点 $n$ 的路径异或值为 $0/1$ 的概率。于是可以写成方程：\n$$ f[x][0] = \\sum_y \\frac{f[y][w(x, y)]}{deg[x]}\\\\ f[x][1] = \\sum_y \\frac{f[y][w(x, y) \\oplus 1]}{deg[x]}\\\\ $$\n设当前枚举的位数为 $b$，则对答案的贡献为 $2 ^ b f[1][1]$。上述转移显然可以高斯消元解决，时间复杂度 $\\Theta(n ^ 3 \\log_2 w)$。\n注意连接自环不要连两遍。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; constexpr int MAXN = 100 + 10; class EquationGroup { public: void init(int n) { this-\u0026gt;n = n; e = vector\u0026lt;vector\u0026lt;long double\u0026gt;\u0026gt;(n + 1, vector\u0026lt;long double\u0026gt;(n + 2, 0)); } vector\u0026lt;long double\u0026gt; \u0026amp;operator[](int x) { return e[x]; } vector\u0026lt;long double\u0026gt; solve() { transform(); calc(); vector\u0026lt;long double\u0026gt; res(n + 1); for (int i = 1; i \u0026lt;= n; ++i) res[i] = e[i][n + 1]; return res; } private: int n; vector\u0026lt;vector\u0026lt;long double\u0026gt;\u0026gt; e; void transform() { for (int i = 1; i \u0026lt;= n; ++i) { int p = i; for (int j = i + 1; j \u0026lt;= n; ++j) if (abs(e[p][i]) \u0026lt; abs(e[j][i])) p = j; if (p != i) for (int j = i; j \u0026lt;= n + 1; ++j) swap(e[i][j], e[p][j]); for (int j = i + 1; j \u0026lt;= n; ++j) { long double rate = e[j][i] / e[i][i]; for (int k = i; k \u0026lt;= n + 1; ++k) e[j][k] -= rate * e[i][k]; } } } void calc() { for (int i = n; i \u0026gt;= 1; --i) { for (int j = i + 1; j \u0026lt;= n; ++j) e[i][n + 1] -= e[i][j] * e[j][n + 1]; e[i][n + 1] /= e[i][i]; } } }; int n, m, mx; EquationGroup e; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; graph[MAXN]; int deg[MAXN]; long double ans; void link(int x, int y, int w) { graph[x].push_back({y, w}); ++deg[x]; if (x != y) { graph[y].push_back({x, w}); ++deg[y]; } } long double calc(int b) { e.init(2 * n); for (int x = 1; x \u0026lt; n; ++x) { e[x][x] += deg[x]; e[x + n][x + n] += deg[x]; for (auto [y, w] : graph[x]) { int w1 = ((w \u0026gt;\u0026gt; b) \u0026amp; 1); e[x][y + w1 * n] += -1; e[x + n][y + (w1 ^ 1) * n] += -1; } } e[n][n] = 1; e[n][2 * n + 1] = 1; e[n + n][2 * n] = 1; e[n + n][2 * n + 1] = 0; auto f = e.solve(); return f[1 + n] * (1 \u0026lt;\u0026lt; b); } int main() { ios::sync_with_stdio(false); cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(3); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; ++i) { int x, y, w; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; w; link(x, y, w); mx = max(mx, w); } mx = (int) log2(mx); for (int i = 0; i \u0026lt;= mx; ++i) ans += calc(i); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  ","id":9,"section":"posts","summary":"高斯消元主要用于求解线性方程组的解，同时可以解决某些有后效性的 DP 问题， 算法思想 增广矩阵 为了更方便地求解方程组，可以将系数和常数项放入矩阵，接","tags":["OI","数学","线性代数","高斯消元","C++"],"title":"高斯消元学习笔记","uri":"https://ctj12461.vercel.app/contents/20220206-gauss-elimination-note/","year":"2022"},{"content":"这里给出一种无需换根的 DP 思路。\nPart 1 我们从结点的添加方式入手，可以把结点分为三类：\n 初始的结点，这种结点只有一个 通过 Append 添加的结点，以下简称 A 类结点 通过 Insert 添加的结点，以下简称 I 类结点  不换根的思路核心就在于保证转移时的过程符合结点的添加规则。为了方便，我们可以给每条线定向。同时假设 $1$ 为根，$x$ 为当前结点，$y$ 为 $x$ 的一个儿子结点，$fa$ 为 $x$ 的父亲结点。很显然接下来可以分 $6$ 类讨论：\n  若 $x$ 为初始结点，则其子结点、$fa$ 都应该连向 $x$\n  若 $x$ 为 A 类结点\n $x$ 向 $fa$ 连一条红线，子结点连向 $x$ $x$ 向其中一个子结点 $y$ 连一条红线，其他子结点以及 $fa$ 连向 $x$    若 $x$ 为 I 类结点\n $x$ 取代一个子结点 $y$ 连向 $fa$ 的红线，然后换成蓝线 $x$ 取代两个个子结点 $y_1$ 和 $y_2$ 之间的红线，然后换成蓝线 $x$ 取代 $fa$ 连向一个子结点 $y$ 的红线，然后换成蓝线    上面的分类讨论中的“连向”可以看成 Append 或 Insert，根据题意计算就可以了。\nPart 2 接下来根据分类讨论设出状态以及写出方程：\nlong long f[MAXN][6]; /** * f[x][0]: x is initial * f[x][1]: x -\u0026gt; fa * f[x][2]: x -\u0026gt; y * f[x][3]: y -\u0026gt; x -\u0026gt; fa * f[x][4]: y1 -\u0026gt; x -\u0026gt; y2 * f[x][5]: fa -\u0026gt; x -\u0026gt; y */  设 $cont(x)$ 表示 $x$ 向其父结点连线的贡献，则 $cont(x)=\\max\\{f[x][1],f[x][3]+len(x,fa(x))\\}$。 $$ f[x][0]=\\sum_{y\\in son(x)}cont(y)\\\\ f[x][1]=\\sum_{y\\in son(x)}cont(y)\\\\ f[x][2]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{\\max\\{f[y][0], f[y][2], f[y][4], f[y][5] + len(y,x)\\}-cont(y)\\}\\\\ f[x][3]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{f[y][1]+len(y,x)-cont(y)\\}\\\\ f[x][4]=\\sum_{y\\in son(x)}cont(y)+\\\\\\max_{y_1,y_2\\in son(x)\\wedge y_1\\ne y_2}\\{ f[y_1][1]+len(y_1,x)-cont(y_1)+\\max\\{f[y_2][0], f[y_2][2], f[y_2][4]\\}+len(y_2,x)-cont(y_2)\\}\\\\ f[x][5]=\\sum_{y\\in son(x)}cont(y)+\\max_{y\\in son(x)}\\{\\max\\{f[y][0], f[y][2], f[y][4]\\}+len(y,x)-cont(y)\\} $$ 上面的转移都可以看成先从子结点按照 $cont(x)$ 转移，在钦定某个结点按照特定的方式转移，记录下最优的差值在加到 $f$ 里即可。$f[x][4]$ 有两个变量，可以考虑枚举其中一个，用 std::multiset\u0026lt;T\u0026gt; 维护另外一个的最值即可。\n时间复杂度 $O(n \\log_2 n)$。\nPart 3 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; constexpr int MAXN = 200000 + 10; constexpr int INFINITY = 0x7fffffff; int n; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; tree[MAXN]; long long f[MAXN][6]; /** * f[x][0]: x is initial * f[x][1]: x -\u0026gt; fa * f[x][2]: x -\u0026gt; y * f[x][3]: y -\u0026gt; x -\u0026gt; fa * f[x][4]: y1 -\u0026gt; x -\u0026gt; y2 * f[x][5]: fa -\u0026gt; x -\u0026gt; y */ void link(int x, int y, int l) { tree[x].push_back({y, l}); tree[y].push_back({x, l}); } void dfs(int x, int fa) { if (tree[x].size() == 1 \u0026amp;\u0026amp; fa != 0) { f[x][2] = f[x][3] = f[x][4] = f[x][5] = -INFINITY; return; } long long sum = 0, delta[4] = {-INFINITY, -INFINITY, -INFINITY, -INFINITY}; multiset\u0026lt;long long\u0026gt; val; val.insert(-INFINITY); for (auto [y, l] : tree[x]) { if (y == fa) continue; dfs(y, x); long long cont = max(f[y][1], f[y][3] + l); sum += cont; for (int i = 0; i \u0026lt; 6; ++i) f[x][i] += cont; delta[0] = max(delta[0], max(max(max(f[y][0], f[y][2]), f[y][4]), f[y][5] + l) - cont); delta[1] = max(delta[1], f[y][1] + l - cont); delta[3] = max(delta[3], max(max(f[y][0], f[y][2]), f[y][4]) + l - cont); val.insert(f[y][1] + l - cont); } for (auto [y, l] : tree[x]) { if (y == fa) continue; int cont = max(f[y][1], f[y][3] + l); val.erase(val.find(f[y][1] + l - cont)); delta[2] = max(delta[2], *val.rbegin() + max(max(f[y][0], f[y][2]), f[y][4]) + l - cont); val.insert(f[y][1] + l - cont); } f[x][2] += delta[0]; f[x][3] += delta[1]; f[x][4] += delta[2]; f[x][5] += delta[3]; for (int i = 0; i \u0026lt; 6; ++i) if (f[x][i] \u0026lt; 0) f[x][i] = -INFINITY; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n; if (n == 1) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return 0; } for (int i = 1; i \u0026lt; n; ++i) { int x, y, l; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; l; link(x, y, l); } dfs(1, 0); cout \u0026lt;\u0026lt; max(max(f[1][0], f[1][2]), f[1][4]) \u0026lt;\u0026lt; endl; return 0; }  ","id":10,"section":"posts","summary":"这里给出一种无需换根的 DP 思路。 Part 1 我们从结点的添加方式入手，可以把结点分为三类： 初始的结点，这种结点只有一个 通过 Append 添加的结点，以下简称 A 类结","tags":["OI","DP","树形 DP","C++"],"title":"Luogu P3647 连珠线题解","uri":"https://ctj12461.vercel.app/contents/20220204-luogu-p3647-solution/","year":"2022"}],"tags":[{"title":"Arch Linux","uri":"https://ctj12461.vercel.app/tags/arch-linux/"},{"title":"BSGS","uri":"https://ctj12461.vercel.app/tags/bsgs/"},{"title":"Burnside 引理","uri":"https://ctj12461.vercel.app/tags/burnside-%E5%BC%95%E7%90%86/"},{"title":"C++","uri":"https://ctj12461.vercel.app/tags/c++/"},{"title":"DP","uri":"https://ctj12461.vercel.app/tags/dp/"},{"title":"Linux","uri":"https://ctj12461.vercel.app/tags/linux/"},{"title":"MultiGenerator","uri":"https://ctj12461.vercel.app/tags/multigenerator/"},{"title":"N 次剩余","uri":"https://ctj12461.vercel.app/tags/n-%E6%AC%A1%E5%89%A9%E4%BD%99/"},{"title":"OI","uri":"https://ctj12461.vercel.app/tags/oi/"},{"title":"Pólya 定理","uri":"https://ctj12461.vercel.app/tags/p%C3%B3lya-%E5%AE%9A%E7%90%86/"},{"title":"中国剩余定理","uri":"https://ctj12461.vercel.app/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"},{"title":"二分图","uri":"https://ctj12461.vercel.app/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"title":"函数对象","uri":"https://ctj12461.vercel.app/tags/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/"},{"title":"原根","uri":"https://ctj12461.vercel.app/tags/%E5%8E%9F%E6%A0%B9/"},{"title":"同余","uri":"https://ctj12461.vercel.app/tags/%E5%90%8C%E4%BD%99/"},{"title":"图论","uri":"https://ctj12461.vercel.app/tags/%E5%9B%BE%E8%AE%BA/"},{"title":"多线程","uri":"https://ctj12461.vercel.app/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"多项式","uri":"https://ctj12461.vercel.app/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"title":"建模","uri":"https://ctj12461.vercel.app/tags/%E5%BB%BA%E6%A8%A1/"},{"title":"技术","uri":"https://ctj12461.vercel.app/tags/%E6%8A%80%E6%9C%AF/"},{"title":"拉格朗日插值","uri":"https://ctj12461.vercel.app/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"},{"title":"数学","uri":"https://ctj12461.vercel.app/tags/%E6%95%B0%E5%AD%A6/"},{"title":"数论","uri":"https://ctj12461.vercel.app/tags/%E6%95%B0%E8%AE%BA/"},{"title":"数论分块","uri":"https://ctj12461.vercel.app/tags/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/"},{"title":"标准库","uri":"https://ctj12461.vercel.app/tags/%E6%A0%87%E5%87%86%E5%BA%93/"},{"title":"树形 DP","uri":"https://ctj12461.vercel.app/tags/%E6%A0%91%E5%BD%A2-dp/"},{"title":"欧拉函数","uri":"https://ctj12461.vercel.app/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"title":"欧拉定理","uri":"https://ctj12461.vercel.app/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"title":"积性函数","uri":"https://ctj12461.vercel.app/tags/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/"},{"title":"筛法","uri":"https://ctj12461.vercel.app/tags/%E7%AD%9B%E6%B3%95/"},{"title":"线性代数","uri":"https://ctj12461.vercel.app/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"title":"置换群","uri":"https://ctj12461.vercel.app/tags/%E7%BD%AE%E6%8D%A2%E7%BE%A4/"},{"title":"群论","uri":"https://ctj12461.vercel.app/tags/%E7%BE%A4%E8%AE%BA/"},{"title":"莫比乌斯函数","uri":"https://ctj12461.vercel.app/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/"},{"title":"莫比乌斯反演","uri":"https://ctj12461.vercel.app/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"title":"配置","uri":"https://ctj12461.vercel.app/tags/%E9%85%8D%E7%BD%AE/"},{"title":"项目","uri":"https://ctj12461.vercel.app/tags/%E9%A1%B9%E7%9B%AE/"},{"title":"高斯消元","uri":"https://ctj12461.vercel.app/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"}]}