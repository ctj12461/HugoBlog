<!doctype html><html lang=zh><head><title>同余方程学习笔记 - ctj12461's Blog</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name=renderer content="webkit"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=format-detection content="telephone=no,email=no,adress=no"><meta name=theme-color content="#000000"><meta http-equiv=window-target content="_top"><meta name=description content="解各种同余方程是同余问题的一个重要部分，本文介绍各种同余方程的求解方法。 二元线性不定方程 形式 不定方程的范围很广泛，只要没有确定的解的方程都可"><meta name=generator content="Hugo 0.96.0 with theme pure"><title>同余方程学习笔记 - ctj12461's Blog</title><link rel=stylesheet href=https://ctj12461.vercel.app/css/style.min.e64d754037c0ee0ec4e20ab1d6f07740ace61729bc03850559b8caa21ae4a597.css><link rel=stylesheet href=https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css async><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css async><meta property="og:title" content="同余方程学习笔记"><meta property="og:description" content="解各种同余方程是同余问题的一个重要部分，本文介绍各种同余方程的求解方法。 二元线性不定方程 形式 不定方程的范围很广泛，只要没有确定的解的方程都可"><meta property="og:type" content="article"><meta property="og:url" content="https://ctj12461.vercel.app/contents/20220213-congruence-equation-note/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-13T21:40:02+08:00"><meta property="article:modified_time" content="2022-02-13T21:40:02+08:00"><meta itemprop=name content="同余方程学习笔记"><meta itemprop=description content="解各种同余方程是同余问题的一个重要部分，本文介绍各种同余方程的求解方法。 二元线性不定方程 形式 不定方程的范围很广泛，只要没有确定的解的方程都可"><meta itemprop=datePublished content="2022-02-13T21:40:02+08:00"><meta itemprop=dateModified content="2022-02-13T21:40:02+08:00"><meta itemprop=wordCount content="5102"><meta itemprop=keywords content="OI,数学,数论,同余,中国剩余定理,BSGS,原根,N 次剩余,C++,"><meta name=twitter:card content="summary"><meta name=twitter:title content="同余方程学习笔记"><meta name=twitter:description content="解各种同余方程是同余问题的一个重要部分，本文介绍各种同余方程的求解方法。 二元线性不定方程 形式 不定方程的范围很广泛，只要没有确定的解的方程都可"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body class="main-center theme-black" itemscope itemtype=http://schema.org/WebPage><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=slimContent><div class=navbar-header><div class="profile-block text-center"><a id=avatar href=https://github.com/ctj12461 target=_blank><img class="img-circle img-rotate" src=https://ctj12461.vercel.app/avatar.jpg width=200 height=200></a><h2 id=name class="hidden-xs hidden-sm">ctj12461</h2><h3 id=title class="hidden-xs hidden-sm hidden-md"></h3><small id=location class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Fuzhou, China</small></div><div class=search id=search-form-wrap><form class="search-form sidebar-form"><div class=input-group><input type=text class="search-form-input form-control" placeholder=搜索>
<span class=input-group-btn><button type=submit class="search-form-submit btn btn-flat" onclick=return!1><i class="icon icon-search"></i></button></span></div><div class=ins-search><div class=ins-search-mask></div><div class=ins-search-container><div class=ins-input-wrapper><input type=text class=ins-search-input placeholder=想要查找什么... x-webkit-speech>
<button type=button class="close ins-close ins-selectable" data-dismiss=modal aria-label=Close><span aria-hidden=true>×</span></button></div><div class=ins-section-wrapper><div class=ins-section-container></div></div></div></div></form></div><button class="navbar-toggle collapsed" type=button data-toggle=collapse data-target=#main-navbar aria-controls=main-navbar aria-expanded=false>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><nav id=main-navbar class="collapse navbar-collapse" itemscope itemtype=http://schema.org/SiteNavigationElement role=navigation><ul class="nav navbar-nav main-nav"><li class="menu-item menu-item-home"><a href=/><i class="icon icon-home-fill"></i>
<span class=menu-title>Home</span></a></li><li class="menu-item menu-item-archives"><a href=/posts/><i class="icon icon-archives-fill"></i>
<span class=menu-title>Archives</span></a></li><li class="menu-item menu-item-categories"><a href=/categories/><i class="icon icon-folder"></i>
<span class=menu-title>Categories</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/><i class="icon icon-tags"></i>
<span class=menu-title>Tags</span></a></li><li class="menu-item menu-item-about"><a href=/about/><i class="icon icon-cup-fill"></i>
<span class=menu-title>About</span></a></li></ul></nav></div></header><aside class=sidebar itemscope itemtype=http://schema.org/WPSideBar><div class=slimContent><div class=widget><h3 class=widget-title>分类</h3><div class=widget-body><ul class=category-list><li class=category-list-item><a href=https://ctj12461.vercel.app/categories/document/ class=category-list-link>document</a><span class=category-list-count>1</span></li><li class=category-list-item><a href=https://ctj12461.vercel.app/categories/olympiad-in-information/ class=category-list-link>olympiad-in-information</a><span class=category-list-count>8</span></li><li class=category-list-item><a href=https://ctj12461.vercel.app/categories/tech/ class=category-list-link>tech</a><span class=category-list-count>2</span></li></ul></div></div><div class=widget><h3 class=widget-title>标签</h3><div id=tag-cloud-list class=widget-body><a href=https://ctj12461.vercel.app/tags/arch-linux/ class=tag-list-link rel=1>arch-linux<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/bsgs/ class=tag-list-link rel=1>bsgs<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/burnside-%E5%BC%95%E7%90%86/ class=tag-list-link rel=1>burnside-引理<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/c++/ class=tag-list-link rel=10>c++<span class=tag-list-count>10</span></a>
<a href=https://ctj12461.vercel.app/tags/dp/ class=tag-list-link rel=1>dp<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/linux/ class=tag-list-link rel=1>linux<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/multigenerator/ class=tag-list-link rel=1>multigenerator<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/n-%E6%AC%A1%E5%89%A9%E4%BD%99/ class=tag-list-link rel=1>n-次剩余<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/oi/ class=tag-list-link rel=9>oi<span class=tag-list-count>9</span></a>
<a href=https://ctj12461.vercel.app/tags/p%C3%B3lya-%E5%AE%9A%E7%90%86/ class=tag-list-link rel=1>pólya-定理<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/ class=tag-list-link rel=1>中国剩余定理<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/ class=tag-list-link rel=1>二分图<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/ class=tag-list-link rel=1>函数对象<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E5%8E%9F%E6%A0%B9/ class=tag-list-link rel=1>原根<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E5%90%8C%E4%BD%99/ class=tag-list-link rel=1>同余<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E5%9B%BE%E8%AE%BA/ class=tag-list-link rel=1>图论<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ class=tag-list-link rel=1>多线程<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/ class=tag-list-link rel=1>多项式<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E5%BB%BA%E6%A8%A1/ class=tag-list-link rel=1>建模<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E6%8A%80%E6%9C%AF/ class=tag-list-link rel=1>技术<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/ class=tag-list-link rel=1>拉格朗日插值<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E6%95%B0%E5%AD%A6/ class=tag-list-link rel=6>数学<span class=tag-list-count>6</span></a>
<a href=https://ctj12461.vercel.app/tags/%E6%95%B0%E8%AE%BA/ class=tag-list-link rel=3>数论<span class=tag-list-count>3</span></a>
<a href=https://ctj12461.vercel.app/tags/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/ class=tag-list-link rel=1>数论分块<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E6%A0%87%E5%87%86%E5%BA%93/ class=tag-list-link rel=1>标准库<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E6%A0%91%E5%BD%A2-dp/ class=tag-list-link rel=1>树形-dp<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/ class=tag-list-link rel=1>欧拉函数<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/ class=tag-list-link rel=1>欧拉定理<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/ class=tag-list-link rel=1>积性函数<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E7%AD%9B%E6%B3%95/ class=tag-list-link rel=1>筛法<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/ class=tag-list-link rel=1>线性代数<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E7%BD%AE%E6%8D%A2%E7%BE%A4/ class=tag-list-link rel=1>置换群<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E7%BE%A4%E8%AE%BA/ class=tag-list-link rel=1>群论<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/ class=tag-list-link rel=1>莫比乌斯函数<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/ class=tag-list-link rel=1>莫比乌斯反演<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E9%85%8D%E7%BD%AE/ class=tag-list-link rel=1>配置<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E9%A1%B9%E7%9B%AE/ class=tag-list-link rel=1>项目<span class=tag-list-count>1</span></a>
<a href=https://ctj12461.vercel.app/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/ class=tag-list-link rel=1>高斯消元<span class=tag-list-count>1</span></a></div><script>document.onreadystatechange=()=>{document.readyState==="complete"&&tagCloud("#tag-cloud-list a",8,20)};function tagCloud(n,s,o){let t=0,e=0;$(n).each(function(){let n=Number($(this).attr("rel"));t<n&&(t=n),(e>n||e==0)&&(e=n)});let i=(o-s)/(t-e);$(n).each(function(){let t=$(this).attr("rel")-e;$(this).css({"font-size":s+t*i+"px"})})}</script></div><div class=widget><h3 class=widget-title>最新文章</h3><div class=widget-body><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class=item-inner><p class=item-title><a href=https://ctj12461.vercel.app/contents/20220404-multigenerator-document/ class=title>MultiGenerator 使用文档</a></p><p class=item-date><time datetime="2022-04-04 22:15:15 +0800 +0800" itemprop=datePublished>2022-04-04</time></p></div></li><li><div class=item-inner><p class=item-title><a href=https://ctj12461.vercel.app/contents/20220329-traps-of-std-function-and-std-bind/ class=title>std::function 和 std::bind 的使用陷阱</a></p><p class=item-date><time datetime="2022-03-29 18:21:31 +0800 +0800" itemprop=datePublished>2022-03-29</time></p></div></li><li><div class=item-inner><p class=item-title><a href=https://ctj12461.vercel.app/contents/20220317-arch-linux-software-config/ class=title>Arch Linux 常用软件配置</a></p><p class=item-date><time datetime="2022-03-17 22:28:02 +0800 +0800" itemprop=datePublished>2022-03-17</time></p></div></li><li><div class=item-inner><p class=item-title><a href=https://ctj12461.vercel.app/contents/20220222-bipartite-graph-matching-note/ class=title>二分图匹配学习笔记</a></p><p class=item-date><time datetime="2022-02-22 13:31:06 +0800 +0800" itemprop=datePublished>2022-02-22</time></p></div></li><li><div class=item-inner><p class=item-title><a href=https://ctj12461.vercel.app/contents/20220220-mobius-inversion-note/ class=title>莫比乌斯反演学习笔记</a></p><p class=item-date><time datetime="2022-02-20 11:23:07 +0800 +0800" itemprop=datePublished>2022-02-20</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse" id=collapseToc itemscope itemtype=http://schema.org/WPSideBar><div class=slimContent><h4 class=toc-title>文章目录</h4><nav id=toc class="js-toc toc"></nav></div></aside><main class=main role=main><div class=content><article id=- class="article article-type-" itemscope itemtype=http://schema.org/BlogPosting><div class=article-header><h1 itemprop=name><a class=article-title href=/contents/20220213-congruence-equation-note/>同余方程学习笔记</a></h1><div class=article-meta><span class=article-date><i class="icon icon-calendar-check"></i>&nbsp;
<a href=https://ctj12461.vercel.app/contents/20220213-congruence-equation-note/ class=article-date><time datetime="2022-02-13 21:40:02 +0800 +0800" itemprop=datePublished>2022-02-13</time></a></span>
<span class=article-category><i class="icon icon-folder"></i>&nbsp;
<a class=article-category-link href=/categories/olympiad-in-information/>Olympiad in Information</a></span>
<span class=article-tag><i class="icon icon-tags"></i>&nbsp;
<a class=article-tag-link href=/tags/oi/>OI</a>
<a class=article-tag-link href=/tags/%E6%95%B0%E5%AD%A6/>数学</a>
<a class=article-tag-link href=/tags/%E6%95%B0%E8%AE%BA/>数论</a>
<a class=article-tag-link href=/tags/%E5%90%8C%E4%BD%99/>同余</a>
<a class=article-tag-link href=/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/>中国剩余定理</a>
<a class=article-tag-link href=/tags/bsgs/>BSGS</a>
<a class=article-tag-link href=/tags/%E5%8E%9F%E6%A0%B9/>原根</a>
<a class=article-tag-link href=/tags/n-%E6%AC%A1%E5%89%A9%E4%BD%99/>N 次剩余</a>
<a class=article-tag-link href=/tags/c++/>C++</a></span>
<span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden=true></i>
<span id=busuanzi_container_page_pv><span id=busuanzi_value_page_pv>0</span></span></span>
<span class="post-wordcount hidden-xs" itemprop=wordCount>字数统计: 5102字</span>
<span class="post-readcount hidden-xs" itemprop=timeRequired>阅读时长: 11分</span></div></div><div class="article-entry marked-body js-toc-content" itemprop=articleBody><p>解各种同余方程是同余问题的一个重要部分，本文介绍各种同余方程的求解方法。</p><h2 id=二元线性不定方程>二元线性不定方程</h2><h3 id=形式>形式</h3><p>不定方程的范围很广泛，只要没有确定的解的方程都可以叫不定方程。本文主要讨论数论中的不定方程。</p><p>$$
ax+by=c\ (a,b,c,x,y\in \mathrm{Z})
$$</p><p>形如上面这种形式，满足各项的系数和解均为整数的方程就是数论中的不定方程。</p><h3 id=求解>求解</h3><p><strong>Theorem 1</strong>：$\forall a, b \in \mathrm{Z}$，一定存在 $x,y\in \mathrm{Z}$，使得 $ax+by=\gcd(a,b)$。</p><p>这个定理又叫做裴蜀定理，根据这个定理，可以得出不定方程 $ax+by=c$ 有解的充要条件就是 $\gcd(a,b)\mid c$。记 $d=\gcd(a,b)$，则我们可以先求出 $ax&rsquo;+by&rsquo;=d$ 的解，再令 $x=\frac{c}{d}x&rsquo;,y=\frac{c}{d}y&rsquo;$，就得出原方程的一组解。</p><p>求 $x&rsquo;,y&rsquo;$ 的过程可以用扩展欧几里得算法，即 <code>exgcd</code> 解决。</p><p><strong>Theorem 2</strong>：若 $\gcd(a,b)=1$，且 $x_0,y_0$ 是方程 $ax+by=c$ 的一组解，则该方程的通解为 $x=x_0+kb,y=y_0-ka$，其中 $k\in \mathrm{Z}$。</p><p>换句话说，$x,y$ 这两个解是具有周期性的。根据这个定理，我们知道一定有一个 $x\in [0,b)$，而对于方程 $ax+by=c$，则一定有一个 $x\in [0,\frac{b}{\gcd(a,b)})$，由此可以求一个不定方程的一个元的最小非负整数解，具体地，假设知道了一个解 $x_0$，则最小非负整数 $x=(x_0 \bmod m + m) \bmod m$，其中 $m=\frac{b}{\gcd(a,b)}$。</p><p>总结一下，求解二元线性不定方程 $ax+by=c$ 的流程如下：</p><ol><li>求出 $ax+by=\gcd(a,b)$ 的一组解 $x&rsquo;,y&rsquo;$，并根据 $\gcd(a,b)\mid c$ 判断方程有无解</li><li>令 $x=\frac{c}{\gcd(a,b)}x&rsquo;,y=\frac{c}{\gcd(a,b)}y&rsquo;$，$x,y$ 为 $ax+by=c$ 的一组解</li><li>若需要求 $x$ 的最小非负整数解，则将 $x=(x_0 \bmod m + m) \bmod m$ 作为最终的答案，其中 $m=\frac{b}{\gcd(a,b)}$</li></ol><h2 id=线性同余方程>线性同余方程</h2><h3 id=形式-1>形式</h3><p>$$
ax \equiv c \pmod{p}
$$</p><p>形如这样的方程，就被称线性同余方程。</p><h3 id=求解-1>求解</h3><p>任意的线性同余方程都可以与一个二元线性不定方程互相转化，比如上面的方程就与二元线性不定方程有如下关系：</p><p>$$
ax \equiv c \pmod{p} \iff ax+py=c
$$</p><p>所以可以把线性同余方程转化为一个二元线性不定方程，求出 $x$ 即可，包括有无解的判定条件都是一样的。</p><h3 id=代码>代码</h3><pre><code class=language-cpp>template &lt;typename T&gt; T exgcd(T a, T b, T &amp; x, T &amp; y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    } else {
        T d = exgcd(b, a % b, x, y);
        T t = x;
        x = y;
        y = t - a / b * y;
        return d;
    }
}

template &lt;typename T&gt; optional&lt;T&gt; solveEquation(T a, T c, T p) {
    a = (a % p + p) % p;
    c = (c % p + p) % p;
    T x, y;
    T d = exgcd(a, p, x, y);

    if (c % d != 0)
        return nullopt;
    
    x = (1ll * (c / d) * x % (p / d) + (p / d)) % (p / d);
    return x;
}
</code></pre><h2 id=中国剩余定理>中国剩余定理</h2><h3 id=形式-2>形式</h3><p>$$
\begin{cases}
x \equiv a_1 \pmod{m_1}\\
x \equiv a_2 \pmod{m_2}\\
\cdots\\
x \equiv a_n \pmod{m_n}\\
\end{cases}
\\
\forall i\ne j,\gcd(m_i,m_j)=1
$$</p><p>形如上面这样的线性同余方程组且满足每个方程的模数两两互质，就可以用中国剩余定理解决。中国剩余定理也叫做 <code>CRT (Chinese Remainder Theorem)</code>。</p><h3 id=求解-2>求解</h3><ol><li>令 $M=\prod_{i=1}^{n} m_i$，$M$ 不对任何数取模</li><li>对于 $m_i$，令 $M_i=\prod_{i\ne j}m_j=\frac{M}{m_i}$，$M_i^{-1}$ 为 $M_i$ 对 $m_i$ 的逆元，$c_i=M_iM_i^{-1}$，$c_i$ 不能对 $m_i$ 取模</li><li>令 $x=\sum_{i=1}^{n}a_ic_i \bmod M$，则 $x$ 为模 $M$ 意义下的唯一解</li></ol><h3 id=算法正确性证明>算法正确性证明</h3><p>对于 $\forall i\ne j$，$m_i\mid M_j$，故 $m_i\mid a_jc_j$，所以在模 $m_i$ 情况下，$x \equiv a_ic_i \pmod{m_i}$。</p><p>因为 $M_i^{-1}$ 为 $M_i$ 对 $m_i$ 的逆元，故在模 $m_i$ 的同余式中 $c_i\equiv 1 \pmod{m_i}$，$a_ic_i\equiv a_i \pmod{m_i}$，即 $x \equiv a_i \pmod{m_i}$，满足第 $i$ 个方程。</p><h3 id=解在模-m-意义下的唯一性证明>解在模 $M$ 意义下的唯一性证明</h3><p>设 $x,y$ 不相等，$x,y&lt;M$，但都满足方程组，则可以有下面的方程组：</p><p>$$
\begin{cases}
x - y\equiv 0 \pmod{m_1}\\
x - y\equiv 0 \pmod{m_2}\\
\cdots\\
x - y\equiv 0 \pmod{m_n}\\
\end{cases}
$$</p><p>则 $\forall i,m_i\mid |x-y|$，所以 $M \mid |x-y|$，即 $|x-y|=kM$，因为 $|x-y|&lt;M$，故 $k=0$，推出 $x=y$，与假设矛盾。</p><h3 id=代码-1>代码</h3><pre><code class=language-cpp>int exgcd(int a, int b, int &amp; x, int &amp; y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    } else {
        int d = exgcd(b, a % b, x, y);
        int t = x;
        x = y;
        y = t - (a / b) * y;
        return d;
    }
}

int solveEquation(int a, int c, int p) {
    int x, y;
    exgcd(a, p, x, y);
    x = (1ll * x * c % p + p) % p;
    return x;
}

inline int inv(int x, int p) {
    return solveEquation(x, 1, p);
}

int chineseRemainderTheorem(int n, int a[], int m[]) {
    int mod = 1, ans = 0;

    for (int i = 1; i &lt;= n; ++i)
        mod *= m[i];
    
    for (int i = 1; i &lt;= n; ++i) {
        int modi = mod / m[i];
        ans = (ans + 1ll * a[i] * modi * inv(modi)) % mod; // 用 exgcd 求逆元
    }

    return ans;
}
</code></pre><h2 id=扩展中国剩余定理>扩展中国剩余定理</h2><h3 id=形式-3>形式</h3><p>$$
\begin{cases}
a_1 x \equiv c_1 \pmod{m_1}\\
a_2 x \equiv c_2 \pmod{m_2}\\
\cdots\\
a_n x \equiv c_n \pmod{m_n}\\
\end{cases}
$$</p><p>相比普通中国剩余定理求解的方程组，少了模数互质的限制。</p><h3 id=求解-3>求解</h3><p>考虑合并方程。设当前要合并前 $i$ 个方程，显然可以转化为合并前 $i-1$ 个方程与第 $i$ 个方程。</p><p>设 $x_i$ 为合并前 $i$ 个方程的解，$d_i=\operatorname{lcm}(m_1,m_2,\dots,m_i)$。构造 $x_i=sx_{i-1}+t$，我们要使 $x_i$ 能够满足前 $i-1$ 个方程，就要满足以下条件：</p><ol><li>$\forall j &lt; i$，$a_j(sx_{i-1}+t)\equiv a_j x_{i-1} \pmod{m_j}$</li><li>$a_i(sx_{i-1}+t) \equiv c_i \pmod{m_i}$</li></ol><p>最简单的办法就是令 $s=1,t=d_{i-1}y_i$，并求一个合适的 $y_i$，也就是要求出以下方程的解 $y_i$：
$$
a_i d_{i-1}y_i \equiv c_i - a_i x_{i-1} \pmod{m_i}
$$</p><p>用 <code>exgcd</code> 解决，若该线性同余方程无解，则方程组无解，否则求出前 $i$ 个方程的解 $x_i$，进行下一次合并。</p><p>假设各个 $m_i$ 同阶，时间复杂度 $O(n \log_2 m_i)$。</p><h3 id=代码-2>代码</h3><pre><code class=language-cpp>int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}

int exgcd(int a, int b, int &amp; x, int &amp; y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    } else {
        int d = exgcd(b, a % b, x, y);
        int t = x;
        x = y;
        y = t - (a / b) * y;
        return d;
    }
}

optional&lt;int&gt; solveEquation(int a, int c, int p) {
    a = (a % p + p) % p;
    c = (c % p + p) % p;
    int x, y, d = exgcd(a, p, x, y);
    
    if (c % d)
        return nullopt;
    
    x *= (c / d);
    int m = p / d;
    x = (x % m + m) % m;
    return x;
}

optional&lt;int&gt; exChineseRemainderTheorem(int n, int a[], int c[], int m[]) {
    int x = 0, d = 1;
    
    for (int i = 1; i &lt;= n; ++i) {
        auto oy = solveEquation(a[i] * d, c[i] - a[i] * x, m[i]);

        if (!oy.has_value())
            return nullopt;
        
        int y = oy.value();
        int g = gcd(d, m[i]);
        d = d / g * m[i];
        x = (x + 1ll * (d / m[i] * g) * y) % d;
    }

    return x;
}
</code></pre><h2 id=bsgs>BSGS</h2><h3 id=离散对数>离散对数</h3><p>与离散对数相对的是我们熟悉的连续对数，也就是最经常接触的对数。而离散对数是在同余中的一个概念。</p><p>若在模 $m$ 意义下，$x$ 满足以下等式：</p><p>$$
a^x \equiv b \pmod{m}
$$</p><p>则 $x$ 为以 $a$ 为底的 $b$ 的离散对数。注意离散对数不同于连续对数，一个数的离散对数有很多个，并不是唯一的。</p><p>如果 $\gcd(a,m)=1$，则我们可以使用 <code>BSGS</code> 算法求解一个数的最小的离散对数。</p><h3 id=求解-4>求解</h3><p>因为 $\gcd(a,m)=1$，则 $a^k$ 对 $m$ 的逆元一定存在。所以我们可以把 $a^x$ 写成 $a^{ps-q}$ 并直接将 $a^{-q}$ 提取出来，即：</p><p>$$
a^{ps} \equiv ba^q \pmod{m}
$$</p><p>考虑暴力的思路，可以枚举两边的 $p,q$，如果有同余的两个 $a^{ps},ba^q$，就更新答案。</p><p>考虑到枚举会计算许多重复的东西，可以用某种数据结构维护映射表，存下每个 $(ba^q,q)$，再枚举左边找相应的同余的项。我们先假设 $x=ps-q \in [0,m)$，则当 $s=\lceil\sqrt{m}\rceil$ 时，时间复杂度最优，为 $\Theta(\sqrt{m})$ 或 $\Theta(\sqrt{m}\log_2 \sqrt{m})$，具体为哪种复杂度，取决于是用哈希表还是平衡树实现。</p><h3 id=可解性证明>可解性证明</h3><p>至于为什么一定有 $x\in [0,m)$，使用抽屉原理证明：</p><p>对于任意的 $x$，$a^x \bmod m$ 最多只有 $m$ 种取值，而在 $x\in [0,m]$ 时，一共有 $m+1$ 种指数，则根据抽屉原理得出必定存在一对 $x,y$ 满足 $a^x \equiv a^y \pmod{m}$。设 $t=|x-y|$，则 $a^x a^k=a^{x+t}a^k$，因为已经保证 $\gcd(a,m)=1$，则逆元一定存在，所以可以规定 $t\in\mathrm{Z}$，所以指数具有周期性，一定可以得到 $x\in [0,m)$。</p><h3 id=代码-3>代码</h3><pre><code class=language-cpp>int power(int x, int y, int m) {
    int res = 1;

    for (; y; y /= 2) {
        if (y % 2)
            res = 1ll * res * x % m;
        
        x = 1ll * x * x % m;
    }

    return res;
}

optional&lt;int&gt; bsgs(int a, int b, int m) {
    a %= m;
    b %= m;
    
    unordered_map&lt;int, int&gt; buc;
    int s = ceil(sqrt(m)), prod = b, base = power(a, s, m);
    buc[b] = 0;

    for (int i = 0; i &lt; s; ++i) {
        prod = 1ll * prod * a % m;
        buc[prod] = i;
    }

    prod = 1;

    for (int i = 0; i &lt;= s; ++i) {
        auto it = buc.find(prod);

        if (it != buc.end() &amp;&amp; i * s - it-&gt;second &gt;= 0)
            return i * s - it-&gt;second;
            
        prod = 1ll * prod * base % m;
    }

    return nullopt;
}
</code></pre><h2 id=扩展-bsgs>扩展 BSGS</h2><h3 id=形式-4>形式</h3><p>$$
a^x \equiv b \pmod{m}
$$</p><p>其中 $a,m$ 不一定互质。这种情况下，逆元不一定存在，也就不可以把指数拆成两个部分来优化。</p><p>考虑先把式子化为 $\gcd(a,m)=1$ 的形式。方法是不断提取出 $a$ 与 $m$ 互质的部分，任何整个式子同除以这个数。</p><p>$$
a \equiv c \pmod{m} \iff \frac{a}{d} \equiv \frac{c}{d} \pmod{\frac{m}{d}}\ (d\mid a \wedge d\mid c \wedge d\mid m)
$$</p><p>这个式子是同余式的基本性质。所以按照这样的方法提取：</p><p>$$
a^x \equiv b \pmod{m}\\
\Downarrow\\
\frac{a}{d_1}a^{x-1} \equiv \frac{b}{d_1} \pmod{\frac{m}{d_1}}\\
\Downarrow\\
\frac{a^2}{d_1 d_2}a^{x-2} \equiv \frac{b}{d_1 d_2} \pmod{\frac{m}{d_1 d_2}}\\
\Downarrow\\
\vdots\\
\Downarrow\\
\frac{a^k}{d_1 d_2\cdots d_k}a^{x-k} \equiv \frac{b}{d_1 d_2\cdots d_k} \pmod{\frac{m}{d_1 d_2\cdots d_k}}\\
$$</p><p>假设现在 $a$ 与 $\frac{m}{d_1 d_2\cdots d_k}$ 互质，就可以用 <code>BSGS</code> 求出最后一个方程的解 $x-k$，再加上 $k$ 就是 $x$ 了。</p><p>需要注意两点：</p><ol><li>若在提取过程中，出现 $d_1 d_2 \cdots d_i \nmid b$，则方程无法再继续提取，方程无解</li><li>有可能答案在 $[0,k)$ 内，只要 $O(k)$ 枚举检验即可。</li></ol><pre><code class=language-cpp>int gcd(int a, int b) {
    int t;

    while (b) {
        t = a;
        a = b;
        b = a % b;
    }
    
    return a;
}

int power(int x, int y, int m) {
    int res = 1;

    for (; y; y /= 2) {
        if (y % 2)
            res = 1ll * res * x % m;
        
        x = 1ll * x * x % m;
    }

    return res;
}

int exgcd(int a, int b, int &amp; x, int &amp; y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    } else {
        int d = exgcd(b, a % b, x, y);
        int t = x;
        x = y;
        y = t - a / b * y;
        return d;
    }
}

int inverse(int a, int p) {
    int x, y;
    exgcd(a, p, x, y);
    x = (x % p + p) % p;
    return x;
}

optional&lt;int&gt; bsgs(int a, int b, int m) {
    a %= m;
    b %= m;
    
    unordered_map&lt;int, int&gt; buc;
    int s = ceil(sqrt(m)), prod = b, base = power(a, s, m);
    buc[b] = 0;

    for (int i = 0; i &lt; s; ++i) {
        prod = 1ll * prod * a % m;
        buc[prod] = i;
    }

    prod = 1;

    for (int i = 0; i &lt;= s; ++i) {
        auto it = buc.find(prod);

        if (it != buc.end() &amp;&amp; i * s - it-&gt;second &gt;= 0)
            return i * s - it-&gt;second;
            
        prod = 1ll * prod * base % m;
    }

    return nullopt;
}

optional&lt;int&gt; exBsgs(int a, int b, int m) {
    a = (a % m + m) % m;
    b = (b % m + m) % m;
    
    if (m == 1 || b == 1)
        return 0;
        
    int prod = 1, d, k = 0;

    while (true) {
        d = gcd(a, m);
        
        if (d == 1)
            break;
        
        if (b % d)
            return nullopt;
        
        b /= d;
        m /= d;
        ++k;
        prod = prod * (a / d) % m;

        if (prod == b)
            return k;
    }

    auto res = bsgs(a, 1ll * b * inverse(prod, m) % p, m);

    if (!res.has_value())
        return nullopt;
    
    return res.value() + k;
}
</code></pre><h2 id=阶与原根>阶与原根</h2><h3 id=阶>阶</h3><p>对于一对互质的整数 $a,m$，若 $r$ 满足 $r \ne 0$ 且 $a^r \equiv 1 \pmod{m}$ 且不存在任何小于 $r$ 的正整数满足该同余式，则称 $r$ 为 $a$ 对 $m$ 的阶，记作 $r = \delta_m(a)$。</p><p><strong>Theorem 1</strong>：$0 &lt; \delta_m(a) \le \varphi(m)$。</p><p>若 $\gcd(a,m)=1$，则欧拉定理一定成立，即 $a^{\varphi(m)} \equiv 1 \pmod{m}$，显然 $0 &lt; \delta_m(a) \le \varphi(m)$。</p><p><strong>Theorem 2</strong>：若 $a^k \equiv 1 \pmod{m}$，则 $\delta_m(a) \mid k$。</p><p>假设满足 $\delta_m(a) \nmid k$ 但 $a^k \equiv 1 \pmod{m}$，则 $k=s\delta_m(a)+t$，其中 $t \in (0,\delta_m(a))$，所以：</p><p>$$
a^k \equiv (a^{\delta_m(a)})^sa^t \equiv a^t \pmod{m}
$$</p><p>根据阶的定义，$a^t \not\equiv 1 \pmod{m}$，所以矛盾，故 $\delta_m(a) \mid k$。</p><h3 id=原根>原根</h3><p>若 $a$ 满足 $\delta_m(a)=\varphi(m)$，则 $a$ 为 $m$ 的原根。</p><p><strong>Theorem 1</strong>：$a$ 为 $m$ 的原根的充要条件为 $\gcd(a,m)=1$ 且对于 $\varphi(m)$ 的每一个质因数，$a^{\frac{\varphi(m)}{p}} \not\equiv 1 \pmod{m}$。</p><p>根据这个定理，可以轻松判断一个数是否是另一个数的原根。</p><pre><code class=language-cpp>int gcd(int a, int b) {
    int t;

    while (b) {
        t = a;
        a = b;
        b = t % b;
    }

    return a;
}

int phi(int x) {
    int res = x;

    for (int i = 2; i * i &lt;= x; ++i) {
        if (x % i)
            continue;
        
        res = res / i * (i - 1);

        while (x % i)
            x /= i;
    }

    if (x &gt; 1)
        res = res / x * (x - 1);
    
    return res;
}

int power(int x, int y, int m) {
    int res = 1;

    for (; y; y /= 2) {
        if (y % 2)
            res = 1ll * res * x % m;
        
        x = 1ll * x * x % m;
    }

    return res;
}

bool isPrimitiveRoot(int a, int m) {
    if (gcd(a, m) != 1)
        return false;
    
    int pm = phi(m), tmp = pm;
    a %= m;

    for (int i = 2; i * i &lt;= tmp; ++i) {
        if (tmp % i)
            continue;
        
        if (power(a, pm / i, m) == 1)
            return false;
        
        while (tmp % i == 0)
            tmp /= i;
    }

    if (tmp &gt; 1)
        if (power(a, pm / tmp, m) == 1)
            return false;

    return true;
}
</code></pre><p><strong>Theorem 2</strong>：一个数 $m$ 有原根，当且仅当 $m$ 为 $2,4,p^k,2p^k$，其中 $k\in \mathrm{N^*}$，$p$ 为奇质数。</p><p><strong>Theorem 3</strong>：若一个数 $m$ 有原根，则其原根个数为 $\varphi(\varphi(m))$。</p><p><strong>Theorem 4</strong>：若一个数 $m$ 有原根，则其最小原根的数量级为 $m^{\frac{1}{4}}$。</p><p>根据这个性质，只需要暴力枚举每个数，求一个数的最小原根的时间复杂度是可以接受的。</p><pre><code class=language-cpp>int gcd(int a, int b) {
    int t;

    while (b) {
        t = a;
        a = b;
        b = t % b;
    }

    return a;
}

int phi(int x) {
    int res = x;

    for (int i = 2; i * i &lt;= x; ++i) {
        if (x % i)
            continue;
        
        res = res / i * (i - 1);

        while (x % i)
            x /= i;
    }

    if (x &gt; 1)
        res = res / x * (x - 1);
    
    return res;
}

int power(int x, int y, int m) {
    int res = 1;

    for (; y; y /= 2) {
        if (y % 2)
            res = 1ll * res * x % m;
        
        x = 1ll * x * x % m;
    }

    return res;
}

int primitiveRoot(int m) {
    int pm = phi(m), tmp = pm;
    vector&lt;int&gt; factor;

    for (int i = 2; i * i &lt;= tmp; ++i) {
        if (tmp % i)
            continue;
        
        factor.push_back(i);
        
        while (tmp % i == 0)
            tmp /= i;
    }

    if (tmp &gt; 1)
        factor.push_back(tmp);
    
    for (int i = 2; i &lt;= m; ++i) {
        if (gcd(i, m) != 1)
            continue;

        bool found = true;
        
        for (int p : factor) {
            if (power(i, pm / p, m) == 1) {
                found = false;
                break;
            }
        }

        if (found)
            return i;
    }

    return -1;
}
</code></pre><p><strong>Theorem 5</strong>：若 $a$ 为 $m$ 的原根，则 $a,a^2,a^3,\dots,a^{\varphi(m)}$ 两两模 $m$ 不同余。</p><p><strong>Theorem 6</strong>：若 $a$ 为 $m$ 的原根，则对于任意的 $x \in [1,\varphi(m)]$，一定有一个 $k$ 与其一一对应，满足 $x \equiv a^k \pmod{m}$ 且 $k\in [1,\varphi(m)]$，$k$ 被称为 $x$ 的指标，记作 $I(x)$。</p><p>比如 $m=13$，其最小原根 $a=2$，则把 $x$ 与 $I(x)$ 写成表格：</p><table><thead><tr><th style=text-align:center>$x$</th><th style=text-align:center>$1$</th><th style=text-align:center>$2$</th><th style=text-align:center>$3$</th><th style=text-align:center>$4$</th><th style=text-align:center>$5$</th><th style=text-align:center>$6$</th><th style=text-align:center>$7$</th><th style=text-align:center>$8$</th><th style=text-align:center>$9$</th><th style=text-align:center>$10$</th><th style=text-align:center>$11$</th><th style=text-align:center>$12$</th></tr></thead><tbody><tr><td style=text-align:center>$I(x)$</td><td style=text-align:center>$12$</td><td style=text-align:center>$1$</td><td style=text-align:center>$4$</td><td style=text-align:center>$2$</td><td style=text-align:center>$9$</td><td style=text-align:center>$5$</td><td style=text-align:center>$11$</td><td style=text-align:center>$3$</td><td style=text-align:center>$8$</td><td style=text-align:center>$10$</td><td style=text-align:center>$7$</td><td style=text-align:center>$6$</td></tr></tbody></table><p>这个定理可以用于把底数转换为原根的幂，可以利用这个性质解模数为质数的 $N$ 次剩余问题。</p><h2 id=n-次剩余>N 次剩余</h2><h3 id=形式-5>形式</h3><p>$$
x^n \equiv a \pmod{m}
$$</p><p>其中 $m$ 为奇质数，求 $x\in [0,m)$。由于 $m$ 不是奇质数的方法较复杂，这里不考虑。</p><h3 id=求解-5>求解</h3><p>设 $g$ 为其原根，则可以利用原根和指标的性质将 $x$ 转化为 $g^y$，即：</p><p>$$
(g^y)^n \equiv (g^n)^y \equiv a \pmod{m}
$$</p><p>这样就可以用 <code>BSGS</code> 求出 $y$，再用快速幂求得 $x$ 即可。</p><p>也可以再将 $a$ 化为 $g^z$，然后方程化为：</p><p>$$
g^{ny} \equiv g^z \pmod{m}
$$</p><p>于是就可以解出线性同余方程的解 $y$：</p><p>$$
ny \equiv z \pmod{m}
$$</p><p>代码就不写了，上面组合一下就可以了。</p></div><div class=article-footer><blockquote class=mt-2x><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接:</strong>
<a href=https://ctj12461.vercel.app/contents/20220213-congruence-equation-note/ title=同余方程学习笔记 target=_blank rel=external>https://ctj12461.vercel.app/contents/20220213-congruence-equation-note/</a></li><li class=post-copyright-license><strong>License:</strong>
<a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=external>CC BY-NC 4.0</a></li></ul></blockquote><div class="panel panel-default panel-badger"><div class=panel-body><figure class=media><div class=media-left><a href=https://github.com/ctj12461 target=_blank class="img-burn thumb-sm visible-lg"><img src=https://ctj12461.vercel.app/avatar.jpg class="img-rounded w-full" alt></a></div><div class=media-body><h3 class=media-heading><a href=https://github.com/ctj12461 target=_blank><span class=text-dark>ctj12461</span><small class=ml-1x></small></a></h3><div>当你想要放弃时，想想你为什么开始。</div></div></figure></div></div></div></article></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class=bar-inner><ul class="pager pull-left"><li class=prev><a href=https://ctj12461.vercel.app/about/ title=About><i class="icon icon-angle-left" aria-hidden=true></i><span>&nbsp;&nbsp;下一篇</span></a></li><li class=next><a href=https://ctj12461.vercel.app/contents/20220220-mobius-inversion-note/ title=莫比乌斯反演学习笔记><span>上一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden=true></i></a></li><li class=toggle-toc><a class="toggle-btn collapsed" data-toggle=collapse href=#collapseToc aria-expanded=false title=文章目录 role=button><span>[&nbsp;</span><span>文章目录</span>
<i class="text-collapsed icon icon-anchor"></i>
<i class="text-in icon icon-close"></i>
<span>]</span></a></li></ul><div class=bar-right><div class=share-component data-sites=weibo,qq,wechat,facebook,twitter data-mobile-sites=weibo,qq,qzone></div></div></div></nav></main><footer class=footer itemscope itemtype=http://schema.org/WPFooter><ul class=social-links><li><a href=https://github.com/ctj12461 target=_blank title=github data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li><li><a href=https://ctj12461.vercel.app/index.xml target=_blank title=rss data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li></ul><div class=copyright>&copy;2022 -
2022<div class=publishby>Theme by <a href=https://github.com/xiaoheiAh target=_blank>xiaoheiAh </a>base on<a href=https://github.com/xiaoheiAh/hugo-theme-pure target=_blank> pure</a>.</div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type=text/x-mathjax-config>
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script type=text/javascript src=https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js></script>
<script type=text/javascript src=https://cdn.staticfile.org/highlight.js/9.15.10/languages/python.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/highlight.js/9.15.10/languages/javascript.min.js defer></script><script>hljs.configure({tabReplace:"    ",classPrefix:''}),hljs.initHighlightingOnLoad()</script>
<script src=https://ctj12461.vercel.app/js/application.min.e720b935330b2a176cfb4b8bd9a6cc632caf6b752f94e87c62152a9557ff6d15.js></script>
<script src=https://ctj12461.vercel.app/js/plugin.min.334875d4d4a72afb866e446df61b5f4bf1f0a516d1303166f52f7804d17ef3ab.js></script>
<script>(function(e){var t={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"https://ctj12461.vercel.app",CONTENT_URL:"https://ctj12461.vercel.app/searchindex.json "};e.INSIGHT_CONFIG=t})(window)</script><script type=text/javascript src=https://ctj12461.vercel.app/js/insight.min.759e5002714e12761afcd512f103d39c86573165db51972dd3b24df6eddf238ed3e3e85c1988e96cba09419d1deccdeb68c15284f2c3d03049fad53c11774524.js defer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js></script>
<script>tocbot.init({tocSelector:".js-toc",contentSelector:".js-toc-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0})</script><script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script></body></html>