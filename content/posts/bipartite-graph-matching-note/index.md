---
title: "二分图匹配学习笔记"
subtitle: ""
date: 2022-02-22T13:31:06+08:00
draft: false
author: ""
authorLink: ""
description: ""
keywords: ""
license: "本文以 CC BY-NC 4.0 许可证发布"
comment: false
weight: 0

tags:
  - OI
  - 图论
  - 二分图
  - 建模
  - C++
categories:
  - 笔记

hiddenFromHomePage: false
hiddenFromSearch: false

summary: ""
resources:
- name: featured-image
  src: featured-image.jpg
- name: featured-image-preview
  src: featured-image-preview.jpg

toc:
  enable: true
math:
  enable: true
lightgallery: false
seo:
  images: []

# See details front matter: /theme-documentation-content/#front-matter
---

## 二分图
### 定义
如果一个图 $G=(V,E)$ 中的结点可以被分为两个部分，且两个部分之内的点互相没有连边，则称这种图为二分图。如果每个结点的度数相等且都为 $k$，则称这种二分图为 $k$ - 正则二分图。

### 判断
对图的结点进行黑白染色，相连的结点染不同的颜色，若最后满足每条边的两个端点颜色不相同，则这个图是二分图。树也是二分图。

### 匹配
在二分图的边集中选出一个非空子集，且这个非空子集内没有两条边连接了一个相同的端点，则这个非空子集被称为二分图的一个匹配，同样对于一般图也有类似的概念。

若一个匹配的所含的边数最大，则称这个匹配为最大匹配。

若二分图两边的结点个数相同，且存在一个匹配满足其中的边连接了所有的点，则这个匹配被称为这个二分图的完美匹配或者完备匹配。

若每条边有边权，且一个匹配的所含的边的权值和最大，则这个匹配被称为这个二分图的最大权匹配。

## 匈牙利算法
### 交替路
假设在二分图最大匹配的过程中，已经找到了一些边作为一个匹配，则一条交替路就是一个匹配边和非匹配边交替连接组成的简单路径。

根据二分图的定义，假设一条交替路的起点在左边，且第一条边是匹配边，则这条交替路中的匹配边一定都是从左边到右边，而非匹配边一定是从右边到左边。

交替路上的结点最多连接一条匹配边和一条非匹配边，所以如果把交替路上的匹配边变为非匹配边，非匹配边变为匹配边，则仍然满足条件，也就是交替路边集的匹配边集的补集也可以是匹配。

### 增广路
匈牙利算法的核心就是找增广路，这条增广路是一条交替路。每次增广从左边开始，第一条边是非匹配边，最后一条边也是非匹配边，根据上文的描述，这样的路径的边数为奇数，非匹配边个数比匹配边个数多 $1$，若把匹配边与非匹配边反转，则反转后的边集仍然是一个合法的匹配，且比原来的匹配的边数多了 $1$。如果能找到一条这样的增广路，则此次增广成功。

具体来说，比如一个左边的结点 $x$ 找到了一个右边的结点 $y$，它没有与其他左边的结点匹配过，则 $e(x,y)$ 可以作为一个匹配边，反转边集前，有 $1$ 条匹配边，$0$ 条非匹配边，增广成功。

如果右边的结点 $y$ 已经有匹配了，那么就可以让原来 $y$ 的匹配 $x'$ 新找一个点 $y'$，如果能够找到这个 $y'$，那么 $e(x',y')$ 成为一个匹配边，$y$ 就无需和 $x'$ 匹配了，也就是说 $y$ 已经变为了一个没有匹配的点，$x$ 就可以与 $y$ 匹配了。如果 $x'$ 找不到 $y'$，那么 $x'$ 就要保持原样，和 $y$ 匹配，那么 $x$ 就不可以和 $y$ 匹配，只能继续寻找下一个可能的结点。

对于 $x'$，它找 $y'$ 的过程和 $x$ 找 $y$ 的过程是一样的，所以可以递归实现。

总结一下，一个结点 $x$ 的寻找过程可以分为两种情况：
1. 找到一个未匹配结点 $y$，与它匹配
2. 让一个已匹配的结点 $y$ 和 $y$ 的另一边的结点 $x'$ 取消匹配，让 $x'$ 找新匹配点 $y'$，若取消成功，则 $x$ 与 $y$ 可以匹配

可以发现 $x$ 寻找成功，则匹配边都变成了非匹配边，原来的非匹配边都变成了匹配边，也就是找增广路的过程，然后对这条增广路的匹配边与非匹配边反转，匹配边数加 $1$，就这样对于左边的每个结点都增广，尝试找到左边的每个结点对应的匹配，最后就找到了最大匹配。

### 代码实现
```cpp
bool augment(int x) {
    for (int y : graph[x]) {
        if (vis[y])
            continue;
        // 无论是否增广成功，对于当前增广路上的结点，下次都可以不用再走这个点
        vis[y] = true;
        // y 没有匹配或者取消 y 的匹配成功
        if (!match[y] || augment(match[y])) {
            match[y] = x;
            return true; // 找到匹配点，增广成功
        }
    }

    return false; // 没有找到结点，增广失败
}

int hungary() {
    int res = 0;

    for (int i = 1; i <= n; ++i)
        match[i] = 0;
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) // 每次增广都要清空
            vis[j] = false;
        
        if (augment(i))
            ++res;
    }

    return res;
}
```

## 二分图最大匹配性质
### 相关概念
假设有一个图 $G=(V,E)$，下面是一些常见的概念：

- **边覆盖**：边覆盖是 $E$ 的一个子集 $E'$，$\forall\ x \in E$，满足 $x$ 是边 $e$ 的端点，且 $e \in E'$，也就是 $E'$ 中的边的端点的并集是 $V$
- **独立集**：独立集是 $V$ 的一个子集 $V'$，$\forall\ x,y \in V$，满足 $e(x,y) \notin E$，也就是独立集中的点互不相连
- **团**：团是图 $G$ 的一个子图$G'=(V',E')$，$V' \subset V$，$E' \subset E$，且团是完全图，即 $\forall\ x,y \in V$，满足 $e(x,y) \in E'$，也就是团中的点互相连边
- **点覆盖**：点覆盖是 $V$ 的一个子集 $V'$，$\forall\ e(x,y) \in V$，满足 $x \in V'$ 或 $y \in V'$，也就是 $V'$ 中的点所连的边的并集是 $E$

### 等式
若一个图是二分图，则有如下性质：
- $|$最小边覆盖$| = |V| - |$最大匹配$|$
- $|$最大独立集$| = |V| - |$最大匹配$|$
- $|$补图的最大团$| = |$最大独立集$|$
- $|$最小点覆盖$| = |$最大匹配$|$

### 与 DAG 的关系
对于一个 DAG $G$，构造二分图 $G'$，满足 $G$ 中的有向边 $e(x,y)$ 与 $G'$ 中的边 $e(x,y')$ 一一对应，其中 $x$ 和 $y'$ 在两边。此时满足 $|G$ 的最小路径覆盖$| = |G'$ 的最小点覆盖$|$。路径覆盖指选出一些路径 $p$ 组成一个集合 $P$，满足图中所有点都被至少一个 $p$ 经过，且 $p \in P$。

### 建模相关
可以通过一些转化把题目转化为二分图的问题，用上面的性质解决，详情见下面的例题。